.C	フック、カスタマイズ（例を見る方がはやいかも）
=E.C	Hooks
.n	hooks
.l	hook

.S	インタプリタとconfig.ph
=E.S	Interpreter and config.ph
.xref	command-hook

インタプリタなので(例えば config.ph に)フックを定義すれば適当な場所で
そのHOOKは評価され実行されます。
=E
Perl is an interpreter language. FML evaluates several hooks in a lot
of places. In this chapter we describe hooks. You can use complicated
control of FML and dynamic configuration changes by using hooks.

そのフックでちょっと複雑な設定やダイナミックなサーバの挙動の変更をした
りできます。config.ph で定義するのでMLが複数あってもMLごとに変更できる
わけです。一方 sitedef.ph で行なえばML共通のHOOKを仕掛けることができま
す。

以下 HOOKおよび、それを使ういくつかの例です。

.S	$START_HOOK
.l	$START_HOOK
.k	$START_HOOK

評価されるタイミングは、
	ヘッダの各フィールドの切り出しは終っている。
	が、配送orコマンド本体を行なう前
である。
=E
FML evaluates $START_HOOK, after header parsing and fundamental checks
but before main distribution and command functions

.if LANG == JAPANESE
例: 配送前にもし #ではじまらない行が８行以上あれば、たとえ#ではじまる
行があっても普通のメールとおもうようにする。

$START_HOOK =q%
    if ($Envelope{'nlines'} - $Envelope{'nclines'} >= 8) {
	undef $Envelope{'mode:uip'};
    }
%;
.fi

.S	$HEADER_ADD_HOOK
.l	$HEADER_ADD_HOOK
.k	$HEADER_ADD_HOOK

ヘッダに”新たに”つけくわえるフィールドをかいてカスタマイズするための
フック。
=E
Evaluated before header generation of distribution articles. $body
variable is used.

現在では $body という変数はこのためだけに使われる。
＃注意：昔は違った

例(昔のやり方):
=E
Example: add the field "X-Baycity-Weather: Mizumaki" (riddle:-).

    $HEADER_ADD_HOOK = q#
	$body .= "X-Baycity-Weather: Mizumaki\n";
    #;

ヘッダに X-Baycity-Weather: Mizumaki とつけくわえる(意味不明(笑))
現在では同じことは例えば 
=E
is the same as

	&DEFINE_FIELD_FORCED("X-Baycity-Weather","Mizumaki");

のような関数でできる。

例２:
=E
Example 2: append the original Message-Id.

Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.asia>

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: ".
	sprintf("<%4d%02d%02d.%05d.%s>\n", 1900 + $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.asia");
#;

.S	$DISTRIBUTE_START_HOOK
.l	$DISTRIBUTE_START_HOOK
.k	$DISTRIBUTE_START_HOOK

配送を始める関数に入った時に最初に評価されるHOOK
=E
evaluated in the begging of &Distribute which is the main function of
distribution.

.S	$SMTP_OPEN_HOOK
.l	$SMTP_OPEN_HOOK
.k	$SMTP_OPEN_HOOK

配送時にはこのフックの後 Sendmail へ渡すヘッダの処理が始まります。ここ
で強制的かつダイナミックにヘッダの内容を変えたりすると効果的です。単に
ヘッダの各フィールドを書き換えるのなら &DEFINE_FIELDうじゃうじゃ 関数
シリーズが用意されています。そちらを使うのがよいでしょう。
SMTPという名前がついていますがSMTP汎用ではありません。歴史的な名前です。
.xref	&DEFINE_FIELD_FORCED &DEFINE_FIELD_ORIGINAL
=E
The variable name is historical, so ambiguous. Today this hook is
evaluated after $DISTRIBUTE_START_HOOK but before $HEADER_ADD_HOOK.
You can understand faster to see libdist.pl.

例:	Reply-To: フィールドをML自体へ強制書き換え
	&DEFINE_FIELD_うじゃうじゃ以外にも別解はいくつかあるが解1
=E
Example: Overwrite Reply-To: field of distribution mail. Today we
recommend to use $DEFINE_FIELD_FORCED.

$SMTP_OPEN_HOOK = q#
	$Envelope{'fh:reply-to:'} = $MAIL_LIST; 	
#;

例2:	Precedence: を bulk へ
=E
Example 2: overwrite Precedence: to set "bulk".

$SMTP_OPEN_HOOK = q#
	$Envelope{'h:Precedence:'} = 'bulk';
#;

Precedence: に関しては実は config.ph で $PRECEDENCE = 'bulk'; でＯＫで
す。

.S	$DISTRIBUTE_CLOSE_HOOK (SMTP_CLOSE_HOOK)
.l	$DISTRIBUTE_CLOSE_HOOK
.k	$DISTRIBUTE_CLOSE_HOOK
.l	$SMTP_CLOSE_HOOK
.k	$SMTP_CLOSE_HOOK

$DISTRIBUTE_CLOSE_HOOK は配送が終った後でかつまだロックされている状態
で実行されます。具体的には &Distribute; を離れる直前に実行されます。
$SMTP_CLOSE_HOOK は昔の名前です。
=E
$DISTRIBUTE_CLOSE_HOOK is evaluated in the last of &Distribute, which
is the main function of distribution. $SMTP_CLOSE_HOOK is an old
obsolete name, so both are same.

.S	$FML_EXIT_HOOK
.l	$FML_EXIT_HOOK
.k	$FML_EXIT_HOOK

fml.pl が最後に実行する フック。このときすでに 『排他制御の lock が解
除されている』いることに注意して下さい。
=E
fml.pl evaluates this hook in the last. This evaluation is after
unlock! This hook is the last hook but $FML_EXIT_PROG is executed
after this since $FML_EXIT_PROG is to start a new process.

.S	$FML_EXIT_PROG
.l	$FML_EXIT_PROG
.k	$FML_EXIT_PROG

In the last of fml.pl, FML starts $FML_EXIT_PROG as a new process by
exec(2) system call (precisely speaking via exec(3)).

.S	$MSEND_START_HOOK
.l	$MSEND_START_HOOK
.k	$MSEND_START_HOOK

After msend.pl is initialized, msend.pl evaluates this hook in the
begging of the main function. See msend.pl internal.

.S	$MSEND_HEADER_HOOK
.l	$MSEND_HEADER_HOOK
.k	$MSEND_HEADER_HOOK

In the header generation when sending digest mail creation time.

.S	$MSEND_OPT_HOOK
.l	$MSEND_OPT_HOOK
.k	$MSEND_OPT_HOOK

msend.pl evaluates $MSEND_OPT_HOOK in the &MSendInit.

例:
デフォールトでは、まとめおくり や mget の時の Subject は
=E
In default, digest delivery's subject is 

Subject: Matomete Send [PLAINTEXT(UNIX FROM)] (1/1) (Elena Lolobrigita ML)

のようになります。が    ↑↑↑↑ここのところの文章がきにいらないので
OVERWRITE したいときは、
=E
To overwrite this, you can set the following ...

$MSEND_OPT_HOOK = q%
    $MSendOpt{'#uf'} = "#Overwritten... $MSendOpt{'#uf'}";
%;

このように、
		$MSEND_OPT_HOOK 
に 連想配列の 

	#モード の値が #説明の文章

のようにかいてください。なにをやってるのかは、libutils.pl の中の
sub MSendModeSet  という関数を見るとわかるとおもいます。
.xref	$MSEND_SUBJECT_TEMPLATE

.S	$REPORT_HEADER_CONFIG_HOOK
.l	$REPORT_HEADER_CONFIG_HOOK
.k	$REPORT_HEADER_CONFIG_HOOK

SMTP 配送ライブラリへ渡す直前に評価されるフック。
=E
In SMTP library, this hook is evaluated just before the mail is passed
to &Smtp; This routine is used in a reply mail of command results.

.S	$COMMAND_HOOK (obsolete on to add new commands technique)
.l	$COMMAND_HOOK
.l	command-hook
.k	コマンドのカスタマイズ
.k	$COMMAND_HOOK

インタプリタですから、コマンドでそのML独自の機能をもたせたかったら
config.ph にセットして下さい(そうすれば、MLが複数あってもそれぞれ別様
にカスタマイズできる)。以下の例はリストを返すようにするコマンド "list" 
を新たに付け加える例です。
=E
This hook is evaluated in the command execution loop. Historically
this hook is to add a new command you customize. Today this is
obsolete, to add a new command is that you write a new routine and
inject "command name" and the function name (reference to the
function) to %LocalProcedure.  Using this hook is obsolete. This
example is to add a new command "list" which send back $DIR/list
file.
.xref add-procedures my-file-sendback-command

--------- in config.ph ---------
$COMMAND_HOOK =q#
      if(/list/io) {
	  &Log("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;
--------- in config.ph ---------

この例だとは # 〜 # の間をquoteしています。#...コメントをとかははさめ
ません。
＃q syntax は q# ... # の形で任意の二つの文字（今はたまたま #）の間を
quoteする関数（本当の意味での関数ではないそうだ）

注意: 実はHOOKをかけなくても上のような簡単なコマンドは 
.ptr{my-file-sendback-command} のように簡単に作れます。

なお $COMMAND_HOOK はコマンドチェックのループの中で評価されます。つま
り一般にメールのコマンドの数だけ評価されることになります。こういうこと
をしても overhead にならないだろういうのは、大抵コマンドは一メールあた
り1、2回しか呼ばれないので、eval は重たいけど、1、2度ならまぁ便利さの
方が優先という観察と経験に基づいてます。ただ前述のようにこのやり方はす
でに obsolete です。

.S	$COMMAND_HOOK Example: add "list" and "rsummary"
.k	"list" command (example)
.k	"rsummary" command (example)

FYI: rsummary は現在は summary 引数 の形で実行できます
=E
FYI: "rsummay" command below is available in the context of "summary"
command.

例:
	list		list リストファイルを取り寄せる
.xref	my-file-sendback-command

sub Command では $to にコマンドの結果の返し先が設定されています。

$COMMAND_HOOK は sub Command の中で定義されています。

$COMMAND_HOOK =q#
      if (/list/io) {
	  &Log("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;

例:
rsummary 100-200	Count 100-200 までのサマリの部分だけを見る
=E
Example: to show summary of article number from 100 to 200 articles.

$COMMAND_HOOK = q#
    if (/rsummary/io) {
	&Log("R Summary ". $Fld[2]);
	if ($Fld[2] =~ /^(\d+)\-(\d+)$/) {
	    local($r);
	    local($a) = $1; 
	    local($b) = $2; 

	    open(TMP, $SUMMARY_FILE) || do { &Log($!); next GivenCommands;};
	    while (<TMP>) {
		if (/\[$a:/ .. /\[$b:/) { $r .= $_;}
	    }
	    close(TMP);

	    &Mesg(*e, "Restricted  Summary $Fld[2]\n$r\n");
        }
	else {
	    &Log("Summary ($From_address)");
	    &SendFile($to, "Summary $ML_FN", "$DIR/summary");
	}

	next GivenCommands;
    }
#;

.S	HOOKによるコマンド実装例: "sget"
=E.S	Example: "sget"
.key	$COMMAND_HOOK

sget uja		subjectに uja というキーワードが入っているファ
			イルを取り寄せる

$COMMAND_HOOK =q#
    if (/^sget$/io) {
	local($s);

	if (open(F, $SUMMARY_FILE)) {
	    while (<F>) {
		/$Fld[2]/ && do {/\s\[(\d+):/ && ($s .= $s ? ",$1" : $1);}
	    }
	    close(F);
	}
	else {
	    $s = "Fail";
	    &Log("Search and Get $Fld[2] Fail");
	    next GivenCommands;
	}

	&Log("Search and Get $Fld[2]");
	&Sendmail($to, "Search and Get $Fld[2] $ML_FN", $s);
    }
#;

.S	HOOKによるコマンド実装例: "admin" アドミンコマンド
=E.S	"admin" command by $COMMAND_HOOK
.k	admin コマンド
.xref	REMOTE-ADMINISTRATION 

"admin" アドミンコマンド って昔HOOKで実装していましたが、今は変数が
あります。
=E
Obsolete. Long time ago, FML provides "admin" commands by
$COMMAND_HOOK.

.S	HOOKの例:ある行数を越えるメールは廃棄する設定
=E.S	Example: to discard an over length mail
.k	$START_HOOK

We discard mail with over 1000 lines. Today please use
$INCOMING_MAIL_SIZE_LIMIT for incoming mail size upper limit.
.xref $INCOMING_MAIL_SIZE_LIMIT
	
$START_HOOK = q#
    if ($Envelope{'nlines'} > 1000) {
	&Warn("Discarded on the behalf of too Large Mail", &WholeMail);	
	$DO_NOTHING = 1;
    }
#;

.S	$START_HOOK でＭＬメンバーの人数制限をする
=E.S	$START_HOOK: limit the number of member 
.k	$START_HOOK

ファイル $LIMIT_OVER_FILE にごめんなさいの文章を書いておく。
Ref: START_HOOK => .ptr{$START_HOOK}
=E
A file $LIMIT_OVER_FILE is to say "Sorry for that I cannot regist you
since this ML is over the limit of ML member".
Ref: START_HOOK => .ptr{$START_HOOK}

$START_HOOK = q%;

$MAX_MEMBER = 100;

$LIMIT_OVER_FILE = "$DIR/limit.over"; 

sub WC
{
    local($f) = @_;
    local($lines) = 0;

    open(TMP, $f) || return 0;
    while (<TMP>) { 
	next if /^\#/;
        $lines++;
    }
    close(TMP);

    $lines;
}


if (&WC($ACTIVE_LIST) > $MAX_MEMBER) {
    &SendFile($From_address, 
	      "Sorry, the mailing list member exceeds the limit $ML_FN", 
	      $LIMIT_OVER_FILE);
    $DO_NOTHING = 1;
}


%;

.S	$MODE_BIFURCATE_HOOK
.l	$MODE_BIFURCATE_HOOK
.k	$MODE_BIFURCATE_HOOK

モードが分岐する関数の中で呼ばれるHOOK。ほとんど先頭で呼ばれる。実際に
は sub ModeBifurcate を見ないと何だか分からないだろう。
=E
Called in the first stage of &ModeBifurcate where fml.pl running mode
changes.

.S	$COMMAND_FILTER_HOOK
.l	$COMMAND_FILTER_HOOK
.k	$COMMAND_FILTER_HOOK
.xref	EnvelopeFilter

.S	$REJECT_COMMAND_FILTER_HOOK
.l	$REJECT_COMMAND_FILTER_HOOK
.k	$REJECT_COMMAND_FILTER_HOOK
.xref	EnvelopeFilter

.S	$DISTRIBUTE_SUMMARY_HOOK
.l	$DISTRIBUTE_SUMMARY_HOOK
.k	$DISTRIBUTE_SUMMARY_HOOK

$DISTRIBUTE_SUMMARY_HOOK = q#
	&Append2(sprintf("%s [%d:%s] %s", 
			 $Now, $ID, substr($From_address, 0, 15), $s),
		 $SUMMARY_FILE);
#;

このHOOKが評価される時 $s は subject になっています。
=E
$s is the subject when this hook is evaluated.

.# $Id$
.# Copyright (C) 1993-1998 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1998 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
