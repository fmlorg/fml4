.C	インストールについて
.l	install


.S	makefml: 初心者向けインストール・インターフェイス
.k	makefml: 初心者向けインストール・インターフェイス
.k	makefml
.k	sbin/makefml

fml のソースファイルを広げて INSTALL というファイルを見て下さい。現在
では makefml という対話的にインストールや簡単なＭＬの設定を行なうイン
ターフェイスが附属しています。それの使い方が INSTALL というファイルです。

INSTALL + α でこの doc/op というファイルと INSTALL の中間に当たるユー
ザーズガイドが整備される予定ですが、2.1-RELEASE に間に合うように統合さ
れるかどうかはわかりません。FAQ も分離するべきなのでしょうが、この辺す
べてそこまで手が回る暇がないので整備される日は来ないかも知れません。
＃やってくれる人募集です。英訳もすすんでない…

config.ph に現れるハッシュ %MAKE_FML は makefml で使うためのものです。
makefml 以外では使われません。
.k	%MAKE_FML


.S	Version up について

ソースを広げてインストールと同様に makefml install をして下さい。
手動でも十分できますが、makefml の方がよいでしょう。実作業としては

	ソースの下の src 階層以下に perl scripts は集められています
	よって version up はこの src/*.pl をコピー(cp - pr)する
	必要に応じて bin/ sbin/ cf/ 等も copy する。
	ドキュメントを copy する

ことを行ないます。makefml install を使えば必要な作業を行なってくれます。
注意：fml 1.x 時代の場合の注意は .ptr{appendix:fmlR1}


.S	本当に残しておく必要のあるファイルは？

たまにどこが必要な部分ですか？と聞かれますが、makefml install を使えば
core の部分だけが概ねインストールされます。ドキュメントが大きいので 
www.sapporo.iij.ad.jp を見るから doc/html は要らないから消すということ
はありうるでしょう。

makefml でインストールすると document 群も入れます。documents は大きい
です。インストール先の doc の下にまとまってるので、ここは消して構いま
せん。祖霊がいに何を消していいかは機能をどこまで使うかに依存しているの
で一概にはいえません。


.S	インストール後にサーバの設定(パラメータ)をいじる
.l	how-to-customize-parameter
.key	fml.plの起動のしかた
.key	exec fml.pl
.key	$DIR
.key	$LIBDIR
.key	fml.c
.key	fml.plの引数
.xref	fml-maintenance
.xref	order-of-option-effeciency
.xref	init-data-structure

複数のやり方があります。本質的にはどれも configuration file を書き換え
るということです。コマンドラインオプションで同じ設定が可能ですが、保守
や makefml インターフェイスとの整合性のため 2.1-RELEASE では推奨されて
いません。


1	makefml

初心者で内部構造がよくわからない場合はインストール時に使った makefml 
というコマンドを使って、ＭＬの設定ができます。makefml config ML で 
ML-directory/config.ph が変更できます。よく使いそうだと思われる基本的
な設定はこれで十分でしょう。この辺のことについては INSTALL を読んで下
さい。

インターフェイスが複雑になるのが嫌なので、ここでいじることのできる設定
は基本的なものに限っています。将来もできるだけ makefml config は少数精
鋭の config のみを入れていく予定です。


2	config.ph

それ以上のことがしたい場合は各メーリングリストの config.ph をいじって
下さい。

3	sitedef.ph

複数のメーリングリストに共通の設定であれば makefml が fml.pl や 
libsmtp.pl を入れた場所に sitedef.ph というファイルを作ってこの中に書
いておくと config.ph の評価の後に sitedef.ph が評価されます。
コマンド等のマシン共通の設定にこれを使うとちょっと便利かもしれません。

例：
	/usr/local/fml/sitedef.ph

を作り、この中に例えば

	$HOST = "mlrelay.dokka.org";
	1;

とか共通の設定を書く(この例では↑は配送に使うマシンをデフォールトから
mlrela.dokka.org(注意:これは架空のホストです)というマシンに変更。


.S	include ファイル (fml.plの呼び方、引数の渡し方)
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list
.label	calling-fml.pl
.seealso fml-uid, plural-handling-1, plural-handling-2

fml の起動の仕方は

	fml.pl config.phのあるdirectry libary-path(必要なら)

の形です。これと同じこと sendmail にやらせるためには /etc/aliases 等に
次のように書きます。いろいろな書き方がありますが、それがちゃんと動くか
否かは sendmail の version に依存です。

例: Elena メーリングリストの場合

   /etc/aliases は

	Elena: :include:/var/spool/ml/Elena/include
	owner-Elena: fukachan
	Elena-request: fukachan
	Elena-admin: fukachan

   /var/spool/ml/Elena/include の中身は

	"|/usr/local/fml/fml.pl directory"

こうすると include ファイル の所有者のIDで fml.pl は動き、sendmail は 
そのプロセス (fml.pl) の STDIN へ来たメールを入れます。

なお単純にこれだけではだめでおまじないが必要なOSもいろいろあります。
OS によるfml.plの呼び方の違い一覧は次の章を見て下さい。
.label	{calling-fml.pl-and-OS}
.key	OS_dependence


.S	C wrapper
.label	c-wrapper
.k	fml
.k	fml.c

:include: 構文が使えない OS もしくは古い sendmail の場合は C wrapper 
を使う必要があります。
C wrapper は setuid して使います。setuid された program の引数でfml.pl 
を渡すとかいうことはしてはいけません。
＃そういうことをする外国のソフトがあるようですが…何考えてるんだろ

makefml が見本の fml.c を作ってくれているのでそれを compile して作りま
す。fml.c は環境に併せて変更されていますが一応確認はしてみてください。
fml.c には実行する内容が hard coding されているので必要なら直接 edit 
して下さい。

fml.c の内容は

	fml.plの場所   config.phのある場所   ライブラリの場所

を exec する C の program というだけのものです。

例： fml.c

execl("/usr/local/fml/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/var/spool/ml/Elena",   /* config.ph は どこ？ */
      "/usr/lcoal/fml",        /* fml packeage の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル (doc/op) 等を見ながら直してみて下さい。


.S	C wrapper program fml on 4.3BSD
.k	fml.c
.k	fml

:include: 構文が使えない時は、setuid された fml という C の wrapper
program を経由して

	/usr/local/fml/fml.pl directory

を実行するという設定をします。makefml を使えば各メーリングリストごとに
専用の fml.c が作成されています。その directory で

	% make fml 

とすると作成されます。fml.c の中で fml.pl directory ... という形で呼ぶ
ようになってます。


.S	C wrapper program fml on 4.4BSD or POSIX
.label	calling-fml.pl-POSIX
.key	POSIXなsetuid
.key	POSIX

もし POSIX なら 

	% make CFLAGS=-DPOSIX 

として fml を作成して下さい。uid と gid は makefml newml 時に fml.c に
埋め込まれています。fml ができたら root権限で

   # chown root fml
   # chmod 4755 fml

これで、setuid が動くはずです。この場合は root の権限で一回動いて あな
たのuidに設定して fml.pl を起動します。install の仕方によっては 
permission をもっと厳しくできるはずです。設定には十分な注意を払って下
さい。fml は root 以外は絶対に書けない場所にインストールするべきです。

それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。詳細については管理者の方と相談して見てください。


.S	まとめおくり
.l	msend-intro
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.xref	msend

INSTALL ファイルの説明で設定だけはできるはずです。
それ以上の詳細については「まとめ送り」と「CRON」の章を見て下さい。
.xref	msend cron

まとめおくりとは

	特定時間になると配送リストに基づき
	その時間に送ることになっている人に
	まだ送っていなかった分のメールをスプールから取り出して送る

ということをすることです。送るべき時間になった時その場で作るため
各ユーザーごとに

   配送するべき時間
	N時間おき、一日一回等

   配送時のファイルのまとめ方

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を定義できます。# matome (# digestでもよい) コマンドで各ユーザが定義し
て下さい。


.S	コマンドコントロール専用のアドレス
.l	control-addr
.xref	calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス
.key	コントロール専用アドレス

makefml が作るデフォールトの config.ph では

	$CONTROL_ADDRESS = "Elena-ctl\@$DOMAINNAME";

のように設定されています。また、Elena-ctl アドレス宛のメールはinclude 
ではなく include-ctl というファイルを :include: 構文で呼び出すように設
定されています(include-ctl では fml.pl --ctladdr という形で呼び出す設
定がされているのが重要なポイントです)。

Elena-ctl宛のメールはコマンドのルーチンだけしか呼ばないようになります。
つまりこのアドレスにくれば間違ったシンタックスのメールがきても配送はし
ません。ちなみに

	'Elena-ctl';
	'Elena-ctl@axion.phys.titech.ac.jp';

どちらでもいいんですが、フルにアドレスを書く方が良いです。

最もローカルからコマンドメールを出す時のことを考えると、
フルアドレスじゃないほうが望ましいという意見もあります。
＃ sendmail.cf 等に依存した話なので断言はできませんが…

なお、この場合/etc/aliasesに

	Elena-ctl: Elena

とか書いてあることが必要です。newaliasesも忘れずに。

makefml の指示通にすればこの設定もしているはずですけど。


.S	メンバーチェックと自動登録について
.xref	auto-regist delivery-mode

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトではメンバーチェックを行ないます。
またこれは security 上望ましいことです。
.xref auto-regist

メンバーチェックをするか否かは config.ph の中で

	$ML_MEMBER_CHECK 

という変数で決まります。

[メンバーチェック]

	$ML_MEMBER_CHECK = 1;

の時は $MEMBER_LIST (デフォールト members) の中に From: 行のアドレスが
存在するか否か？を調べます。ない場合は管理者へ知らせ、さらに From: 行
のアドレスの人へ $DENY_FILE を送り返します。
この場合の配送は $ACTIVE_LIST に従って配送されます。


[自動登録]

	$ML_MEMBER_CHECK = 0;

の時は $MEMBER_LIST (デフォールト members) の中に From: 行のアドレスが
存在するか否か？を調べます。

存在しない場合は管理者へ知らせ、(例えば From: 行の)アドレスを自動的に 
$MEMBER_LIST に登録します。

配送は $MEMBER_LIST のみに従って配送されます（注意）。
つまり自動登録時は $MEMBER_LIST しか使っていないのです。
＃実は $ACTIVE_LIST = $MEMBER_LIST に設定しています。

自動登録はキーワードを必要とするとか登録したいアドレスを指定したい時に
どうするか？等に関して様々なバリエーションがあります。
詳細については「自動登録」の章を見て下さい。
.xref auto-regist


[アドレスのチェックの厳しさ]
アドレスのチェックを緩めたりきつくしたりしたい場合は
.xref $ADDR_CHECK_MAX


.S	$MAINTAINER というアドレス
.key	UNIX_FROM
.key	$MAINTAINER

ＭＬの管理者のアドレスです。“大雑把に”いうとエラ−メ−ルの帰る場所と
思っていいです。エラーが返る時にこれがＭＬ宛になっていると無限ループし
ます。

インターネットでは歴史的に listname (MLの名前) に対して

	listname-request は管理者のアドレス

が多いです(絶対ではありません)。ちょっと request というのが直観に反す
るところもありますが…いつも僕はこの事実との整合性とわかりやすさのため
に

	listname-admin 		管理者のアドレス
	listname-request 	listname-adminへフォワード

のように設定しています。そのためどちらのアドレスへ送られても管理者へそ
のメールは届くわけです。makefml のデフォールトは listname-admin です。
provider 等ではそれぞれの設定があったりするので注意して下さい。


.S	他の人にＭＬのスプールを見せない設定

通常ＭＬ管理者の権限で fml は走っています。そしてＭＬの全てのファイル
は管理者以外の人が見れない様になっています。

例外としてメーリングリストの directory でも htdocs だけはすべての人が
読めるようになっています。これは httpd がどのユーザ権限で走っているか
わからないためです(nobodyとかで走っている)。


.S	スプールに記事をためない
.l	$NOT_USE_SPOOL

DISKが足りない等で記事をためずに配送するだけにしたいなら

	$NOT_USE_SPOOL = 1;

と設定してください。もちろんその場合は記事の取り寄せ等ができません(当
たり前)。


.S	makefml install 後使わなさそうなファイルを消す

例えば makefml install で /usr/local/fml なり ~/fml なりにインストール
したとします。その directory には document 等も入っているので

	DISKが足らない
	document が要らない ;_;
	ドキュメントは www.fml.org で見るから別に要らない 

等の要求はあると思います。この場所で普通消しても困らないものは

	doc 	ドキュメント
	libexec 特殊なもの fml_local とかも含む
		fmlserv があるから消しちゃ駄目かもしれない
	bin 	fml 自体は使わない user 支援 program 群

etc, sbin, cf は消しちゃダメです。



.C	配送のモード
.l	delivery-mode


以下では配送のモードについて解説します。fml の設定変数は非常に多岐に渡っ
ています。またメタレベルで設計されている部分もあります。そのため設定の
自由度は高いのですが、一つの内容に複数の設定変数が附随してきます。

しかし多くの場合一つ一つの変数を設定しなくてもデフォールトの値で決め打
ちでも動かすことはできます。むしろ初心者にはその方がわかりやすいでhそ
う。そこで、代表的なモードは”簡易モード設定”という形でわかりやすいユー
ザインターフェイスを提供するようになっています。初めはわからなくてもい
いので、もっと細かくいじりたくなった時にその設定の意味を調べれば良いと
おもいます。


.S	デバッグモード
.k	デバッグモード
.label	debug-mode
.k	$debug

	$debug        = 1;

デバッグモードのフラッグ。１がデバッグモード。配送以外の設定、コマンド
操作はすべて有効です。テストに使って下さい。０に設定しないと配送してく
れません。


.S	DEFINE_MODE
.k	DEFINE_MODE
.k	&DEFINE_MODE
.xref	auto-regist

config.ph で簡易モード設定をするための関数です。以下のような理由のため
に導入されました。

○ 歴史的な理由で自動登録とメンバーチェックをするモードの設定等で同時
にいくつかの変数を設定する必要がある時にTYPOの可能性を低くする

○ 変数の設定の中には 1 or 0 だけでは不充分な場合がある

&DEFIN_MODE(mode-name); は必ず config.ph の最後 (1; より前) に書いて下
さい。というのはモード設定の中には config.ph の値を overwrite する必要
のあるものがあるからです(もちろん必要のないものもあります)。

conflict する例(古い例):

	$ML_MEMBER_CHECK = 1; (上の方)
…
	&DEFINE_MODE('autoregist'); （autoregistは古い変数名。一番最後）

と書くと、$ML_MEMBER_CHECK は 0 に overwrite され自動登録モードになっ
てしまいます。

これはこの時はよいのですが、後で trouble が発生した時に見通しを悪くし
ます。そのためこういう変数の conflict が発生しないようなものに限って使
うべきです。またこれらの理由により、2.1 gamma にあった、いくつかのもの
を除いて多くのモード設定は 2.1 release ではobsolete になりました。
backward compatible のため 2.1 release でも設定は有効ですができるだけ
使うべきではありません。


.S	&DEFINE_MODE の定義について

以下 ＭＬ = 

	listname@domain		include     ファイルを呼ぶ
	listname-ctl@domain	include-ctl ファイルを呼ぶ(ctladdr mode)

とする。前提条件としてＭＬは通常そのメンバーだけが投稿する。
メンバーでない人が投稿という概念はない。


(歴史的な)メンバーチェックの定義:＃ほんと歴史的だな、これ…

	$ML_MEMBER_CHECK = 1	メンバーチェックを通った人は投稿可
				違うなら reject 

	$ML_MEMBER_CHECK = 0	メンバーチェックを通らないなら
				メンバーに加える or confirm に回して配送しない
				メンバーでない人が投稿という概念ははないので
				no check という意味にはとらない

	例外処理: post=anyone で listname 宛の挙動は変えられる。
	listname-ctl は $ML_MEMBER_CHECK の設定に従い振舞いを変える。


定義:
	&DEFINE_MODE(DEFINE_SYNTAX)

	DEFINE_SYNTAX := ACTION "=" RESTRICTION / 
			 AUTOREGIST_TYPE "=" AUTOREGIST_TYPE_KINDS /
			 BACKWARD_MODE_DEFINITION

	ACTION        := "post" / "command"
	RESTRICTION   := "anyone" / "members_only" / "moderated"
	
	AUTOREGIST_TYPE       := "artype"
	AUTOREGIST_TYPE_KINDS := "confirm" / "subject" / "body"

	BACKWARD_MODE_DEFINITION := いままで [a-z_]+ のやつを押込める


解説:

○ listname

	・ post=
	post= syntax は listname 宛の振舞いを変える
	宣言しないならデフォールトの listname = distribute + command

	・ listname のメンバーチェックで reject 時の振舞いは
	 $ML_MEMBER_CHECK の設定に従い変わる。


○ listname-ctl

	・ command=
	command= syntax は listname-ctl 宛の振舞いを変える

	デフォールトは「メンバーだけがコマンドを使える」なので
	command=anyone だけが例外
	注意:一般に誰でもコマンドが使えるのは推奨しないが、
	自動送り返しサーバ等の応用がありうる。

	・ listname-ctl のメンバーチェックで reject 時の振舞いは
	 $ML_MEMBER_CHECK の設定に従い変わる。


○ 自動登録のタイプ

	・ artype=
	$ML_MEMBER_CHECK = 0 の時の AUTO REGISTRATION TYPE を決める。
	タイプを決めるだけなので 0 は必要。makefml interface でない時
	は要注意。

	--auto* は便利なように $ML_MEMBER_CHECK の overwrite をしてい
	るがそれだと config.ph と dup するのでよくない。

	矛盾を防ぐためにモード設定は config.ph (cf/MANIFEST 内の定義)
	と直交している必要がある。その意味で confirm 以外の artype= は
	本当はよくない。

	備考:
	artype って makefml では confirm くらいしか使ってないのだが…


.S	配送だけをするサーバ
.k	distribute-only

makefml は makefml newml listname で listname (配送用), listname-ctl
(コマンド用)という２つのアドレスを作ります。config.ph では 
$CONTROL_ADDRESS も listname-ctl として設定されています。

listname のデフォールトの挙動は (backward compatibleのため) サーバは一
つのアドレスで配送もコマンドも受け持ちます。

listname のアドレスでコマンドを使えなくし配送専用のアドレスにするため
には

	&DEFINE_MODE("post=anyone");       (誰でも投稿できる)
OR
	&DEFINE_MODE("post=members_only"); (メンバーだけが投稿できる)

を設定してみて下さい。listname は配送専用になります。コマンドは 
listname-ctl を使ってもらうことになります。


.S	再配送だけをするサーバ
.key	再配送だけをするサーバ

単に配送を待って、それをスプールすることだけを目的にするメーリングリス
トを作ることもあるでしょう。つまり ガイドを相手に返すこともなく、単に
再配送するだけです。それは上述のように &DEFINE_MODE("post=anyone"); を
設定することで実現されます。

例: 	elena メーリングリストを再配送専用に設定する

makefml newml elena で elena メーリングリストを作る。/etc/aliases で

	elena: :include:/var/spool/ml/elena/include

となっているとします。 /var/spool/ml/elena/config.ph に

	&DEFINE_MODE("post=anyone");

を書く。別の言い方をすれば、/etc/aliases でやってるただのフォワードに
スプール機能がついてるような状態ですね。

		
.S	コマンド専用のサーバ (e.g. listname-ctl)
.k	$COMMAND_CHECK_LIMIT

makefml は listname-ctl というアドレスを用意します。これはコマンド専用
です。listname-ctl 用に include-ctl というファイルを :include: するよ
うに設定されています。include-ctl では --ctladdr というオプションがつ
いているのがコマンド専用として fml.pl を起動するためのオプションです。
このオプションを消さないで下さい。


.S	配送およびコマンドのサーバ (default for backward compatible)
.k	$COMMAND_CHECK_LIMIT

fml のデフォールトの挙動は(Backward compatible)で サーバは一つのアドレ
スで配送もコマンドも受け持ちます。

	メールの最所の３行のどこかが 
	# command（英文字だけの塊）
	の場合コマンドモードへ移行する

です。ちなみにこの３行の３は

	$COMMAND_CHECK_LIMIT           = 3;

で決めています。

これは 配送するのか？コマンドを実行するのか？の切替の合図に 

	# command options

形を使っているからです。
＃Emacs の C- (control) とか vi のモード切替えみたいなものです:-)

コマンドしか受け付けないアドレスなら "# command" syntax じゃなくてもい
いはずでず…	

	$COMMAND_ONLY_SERVER           = 1;
.l	$COMMAND_ONLY_SERVER

とすると 

	# command options 

ではなくメールは

	command options

の形と仮定します。つまり通常のメールもすべてコマンドとみなされてしまう
コマンド専用のサーバになります。


.S	コマンド or 特殊目的専用のサーバへの変更
.k	コマンド専用のサーバへの変更
.key	特殊目的専用のサーバへの変更
.label	server-for-command-only

makefml は listname-ctl というコマンド専用のアドレスを用意します。
だから通常はそれで間に合うはずです。

そのコマンド専用のサーバを特別のものにすることもできます。

	$LOAD_LIBRARY = 'libfml.pl'; 

のように設定(default)したら コマンド専用だし、

	$LOAD_LIBRARY = 'libftpmail.pl'; 

とすれば ftpmail 専用のアドレスに早変わりです(注意: ftpmail 用の設定は
別途必要です)。

それは $LOAD_LIBRARY が設定されていると、そのライブラリを評価して実行
するように作動します。この場合配送は行なわれません。絶対配送させないよ
うにするにはさらに &DEFINE_MODE('ctladdr'); も設定すると良いでしょう
(これだけは --ctladdr というコマンドラインでの設定が推奨されます、この
方がそのアドレスでの挙動を確実にコマンドに設定できるので)。

$CONTROL_ADDRESS にアドレスを登録するとコマンド専用のＭＬサーバが作れ
ます。その場合 $CONTROL_ADDRESS に来た場合有無を言わさずすべてコマンド
と解釈します。ただこのやり方ではヘッダを場合わけの根拠にしているため曖
昧さがあります。

曖昧さをなくすためには listname-ctl アドレスを使うのが良いでしょう。配
送用の listname を使わなくてよいなら &DEFINE_MODE('ctladdr'); を設定し
てもよいです。これを設定すると配送サーバは使えなくなります。


.S	Subject: にコマンドを書く場合
.k	$USE_SUBJECT_AS_COMMANDS
.xref	STDIN->fml

	$USE_SUBJECT_AS_COMMANDS = 1;

の場合は、Subject: の部分をコマンドとみなします。
.xref	STDIN->fml

	# で始まり、英文字が続く行 (\s*\w+\s|^\#\s*\w+)
	# で始まり、$CHADDR_KEYWORD のキーワード

$COMMAND_ONLY_SERVER がセットされている場合は、キーワード # の有無に関
わらず、上記のキーワードを探索します。
.xref	$COMMAND_ONLY_SERVER

キーワードを見つけた場合は、コマンドモードへ移行します。


.S	リモートで管理する設定
.xref	REMOTE-ADMINISTRATION
.xref	bin/passwd.pl

SMTPでは所詮どうしようもないのでデフォールトではリモートでサーバを管理
するようにはなっていません。可能な限り避けるべきです。リモート管理より
Secure Shell で makefml を起動させるような仕組みがあるとよいですね。

リモートで管理もできるようにモードを変えるには、

	$REMOTE_ADMINISTRATION = 1;
	$REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1;

を設定して下さい。お勧めではありませんが &DEFINE_MODE("remote"); でも
同じです。

	$REMOTE_ADMINISTRATION_REQUIRE_PASSWORD 

をセットしないならパスワード認証をせず
	管理者のメンバーリスト $ADMIN_MEMBER_LIST

だけでアドレスの認証だけをします。この設定はするべきではありません。

パスワードは $DIR/etc/passwd に crypt された形で保存されます。
.xref bin/passwd.pl

$USE_MD5 = 1; を設定すると crypt ではなく MD5 になります
(注意: perl 5 でなおかつ MD5.pm が必要です)。
.xref $USE_MD5


新たにパスワードを初期化する場合は 

○ makefml を使う(INSTALL を見て下さい)

○ コマンドでは fml-install-dir/bin/passwd -i mail-address 

○ アドミンコマンドの初期化用の initpass というコマンド
.xref	remote

リモート管理関係のカスタマイズ変数は

   アドミンと認めるメンバーのリスト（Email-address）
   $ADMIN_MEMBER_LIST	= "$DIR/members-admin";

   アドミンのコマンドのHELPファイル
   $ADMIN_HELP_FILE	= "$DIR/help-admin";

   リモート管理にパスワードを要求する場合には１に
   $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1;

   その場合のパスワードを保存するファイル
   $PASSWD_FILE        = "$DIR/etc/passwd";

詳細は「リモート管理」の章を見てください。
.xref REMOTE-ADMINISTRATION 


.# ##########################################################
.include msend.wix
.include remote.wix
.include autoregist.wix



.C	コマンドの実行に関する２、３のこと…

.S	ＭＬで使えるコマンドを増やすor減らす
.l	add-procedures
.xref	add-admin-procedures

config.ph でコントロールできます。
いくつかの変数がありますが、次のように作動します

   1	@PermitProcedure が定義してあるなら
	@PermitProcedure で許しているコマンドだけを設定します。
	もし、定義されていなければデフォールトのすべてのコマンドが
	利用可能になります。
	これらの設定はグローバル変数の %Procedure に定義されます。

   2	%LocalProcedure が定義されているなら
	1 で定義された %Procedure を %LocalProcedure で上書きします。

   3	@DenyProcedure が定義されているなら
	@DenyProcedure のコマンドだけを使えなくする

例：
	○ guide と summary のみを使用可能、それ以外はすべて使用不可

	@PermitProcedure = ('guide', 'summary');

	○デフォールトに加え自分で定義した hack コマンドも使える

	%LocalProcedure = ('hack', 'ProcHack');

	もちろんこの場合はどこかで sub ProcHack { ...; } があって
	この関数を用意しておく必要がある。

	○デフォールトの中で get 関係は使えなくする
	@DenyProcedure = ('get', 'send', 'mget', 'msend');


.S	コマンドの # syntax は必要か？ 

配送とコマンドが同じアドレスなら動作を切替えるためのキーワードが必要で
す。それが # syntax です。

makefml が作る listname-ctl アドレスはコマンド専用なので要りません。
もちろんあっても # 部分は勝手に解釈するのでどっちでも構いません。

“コマンド専用のアドレスにメールが来た時だけ”は考える必要がないですね
もし、コマンド専用のアドレスで

	# get 1
		も
	get 1

同じにコマンドとして動いて欲しいなら＃もちろん off bye 等も同様

	config.ph に $COMMAND_ONLY_SERVER = 1;


.S	コマンドの書き方 [e.g. # get 1 と #get 1は同じものとみなす]
.k	# help ではなく #help 形式

以下は コマンドの書き方についてのオプションです。

	# get 1
	# help

のような書き方をしてきました。で、こうでない書き方は解釈してくれなかっ
たので、今度は

	# get 1 と #get 1は同じものとみなす（両方使える）
	すべてのコマンドで同じように "# " -> "#" 解釈する。
	さらに#getfile ...も# get ...と理解する。

としました。つまり、

	# get 1
	#get 1
	# getfile 1
	#getfile 1

は同じもの。同様に

	# help
	#help

を同じものにみなします。

.key	$COMMAND_SYNTAX_EXTENSION
	$COMMAND_SYNTAX_EXTENSION = 1;

両方解釈するなら１、"# summary" みたいな形式だけなら０


.S	コマンドは一辺に実行できるか？

例えば

	# get 1
	# get 2
	# get 3
	# help
	# summary

という内容のメールをＭＬサーバへ入れると

1、 2、 3 の記事を取り寄せ、ヘルプとさらにサマリファイルも取り寄せると
いう働きをします。bye を除き 一行一コマンドずつ順番にすべて実行します。

それは各行ごとにどんどん処理をするようになっているからです。
＃ ただし # exit はコマンドの終りです。ここで exit == end == quit


しかしながら

	uja
	# get 1
	# get 2

というメールの内容とエラーです。というのは、最初の３行のどこかで#では
じまる行があればコマンドモードとみなして処理を行なうためです。

最初の行は空行で２行目に#があるメールが、間違えて流れたりしないための
防止機構です。この“３”行の“３”を変えたいときは config.ph の中の

	$COMMAND_CHECK_LIMIT = 3;

を変えます（最初の３行をチェックする）。


.S	間違ったコマンドを送ってきた人への警告
.k	USE_WARNING 

デフォールトでは警告しません。

	$USE_WARNING = 1; 

でない限り、間違ったコマンドへの警告メールをだすことはありません。
これは signature を自動的に付ける設定をしている場合への対処です。
# exit 等で明示的にコマンド指定を終わらせるのが良いでしょう。


.S	コマンドの終り(シグニチャア対策)
.key	シグニチャア対策

	# exit 
	# end
	# quit

というコマンドを追加しました。このコマンドのところでアクションは終了し
ます。signature があってもいいように、こうしました。


.S	ＭＬサーバの作業エリア 
.key	$TMP_DIR

デフォールトでは $DIR/tmp (つまり $TMP_DIR = './tmp';) を使います。
変更したい場合は $TMP_DIR を変更して下さい。

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。
private communication のファイルを public な場所にファイルを残すことは
しないためです。

その他にも 4.4BSD 風の directory 構造の中に各種のログやキャッシュが保
存されます。


.S	コマンドの結果を送り返すときにヘルプやなにかの情報も付加する設定

	$PREAMBLE_MAILBODY	（前）
	$TRAILER_MAILBODY	（後）
	を本文の前後に必ず付けます。

つまり、
	e.g. HELP コマンドにたいして、

	$PREAMBLE_MAILBODY	（前）
	HELPファイル本文
	$TRAILER_MAILBODY	（後）

のようになります。昔のやり方は

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= $PREAMBLE_BODY.$e{'Body'}; #;
   ＃注：普通のＭＬのメールに $PREAMBLE_BODY がついて配送

ですが今は汎用性のためSMTPライブラリ中で処理されます。

これと同様にすれば、本文にメールカウントを埋め込むことも可能になります。

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= "Mail Count: $ID\n\n".$e{'Body'}; #;

注意：このHOOKが走る関数中では %e == %Envelope 


.include forward.wix
.include filter.wix
.include fmlserv.wix



.# ##########################################################
.C	複数のメーリングリストの運用
.key	複数のメーリングリストの運用
.label	{plural-handling-1}
.xref	fml-process


.S	複数のメーリングリストを作る。


INSTALL を見て下さい。メーリングリストを作るには

	makefml newml listnmae

で listname というメーリングリストが準備されます。/etc/alisaes に設定
を書いて newaliases を実行すればそれで終りです。

以下では実装の理屈について説明します。


.S	複数のメーリングリストの運用時の設定の理論
.label	plural-handling-2
.xref	fml-process

.ptr{fml-process} (詳細はそちらを見て下さい)で説明されている通り

	fml.pl	MLのHOME(config.phのあるところ） libraryの場所

の形で与えることができます。なお、fml.pl と libなんとか.pl が同じ場所
にあるなら「libraryの場所」は不要です。
.xref	fml-process

fml は

	config.ph （とその置き場所以下の階層、つまりＭＬのホーム）

ですべての挙動が決まります。つまりこの部分さえ別に保守すれば複数のＭＬ
はすぐに操作可能です。


.S	２つのメーリングリストの運用の設定例
.k	２つのメーリングリストの運用の設定例
.k	複数のメーリングリストの運用の設定例

以下では Elena というＭＬともう一つ別の freekick というＭＬを設定
する時の例です。複数あっても以下同様です。

○ ＭＬのホーム（directory）を別々に作ります。

	/var/spool/ml/Elena
	/var/spool/ml/freekick

○ config.ph を分けるため

	/var/spool/ml/Elena/config.ph
	/var/spool/ml/freekick/config.ph

を作り、それぞれのＭＬ用に定義します。

○ sendmail から呼び出す時に

   /etc/aliases は

	Elena:	  :include:/usr/local/ml/include/Elena
	freekick: :include:/usr/local/ml/include/freekick

のように別のアドレス（当たり前）で別の INCLUDE ファイルを呼び出します。

この場合

	/usr/local/ml/include/Elena は
	"/usr/local/fml/fml.pl /var/spool/ml/Elena"

	/usr/local/ml/include/freekick は
	"/usr/local/fml/fml.pl /var/spool/ml/freekick"

のように呼び出します。この後 

	Elena ML は 	/var/spool/ml/Elena/config.ph 
	freekick ML は 	/var/spool/ml/freekick/config.ph 

に従い、それぞれの directory 以下の階層に記事やログを残すので
別々のＭＬとして挙動することになります。

○ :include: が使えないＯＳ

上述のようにfmlの呼び出し方をそれぞれ変えるので、
setuid program を各ＭＬ用に作ればいいわけです。

可変引数をとる setuid program は security hole になり得るので、ちゃん
と別の C program を作り、それぞれ compile し注意してインストールします。

fml.c を参考にして下さい。fml.c を

  Elena ML が

  execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/Elena", NULL);

  freekick ML が
  execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/freekick", NULL);

のように変更し、compileすればいいわけです。



.S	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.k	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.xref	fmlserv


.# ##########################################################
.include header.wix
.# .include configmisc.wix
.include archive.wix
.include expire.wix
.include href.wix
.include proc.wix


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
