.C	インストールについて
.l	install


.S	makefml によるインストール

とりあえず細かいチューニングを行なわなくてよいなら
=E
The simplest way to install Fml system is to run 

	make install
or
	perl makefml 

=E
in the top directory of the fml source. Please see INSTALL.English for
more details.


.S	makefml: 初心者向けインストール・インターフェイス
.k	makefml: fmlのインストーラ
.l	sbin/makefml
.l	makefml

fml のソースファイルを広げて INSTALL というファイルを見て下さい。現在
では makefml という対話的にインストールや簡単なＭＬの設定を行なうイン
ターフェイスが附属しています。使い方は INSTALL というファイルにありま
す。

INSTALL +α でこの doc/op というファイルと INSTALL の中間に当たるユー
ザーズガイドが整備される予定ですが、2.1-RELEASE に間に合うように統合さ
れるかどうかはわかりません。FAQ も分離するべきなのでしょうが、この辺す
べてそこまで手が回る暇がないので整備される日は来ないかも知れません。
＃やってくれる人募集です。英訳もすすんでない…

config.ph に現れるハッシュ %MAKE_FML は makefml で使うためのものです。
makefml 以外では使われません。
.k	%MAKE_FML


.S	Version up について
.l	version-up
.k	version up

ソースを広げてインストールと同様に makefml install をして下さい。
手動でも十分できますが、makefml の方がよいでしょう。
makefml install を使えば必要な作業を行なってくれます。

実作業としては

	(ソースの下の src 階層以下に perl scripts は集められています)
	makefml この src/ bin/ sbin/ cf/ doc/ 群をコピーします。

ことを makefml が行ないます。
注意：fml 1.x 時代の場合の注意は .ptr{appendix:fmlR1}


.S	本当に残しておく必要のあるファイルは？
.l	files-to-need

たまにどこが必要な部分ですか？と聞かれますが、makefml install を使えば
core の部分だけが概ねインストールされます。

makefml でインストールすると document 群も入れます。documents は大きい
です。インストール先の doc の下にまとまってるので、ここは消して構いま
せん。ドキュメントは「www.sapporo.iij.ad.jp を見るから doc/html は要ら
ないから消す」という選択はありうるでしょう。ただ www では常に最新版の
内容だという点で注意が必要です。

それ以外に何を消していいかは機能をどこまで使うかに依存しているので一概
にはいえません。

ちなみに

	doc 	ドキュメント
	libexec 特殊なもの fml_local とかも含む
		fmlserv があるから消しちゃ駄目かもしれない
	bin 	fml 自体は使わない user 支援 program 群

etc, sbin, cf は消しちゃダメです。


.S	インストール後にサーバの設定(パラメータ)をいじる
.l	how-to-customize-parameter
.xref	fml-maintenance
.xref	order-of-option-effeciency
.xref	init-data-structure

複数のやり方があります。本質的にはどれも設定ファイル(config.ph)を書き
換えるということです。コマンドラインオプションで同じ設定が可能ですが、
保守や makefml インターフェイスとの整合性のため 2.1-RELEASE では推奨さ
れていません。


1	makefml
.k	makefml

初心者で内部構造がよくわからない場合はインストール時に使った makefml 
というコマンドを使って、ＭＬの設定ができます。makefml config ML で Ｍ
ＬのHOME/config.ph が変更できます。よく使いそうだと思われる基本的な設
定はこれで十分でしょう。この辺のことについては INSTALL を読んで下さい。

インターフェイスが複雑になるのが嫌なので、ここでいじることのできる設定
は基本的なものに限っています。将来もできるだけ makefml config は少数精
鋭の config のみを入れていく予定です。

[注意] 各ＭＬのHOMEには

	cf
	config.ph 

というファイルがあります。実は makefml config でいじっているのは cf で 
毎回 cf から config.ph を再生成しています。そのため config.ph をいじっ
ても、その後 makefml config をしてしまうと、ほとんどの設定は上書きされ
てしまいます。よって

   ・ cf を常にマスターとして、make config.ph で作成
	ちょうど CF と sendmail.cf の関係のように

	この場合は makefml config を使っても大丈夫

か

   ・ 最初だけ makefml config でいじり、あとは全て config.ph を手動編集

必要があります。


2	config.ph

それ以上のことがしたい場合は各メーリングリストの config.ph をいじって
下さい。

3	sitedef.ph
.k	sitedef.ph

複数のメーリングリストに共通の設定であれば makefml が fml.pl や 
libsmtp.pl を入れた場所に sitedef.ph というファイルを作ってこの中に書
いておくと config.ph の評価の後に sitedef.ph が評価されます。
コマンド等のマシン共通の設定にこれを使うとちょっと便利かもしれません。

例：
	/usr/local/fml/sitedef.ph

を作り、この中に例えば

	$HOST = "mlrelay.dokka.org";
	1;

とか共通の設定を書く(この例では↑は配送に使うマシンをデフォールトから
mlrela.dokka.org(注意:これは架空のホストです)というマシンに変更。


.S	include ファイル (fml.plの呼び方、引数の渡し方)
.k	include ファイル
.l	calling-fml.pl
.xref	fml-uid, plural-handling-1, plural-handling-2

fml の起動の仕方は

	fml.pl config.phのあるdirectry libary-path(必要なら)

の形です。これと同じこと sendmail にやらせるためには /etc/aliases 等に
次のように書きます。いろいろな書き方がありますが、それがちゃんと動くか
否かは sendmail の version に依存です。

例: Elena メーリングリストの場合

   /etc/aliases は

	Elena: :include:/var/spool/ml/Elena/include
	owner-Elena: fukachan
	Elena-request: fukachan
	Elena-admin: fukachan

   /var/spool/ml/Elena/include の中身は

	"|/usr/local/fml/fml.pl directory"

こうすると include ファイル の所有者のIDで fml.pl は動き、sendmail は 
そのプロセス (fml.pl) の STDIN へ来たメールを入れます。

なお単純にこれだけではだめでおまじないが必要なOSもいろいろあります。
OS によるfml.plの呼び方の違い一覧は次の章を見て下さい。
.label	{calling-fml.pl-and-OS}
.key	OS_dependence


.S	C wrapper
.label	c-wrapper
.k	fml
.k	fml.c

:include: 構文が使えない OS もしくは古い sendmail の場合は C wrapper 
を使う必要があります。
C wrapper は setuid して使います。setuid された program の引数でfml.pl 
を渡すとかいうことはしてはいけません。
＃そういうことをする外国のソフトがあるようですが…何考えてるんだろ

makefml が見本の fml.c を作ってくれているのでそれを compile して作りま
す。fml.c は環境に併せて変更されていますが一応確認はしてみてください。
fml.c には実行する内容が hard coding されているので必要なら直接 edit 
して下さい。

fml.c の内容は

	fml.plの場所   config.phのある場所   ライブラリの場所

を exec する C の program というだけのものです。

例： fml.c

execl("/usr/local/fml/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/var/spool/ml/Elena",   /* config.ph は どこ？ */
      "/usr/lcoal/fml",        /* fml package の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル (doc/op) 等を見ながら直してみて下さい。


.S	C wrapper program fml on 4.3BSD
.k	fml.c
.k	fml

:include: 構文が使えない時は、setuid された fml という C の wrapper
program を経由して

	/usr/local/fml/fml.pl directory

を実行するという設定をします。makefml を使えば各メーリングリストごとに
専用の fml.c が作成されています。その directory で

	% make fml 

とすると作成されます。fml.c の中で fml.pl directory ... という形で呼ぶ
ようになってます。


.S	C wrapper program fml on 4.4BSD or POSIX
.label	calling-fml.pl-POSIX
.key	POSIXなsetuid
.key	POSIX

もし POSIX なら 

	% make CFLAGS=-DPOSIX 

として fml を作成して下さい。uid と gid は makefml newml 時に fml.c に
埋め込まれています。fml ができたら root権限で

   # chown root fml
   # chmod 4755 fml

これで、setuid が動くはずです。この場合は root の権限で一回動いて あな
たのuidに設定して fml.pl を起動します。install の仕方によっては 
permission をもっと厳しくできるはずです。設定には十分な注意を払って下
さい。fml は root 以外は絶対に書けない場所にインストールするべきです。

それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。詳細については管理者の方と相談して見てください。


.S	まとめおくり
.l	msend-intro
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.xref	msend

INSTALL ファイルの説明で設定だけはできるはずです。
それ以上の詳細については「まとめ送り」と「CRON」の章を見て下さい。
.xref	msend cron

まとめおくりとは

	特定時間になると配送リストに基づき
	その時間に送ることになっている人に
	まだ送っていなかった分のメールをスプールから取り出して送る

ということをすることです。送るべき時間になった時その場で作るため
各ユーザーごとに

   配送するべき時間
	N時間おき、一日一回等

   配送時のファイルのまとめ方

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を定義できます。# matome (# digestでもよい) コマンドで各ユーザが定義し
て下さい。


.S	コマンドコントロール専用のアドレス
.l	control-addr
.xref	calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス

makefml が作るデフォールトの config.ph では

	$CONTROL_ADDRESS = "Elena-ctl\@$DOMAINNAME";

のように設定されています。また、Elena-ctl アドレス宛のメールはinclude 
ではなく include-ctl というファイルを :include: 構文で呼び出すように設
定されています(include-ctl では fml.pl --ctladdr という形で呼び出す設
定がされているのが重要なポイントです)。

Elena-ctl宛のメールはコマンドのルーチンだけしか呼ばないようになります。
つまりこのアドレスにくれば間違ったシンタックスのメールがきても配送はし
ません。ちなみに

	'Elena-ctl';
	'Elena-ctl@axion.phys.titech.ac.jp';

どちらでもいいんですが、フルにアドレスを書く方が良いです。

最もローカルからコマンドメールを出す時のことを考えると、
フルアドレスじゃないほうが望ましいという意見もあります。
＃ sendmail.cf 等に依存した話なので断言はできませんが…

なお、この場合/etc/aliasesに

	Elena-ctl: Elena

とか書いてあることが必要です。newaliasesも忘れずに。
makefml の指示通りにすればこの設定もしているはずですけど。


.S	メンバーチェックと自動登録について
.xref	auto-regist delivery-mode

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトではメンバーチェックを行ないます。
またこれは security 上望ましいことです。
.xref auto-regist

メンバーのアクセス制御については Chapter .ptr{access_policy} を参照。
基本的には

	$REJECT_COMMAND_HANDLER = "auto_regist";

で auto_regist のように設定されていれば自動登録を行ないます。

なお、昔は

	$ML_MEMBER_CHECK 

という変数で決めていましたが、今これは内部変数として使われています。
HOOK等で使われるだろうということを想定し歴史的変数として残っています。

	$ML_MEMBER_CHECK 

が重要なのはこの変数によって メンバーリストと配送リストが異なるからです。

[メンバーチェック]

この時は $MEMBER_LIST (デフォールト members) の中に From: 行のアドレス
が存在するか否か？を調べます。ない場合は管理者へ知らせ、さらに From: 
行のアドレスの人へ $DENY_FILE を送り返します。この場合の配送は 
$ACTIVE_LIST に従って配送されます。


[自動登録]

$MEMBER_LIST (デフォールト members) の中に From: 行のアドレスが存在す
るか否か？を調べます。

存在しない場合は管理者へ知らせ、(例えば From: 行の)アドレスを自動的に 
$MEMBER_LIST に登録します。

配送は $MEMBER_LIST のみに従って配送されます（注意）。
つまり自動登録時は $MEMBER_LIST しか使っていないのです。
＃実は $ACTIVE_LIST = $MEMBER_LIST に設定しています。

自動登録はキーワードを必要とするとか登録したいアドレスを指定したい時に
どうするか？等に関して様々なバリエーションがあります。
詳細については「自動登録」の章を見て下さい。
.xref auto-regist


[アドレスのチェックの厳しさ]
アドレスのチェックを緩めたりきつくしたりしたい場合は
.xref $ADDR_CHECK_MAX


.S	$MAINTAINER というアドレス
.key	UNIX_FROM
.key	$MAINTAINER

ＭＬの管理者のアドレスです。“大雑把に”いうとエラ−メ−ルの帰る場所と
思っていいです。エラーが返る時にこれがＭＬ宛になっていると無限ループし
ます。

インターネットでは歴史的に listname (MLの名前) に対して

	listname-request は管理者のアドレス

が多いです(絶対ではありません)。ちょっと request というのが直観に反す
るところもありますが…いつも僕はこの事実との整合性とわかりやすさのため
に

	listname-admin 		管理者のアドレス
	listname-request 	listname-adminへフォワード

のように設定しています。そのためどちらのアドレスへ送られても管理者へそ
のメールは届くわけです。makefml のデフォールトは listname-admin です。
プロバイダではそれぞれの設定があったりするので注意して下さい。


.S	他の人にＭＬのスプールを見せない設定

通常ＭＬ管理者の権限で fml は走っています。そしてＭＬの全てのファイル
は管理者以外の人が見れない様になっています。

例外としてメーリングリストの directory でも htdocs だけはすべての人が
読めるようになっています。これは httpd がどのユーザ権限で走っているか
わからないためです(通常 nobodyとかで走っている)。


.S	スプールに記事をためない
.k	スプールに記事をためない
.l	$NOT_USE_SPOOL

DISKが足りない等で記事をためずに配送するだけにしたいなら

	$NOT_USE_SPOOL = 1;

と設定してください。もちろんその場合は古い記事の取り寄せ等ができません
(当たり前)。


.C	配送とコマンド、そしてそのアクセス制御
.l	delivery-mode


.S	デバッグモード
.k	デバッグモード
.label	debug-mode
.k	$debug

	$debug        = 1;

デバッグモードのフラッグ。１がデバッグモード。配送以外の設定、コマンド
操作はすべて有効です。テストに使って下さい。０に設定しないと配送してく
れません。


.S	アクセス制御のポリシー
.l	access_policy

FML 2.1 (config.ph の CFVersion が 3)では 

	$PERMIT_POST_FROM
	$REJECT_POST_HANDLER
	$PERMIT_COMMAND_FROM
	$REJECT_COMMAND_HANDLER
.l	$PERMIT_POST_FROM
.l	$REJECT_POST_HANDLER
.l	$PERMIT_COMMAND_FROM
.l	$REJECT_COMMAND_HANDLER
.k	$PERMIT_POST_FROM
.k	$REJECT_POST_HANDLER
.k	$PERMIT_COMMAND_FROM
.k	$REJECT_COMMAND_HANDLER

という4つの変数がアクセス制御の鍵を握っています。また自動登録をするか
否か?もアクセス制御の一部としてこれらの変数で制御されます。それぞれの
意味は

   $PERMIT_POST_FROM		だれからの投稿を許すか?
   $REJECT_POST_HANDLER		メンバー以外からの投稿があったらどうするか?
   $PERMIT_COMMAND_FROM		だれからのコマンドを許すか?
   $REJECT_COMMAND_HANDLER	メンバー以外からのコマンドが来たらどうするか?

です。ありえる設定は

   [だれから？]

	anyone			だれでもOK
	members_only		ＭＬのメンバーのみ
	moderator		モデレーターのみ (.ptr{moderators})

   [HANDLERの種類]
	reject			許否 (deny というファイルが送り返される)
	auto_regist		自動登録
	ignore			無視 

＊ HANDLER はいずれの場合も管理者へメールでの報告はいきます。

デフォールトのＭＬサーバの挙動は

	メンバーのみ(members_only) 投稿/コマンドの使用 が可能
	もしメンバー以外から来たら許否(reject)

です。つまり config.ph で

（デフォールト）

	$MAIL_LIST                     = "elena\@$DOMAINNAME";
	$PERMIT_POST_FROM              = "members_only";
	$REJECT_POST_HANDLER           = "reject";

	$CONTROL_ADDRESS               = "elena-ctl\@$DOMAINNAME";
	$PERMIT_COMMAND_FROM           = "members_only";
	$REJECT_COMMAND_HANDLER        = "reject";

のようになっています(elena MLの場合)。


.S	自動登録とアクセス制御
.l	access_policy_and_auto_regist
.xref	auto-regist

自動登録は

	"投稿がメンバーだけ"(members_only)の場合に
	もしメンバー以外から来たら自動登録 → auto_regist へ変更

という設定をすることで行ないます(makefmlで制御できます)。config.ph 中
では

	$MAIL_LIST                     = "elena\@$DOMAINNAME";
	$PERMIT_POST_FROM              = "members_only";
	$REJECT_POST_HANDLER           = "reject";

	$CONTROL_ADDRESS               = "elena-ctl\@$DOMAINNAME";
	$PERMIT_COMMAND_FROM           = "members_only";
注意→	$REJECT_COMMAND_HANDLER        = "auto_regist";

のようになることです。この場合はメンバー以外の人が

	投稿した場合		→	許否(メンバーでないというメールが返る)

	コマンド用のアドレスへメール
				→	自動登録

のような動きをします。

	$REJECT_POST_HANDLER           = "auto_regist";

にすれば「投稿用のアドレスにメンバー以外からメールが来たら自動登録」に
することもできます。


.S	配送用のアドレス ($MAIL_LIST)
.k	配送用のアドレス ($MAIL_LIST)
.k	$MAIL_LIST
.k	distribute-only

$CFVerson 3 の config.ph では

   ・$MAIL_LIST と $CONTROL_ADDRESS が異なる場合(デフォールト)
	$MAIL_LIST は配送だけです。

   ・$MAIL_LIST と $CONTROL_ADDRESS が同じ場合
	$MAIL_LIST は配送もコマンドも受け付けます。
	"# command"を見つけるとコマンドモードになります。

投稿できる人の範囲(だれでも/メンバーだけ)は $PERMIT_POST_FROM で変更し
ます。デフォールトは members_only

どこかにＭＬがあってそれをフォワードするだけのアドレス/ＭＬ(再配送専用
のアドレス)を作る場合は
.k	再配送専用のアドレス

	$PERMIT_POST_FROM = "anyone";

とするべきです。


.S	コマンド専用のアドレス ($CONTROL_ADDRESS)
.k	$COMMAND_CHECK_LIMIT

makefml は listname-ctl というアドレスを用意します。$CONTROL_ADDRESS 
という変数がそれです。

これはコマンド専用です。listname-ctl 用に include-ctl というファイルを 
:include: するように設定されています。include-ctl では --ctladdr とい
うオプションがついているのがコマンド専用として fml.pl を起動するための
オプションです。このオプションを消さないで下さい。

コマンドを実行できる人の範囲(だれでも/メンバーだけ)は 
$PERMIT_COMMAND_FROM で変更します。特別な場合を除きこの変数を変えるこ
とはないでしょう。デフォールトは members_only


.S	配送とコマンドを同じアドレスで行なう場合
.k	$COMMAND_CHECK_LIMIT

2.1 RELEASE 以前の fml のデフォールトの挙動(Backward compatible)では 
サーバは一つのアドレスで配送もコマンドも受け持ちます。

2.1 RELEASE では $CONTROL_ADDRESS と $MAIL_LIST を同じにすることで実現
することができますが、↑ makefml 等で明示的に設定変更が必要なことに注
意して下さい。

なお、2.1 RELEASE の config.ph は $CFVersion 3 です。以前の config.ph 
は 3 より小さい version か定義されていないかどちからです。3 より以前の
ものだと判断した場合は $MAIL_LIST で配送もコマンドも受け付けます。これ
は backward compatibility のためです。

配送とコマンドを同じアドレスで受けとる場合にはコマンドなのかどうか？を
判定する必要があります。判定基準は

	メールの最初の３行のどこかが 
	# command（英文字だけの塊）
	の場合コマンドモードへ移行する

です。ちなみにこの３行の３は

	$COMMAND_CHECK_LIMIT           = 3;

で決めています。

これは 配送するのか？コマンドを実行するのか？の切替の合図に 

	# command options

形を使っているからです。
＃Emacs の C- (control) とか vi のモード切替えみたいなものです:-)

コマンドしか受け付けないアドレスなら "# command" syntax じゃなくてもい
いはずでず…	

	$COMMAND_ONLY_SERVER           = 1;
.l	$COMMAND_ONLY_SERVER

とすると 

	# command options 

ではなくメールは

	command options

の形と仮定します。つまり通常のメールもすべてコマンドとみなされてしまう
コマンド専用のサーバになります。


.S	コマンド or 特殊目的専用のサーバへの変更
.k	コマンド専用のサーバへの変更
.key	特殊目的専用のサーバへの変更
.label	server-for-command-only

makefml は listname-ctl というコマンド専用のアドレスを用意します。
だから通常はそれで間に合うはずです。

そのコマンド専用のサーバを特別のものにすることもできます。

	$LOAD_LIBRARY = 'libfml.pl'; 

のように設定(default)したら コマンド専用だし、

	$LOAD_LIBRARY = 'libftpmail.pl'; 

とすれば ftpmail 専用のアドレスに早変わりです(注意: ftpmail 用の設定は
別途必要です)。

それは $LOAD_LIBRARY が設定されていると、そのライブラリを評価して実行
するように作動します。この場合配送は行なわれません。絶対配送させないよ
うにするにはさらに &DEFINE_MODE('ctladdr'); も設定すると良いでしょう
(これだけは --ctladdr というコマンドラインでの設定が推奨されます、この
方がそのアドレスでの挙動を確実にコマンドに設定できるので)。

$CONTROL_ADDRESS にアドレスを登録するとコマンド専用のＭＬサーバが作れ
ます。その場合 $CONTROL_ADDRESS に来た場合有無を言わさずすべてコマンド
と解釈します。ただこのやり方ではヘッダを場合わけの根拠にしているため曖
昧さがあります。

曖昧さをなくすためにはfml.pl が --ctladdr つきで起動される 
listname-ctl アドレスを使うのが良いでしょう。


.S	リモートで管理する際のアクセス制御
.xref	REMOTE-ADMINISTRATION pgp bin/passwd.pl

SMTPでは所詮どうしようもないのでデフォールトではリモートでサーバを管理
するようにはなっていません。可能な限り避けるべきです。リモート管理より
Secure Shell で makefml を起動させるような仕組みがあるとよいですね。

Email Address と秘密鍵の組合せ もしくは 公開鍵暗合によりアクセス制御を
行なっています。

詳細は「リモート管理」の章を見てください。
.xref REMOTE-ADMINISTRATION 


.# ##########################################################
.include msend.wix
.include remote.wix
.include pgp.wix
.include autoregist.wix
.include proc.wix
.include forward.wix
.include filter.wix
.include fmlserv.wix
.include moderator.wix



.# ##########################################################
.C	複数のメーリングリストの運用
.k	複数のメーリングリストの運用
.l	plural-handling-1
.xref	fml-process


.S	複数のメーリングリストを作る。

INSTALL を見て下さい。メーリングリストを作るには

	makefml newml listname

で listname というメーリングリストが準備されます。/etc/alisaes に設定
を書いて newaliases を実行すればそれで終りです。

以下では実装の理屈について説明します。


.S	複数のメーリングリストの運用時の設定の理論
.l	plural-handling-2
.xref	fml-process

.ptr{fml-process} (詳細はそちらを見て下さい)で説明されている通り

	fml.pl	MLのHOME(config.phのあるところ） libraryの場所

の形で与えることができます。なお、fml.pl と libなんとか.pl が同じ場所
にあるなら「libraryの場所」は不要です。
.xref	fml-process

fml は

	config.ph (とその置き場所以下の階層、つまりMLのホーム)

ですべての挙動が決まります。つまりこの部分さえ別に保守すれば複数のＭＬ
が独立に同時に動くわけです。


.S	２つのメーリングリストの運用の設定例
.k	複数のメーリングリストの運用例

以下では Elena というＭＬともう一つ別の freekick というＭＬを設定
する時の例です。複数あっても以下同様です。

○ ＭＬのホーム（directory）を別々に作ります。

	/var/spool/ml/Elena
	/var/spool/ml/freekick

○ config.ph を分けるため

	/var/spool/ml/Elena/config.ph
	/var/spool/ml/freekick/config.ph

を作り、それぞれのＭＬ用に定義します。

○ sendmail から呼び出す時に

   /etc/aliases は

	Elena:	  :include:/usr/local/ml/include/Elena
	freekick: :include:/usr/local/ml/include/freekick

のように別のアドレス（当たり前）で別の include ファイルを呼び出します。
この場合

	/usr/local/ml/include/Elena は
	"/usr/local/fml/fml.pl /var/spool/ml/Elena"

	/usr/local/ml/include/freekick は
	"/usr/local/fml/fml.pl /var/spool/ml/freekick"

のように呼び出します。この後 

	Elena ML は 	/var/spool/ml/Elena/config.ph 
	freekick ML は 	/var/spool/ml/freekick/config.ph 

に従い、それぞれの directory 以下の階層に記事やログを残すので
別々のＭＬとして挙動することになります。

○ :include: が使えないOS

上述のようにfmlの呼び出し方をそれぞれ変えるので、
setuid program を各ＭＬ用に作ればいいわけです。

可変引数をとる setuid program は security hole になり得るので、ちゃん
と別の C program を作り、それぞれ compile し注意してインストールします。

fml.c を参考にして下さい。fml.c を

  Elena ML が
    execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/Elena", NULL);

  freekick ML が
    execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/freekick", NULL);

のように変更し、compileすればいいわけです。


.S	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.k	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.xref	fmlserv


.# ##########################################################
.include header.wix
.include config_ph.wix
.include archive.wix
.include expire.wix
.include href.wix


.# $Id$
.# Copyright (C) 1993-1998 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1998 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
