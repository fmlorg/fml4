.C	インストール
.l	install

.S	インストール

インストールについては(READMEでもそういっていますが)
INSTALL(doc/INSTALL) を見て下さい。

「お手軽なインストール」はfml を広げた directory へいって

   % make MAIL_LIST=作りたいMLのアドレス MAINTAINER=ML管理者のアドレス

で、インストール先のマシンに合わせたサンプル(./samples/の下)まで作るの
で、それを参考にしながらで十分インストールできるとおもいます。

細かいカスタマイズをしたくなったら、このドキュメントを見ながら 
config.ph を直したりすれば良いでしょう。


.S	Version up

Version up は *.pl をコピーすれば終りです。

注意：fml 1.x 時代の場合の注意は .ptr{appendix:fmlR1}


.S	インストール後にサーバの設定（パラメータ）をいじる
.l	how-to-customize-parameter
.key	fml.plの起動のしかた
.key	exec fml.pl
.key	$DIR
.key	$LIBDIR
.key	fml.c
.key	fml.plの引数


例によって複数のやり方があります:-)

○	ひとつしかMLがない場合
	
	config.ph をいじるか コマンドラインオプションで変更します。
	
○	複数のMLがある場合

	ML固有の変更はそれぞれのMLの config.ph へ変更を加えるか

	include file 等で fml.pl --distribute のようにコマンドラインオ
	プションで変更するか？

ですが、複数の ML に共通の設定であれば libsmtp.pl 等がおいてある場所に 
sitedef.ph を作って、これの中にいれておくとよいでしょう。
.xref	order-of-option-effeciency, init-data-structure

例：
	/usr/libexec/fml/sitedef.ph


.S	fml.plの呼び方、引数の渡し方(4.3BSD)
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list
.label	calling-fml.pl
.seealso fml-uid, plural-handling-1, plural-handling-2

fml.pl の中に変数は今はもうありません (fml 1.2 より)

fml.c の中で fml.pl directory ... という形で呼ぶようになってます。

	fml.pl config.phのあるdirectry libaries 

の形で呼ぶ。上と同じことを↓こういう書き方（ちゃんと動くか否かは 
sendmail の version 依存）ができます。

   /etc/aliases では

	Elena: :include:/usr/local/ml/include/Elena
	owner-Elena: fukachan

   /usr/local/ml/include/Elena の中身は

	"|/usr/libexec/fml/fml.pl directory"

こうするとElena(include ファイル)の所有者のIDで動くようになります。


.S	fml.plの呼び方、引数の渡し方(4.4BSD or POSIX)
.label	calling-fml.pl-POSIX
.key	POSIXなsetuid
.key	POSIX
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list

もし POSIX なら 

   % make OPT=-DPOSIX 

とすると、 uid gid を今の環境からわりだして自動的にこういう風に 
compileします。↓

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
perl sbin/ccfml cc -s -O -DPOSIX   fml.c -o fml
O.K. I'll try to guess your OS...
-f /usr/include/sys/types.h
-f /usr/include/unistd.h
#	... No OS= option specified; dynamically determining OS type
#	... OS appears to be "nos4"

cc -s -O fml.c -o fml  -DXXUID=65536 -DXXGID=999 -DPOSIX  -DOS=nos4 
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

fml ができたら root権限で

   # chown root fml
   # chmod 4755 fml

これで、setuid が動くはずです。この場合は root の権限で一回動いて あな
たのuidに設定して fml.pl を起動します。
＃これ最後の手段だから…

こういう時は /usr/local/ml/driver/fml とかにして そこは root 以外は絶
対に書けないとかにしておくくらいの注意を払いたいものです。
それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。管理者の方と相談して見てください。


.S	binary の driver 
.label	c-wrapper
.k	fml
.k	fml.c

	/usr/local/ml/include/Elena というファイルを sendmail が実行し
	その中身は

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

	のように書いてある。

と上述しましたが、このやり方が変なOSもしくは古い sendmail では駄目な場
合があります。

その場合次のような setuid された driver(binary) を使うということになり
ます。fml.c をいじり、compile します。fml.c は通常 最初の make の時に
あなたの環境に併せて変更されていますが、確認はしてみてください。

それは次のような内容です。fml.c の中に

	fml.plの場所   config.phのある場所   ライブラリの場所

の形でexecするように埋め込んで最初にcompileしました。
directoryを変えるにはここを書き換えてrecompileです。
＃since 1.1.2.17 1994.3.14 version

例： fml.c

execl("/usr/libexec/fml/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/var/spool/ml/Elena", /* config.ph は どこ？ */
      "/usr/libexec/fml", /* fml packeage の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル等を見ながら直してみて下さい。

version up は *.plファイルをコピーするだけなので 一度設定すれば driver 
の設定を変更する必要ありません。


.S	OSによるfml.plの呼び方の違い一覧
.label	{calling-fml.pl-and-OS}
.key	OS_dependence

INSTALLにOSのまとめ一覧があります。ご覧ください


.S	まとめおくり
.label	msend-intro
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.xref	msend

詳細については「まとめ送り」と「CRON」の章を見て下さい
.xref	msend cron

まとめおくりとは

	特定時間になると配送リストの情報に基づき
	その時間に送ることになっている人に
	まだ送っていなかった分のメールをスプールから取り出して送る

ということをすることです。送るべき時間になった時その場で作るため
各ユーザーごとに
   配送するべき時間
	Ｎ時間おき、一日一回等

   配送時のファイルのまとめ方

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を定義できます。# matome (digest) コマンドで各ユーザが定義して下さい。



.S	コマンドコントロール専用のアドレス
.label	{control-addr}
.seealso calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス
.key	コントロール専用アドレス

config.phの中で

	$CONTROL_ADDRESS = 'Elena-ctl';

をセットすると、 Elena-ctl宛のメールはコントロールコマンドのルーチンだ
けしか呼ばないようになります。つまり、このアドレスにくれば間違ったメー
ルがきても配送はしない

ちなみに
	'Elena-ctl';

でも
	'Elena-ctl@axion.phys.titech.ac.jp';

のようにフルアドレスを書いても良いです。

ローカルからコマンドメールを出す時のことを考えると、
フルアドレスじゃないほうが望ましいという意見があります。
＃ sendmail.cf 等に依存した話なので断言はできませんが…

この場合/etc/aliasesに

	Elena-ctl: Elena

とか書くことが必要です。＃ newaliasesも忘れずにね


.S	メンバーチェックと自動登録について
.xref	auto-regist delivery-mode

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトではメンバーチェックを行ないます。
＃何をやってるかは fml.pl の subroutine MLMemberCheck を見て下さい

チェックするか否かは config.ph の中で

	$ML_MEMBER_CHECK 

という変数で指定します。

[メンバーチェック]

	$ML_MEMBER_CHECK = 1;

の時は $MEMBER_LIST (デフォールト members) の中に From: 行のアドレスが
存在するか否か？を調べます。ない場合は管理者へ知らせ、さらに From: 行
のアドレスの人へ $DENY_FILE を送り返します。
この場合の配送は $ACTIVE_LIST に従って配送されます。


[自動登録]

	$ML_MEMBER_CHECK = 0;

の時は $MEMBER_LIST (デフォールト members) の中に From: 行のアドレスが
存在するか否か？を調べます。

存在しない場合は管理者へ知らせ、(例えば From: 行の)アドレスを自動的に 
$MEMBER_LIST に登録します。

配送は $MEMBER_LIST のみに従って配送されます（注意）。
つまり自動登録時は $MEMBER_LIST しか使っていないのです。
＃実は $ACTIVE_LIST = $MEMBER_LIST に設定しています。

自動登録はキーワードを必要とするとか登録したいアドレスを指定したい時に
どうするか？等に関して様々なバリエーションがあります。
詳細については「自動登録」の章を見て下さい。
.xref auto-regist


コマンドラインオプションでも
.xref	clo

	check		メンバーチェック
	auto		自動登録（どういうメールが来ても登録）
	autosubject	subject: subscribe のキーワードを必要とする
	autobody	メール本文にsubscribe のキーワードを必要とする

等がカスタマイズできます。これらの詳細については「自動登録」の章を参照
.xref	auto-regist

例：
	/usr/libexec/fml/fml.pl /var/ML-dir --auto 



.S	$MAINTAINER というアドレス
.key	UNIX_FROM
.key	$MAINTAINER

ＭＬの管理者のアドレスです。“大雑把に”いうとエラ−メ−ルの帰る場所と
思ってもいいです。エラーが返る時にこれがＭＬ宛になっていると無限ループ
するわけですね。

インターネットでは歴史的に listname (MLの名前) に対して

	listname-request は管理者のアドレス

が多いです（絶対ではない）。ちょっと request というのが直観に反すると
ころもありますが…
いつも私はこの事実との整合性とわかりやすさのために

	listname-admin 		管理者のアドレス
	listname-request 	listname-adminへフォワード

のように設定しています。そのためどちらのアドレスへ送られても管理者へそ
のメールは届くわけです。


.S	他の人にＭＬのスプールを見せない設定

要はＯＳの permission を正しく使う。それだけです。setuid() してから実
行するのでＭＬ管理者の権限で fml は走っています。そのため全てのファイ
ルを管理者以外の人が見れない様になっていればＯＫなわけです。

例：
% pwd
/var/spool/ml/Elena
% ls .
config.ph spool	...(省略)

という directory とする。/var/spool/ml/driver/Elena には 

   "|/usr/libexec/fml/fml.pl /var/spool/ml/Elena /usr/libexec/fml"

のように書きます。 permission は以下のようであればＯＫです。

	/var/spool/ml/driver/Elena 	755

	/var/spool/ml/Elena 		700
	/var/spool/ml/Elena/spool	700

等の/var/spool/ml/Elena以下の階層はすべて管理者のみ read write 可能に
します。

この場合はまず sendmail (root 権限)がメールを受けた時

	sendmail (root 権限) は
	/var/spool/ml/driver/Elena を読めないといけません

そのため 755 にしておきます。どのみちこのファイル自体を他人に読まれて
も影響はないので 755 で構いません。

	/var/spool/ml/driver/Elena 
	を通して
	"|/usr/libexec/fml/fml.pl /var/spool/ml/Elena /usr/libexec/fml"

を実行する時までに setuid() system call をかけ 

	/var/spool/ml/driver/Elena 

の所有者のプロセスになっています。つまり fml.pl を exec() する時はすで
にＭＬ管理者のプロセスなので、 fml は /var/spool/ml/Elena 以下のファイ
ルを操作しますが、そのためにはこれで必要十分なわけです。


.#	
.#	.S	配送されるメールのヘッダのカスタマイズ
.#	.xref	header
.#	
.#	.S 	それ以外のこまごまとしたこと（OS, MISC: OTHER CUSTOM OPTIONS）
.#	.xref 	misc
.#	
.#	
.#	.S 	HOOKS: ML-specific hooks e.g. "# list"
.#	.xref	hook hack
.#	


.C	配送のモード
.l	delivery-mode


以下では配送のモードについて解説します。fml の設定変数は非常に多岐に渡っ
ています。またメタレベルで設計されている部分もあります。

そのため設定の自由度は高いのですが、そのためにわかりやすさは多少犠牲に
なっています。そこで、

代表的なモードは”簡易モード設定”という形でわかりやすいユーザインター
フェイスを提供するようになっています。

初めはわからなくてもいいので、もっと細かくいじりたくなった時にその設定
の意味を調べれば良いとおもうのです。


.S	デバッグモード
.k	デバッグモード
.label	debug-mode
.k	$debug

	$debug        = 1;

デバッグモードのフラッグ。１がデバッグモード。配送以外の設定、コマンド
操作はすべて有効です。テストに使って下さい。０に設定しないと配送してく
れません。


.S	DEFINE_MODE マクロ
.k	DEFINE_MODE
.k	&DEFINE_MODE
.xref	auto-regist

マクロというのは正確ではないですが config.ph で簡易モード設定ができま
す。

特に歴史的な理由で自動登録とメンバーチェックをするモードの設定はわかり
にくいので、このモード設定をつかうと楽かもしれません。

注意として、モード設定は config.ph を評価した後行なわれます。そのため、
config.ph の中で

	$ML_MEMBER_CHECK = 1;
	&DEFINE_MODE('autoregist'); 

とか書くと、自動登録モードになり、メンバーチェック ($ML_MEMBER_CHECK =
1)と宣言したことは overwrite されてしまいます。

注意：コマンドラインオプションはこの定義よりも強いことに注意して下さい

config.ph の中で

	$ML_MEMBER_CHECK = 1;
	&DEFINE_MODE('autoregist'); # 自動登録

でもコマンドラインで

	fml.pl --distribute ...

のようになっていた場合は、distribute モード（メンバーチェックも自動登
録もせずに、配送しスプールするだけのモード）に設定されます。

モード一覧は コマンドラインオプションを見て下さい。
.xref	clo


.S	簡易モード一覧
.xref	clo

詳細はコマンドラインオプションの項を見てね。ソースは libmodedef.pl です。

	distribute	配送だけ
	hack		ローカルハック用
	fmlserv		listserv emulation
	fml		デフォールト
	hml		hml emulation
	emudistribute	distribute を emulate(配送だけ＋ヘッダ変換等)
			注意：↑ distribute というprogramもあるのである 
	html		var/html に html 化した記事も作っていく
	check		メンバーチェック
	commandonly	コマンドだけを実行するサーバ
	mime		MIME 変換した記事等を置くなど MIME オプション
	through		すどおし
	auto		自動登録（どういうメールが来ても登録）
	autosubject	subject: subscribe のキーワードを必要とする
	autobody	メール本文にsubscribe のキーワードを必要とする
	cack		コマンドをだれでも実行できる（ + trick の時有用）


ソースより(以下 libmodedef.pl 2.0.2)：
.q
sub ModeDef
{
    local($mode) = @_;

    &Debug("ModeDef::$mode()") if $debug;

    require 'libhack.pl' if $mode eq 'hack';

    &FmlServMode    if $mode eq 'fmlserv';
    &FmlMode        if $mode eq 'fml';
    &HmlMode        if $mode eq 'hml';
    &EmulateDistributeMode if $mode eq 'emudistribute';
    &HtmlMode       if $mode eq 'html';

    if ($mode eq 'check')       { $ML_MEMBER_CHECK = 1;}
    if ($mode eq 'commandonly') { $COMMAND_ONLY_SERVER = 1;}
    if ($mode eq 'mime')        { $USE_MIME = 1;}
    if ($mode eq 'through')     { $SUPERFLUOUS_HEADERS = 1;}
    if ($mode eq 'auto')        { $ML_MEMBER_CHECK = 0;}

    if ($mode eq 'autosubject') { 
	$ML_MEMBER_CHECK = 0;
	$REQUIRE_SUBSCRIBE = "subscribe";
    }

    if ($mode eq 'autobody')     { 
	$ML_MEMBER_CHECK = 0;
	$REQUIRE_SUBSCRIBE = "subscribe";
	$REQUIRE_SUBSCRIBE_IN_BODY = 1;
    }

    if ($mode eq 'caok') {	# command anyone ok
	$Envelope{'mode:anyoneok'} = 1;
	$PROHIBIT_COMMAND_FOR_STRANGER = 0;
    }

    1;
}
.~q


.S	再配送だけをするサーバ（コマンドを必要としないサーバ）
.key	再配送だけをするサーバ
.xref	--distribute

単に配送を待って、それをスプールすることだけを目的にするMLを作ることも
あるでしょう。つまり ガイドを相手に返すこともなく、単に再配送するだけ
です。

	コマンドラインオプションの --distribute はそういう目的です。

別の言い方をすれば、/etc/aliases でやってるただのフォワードにスプール
機能がついてるようなものですね。

		
.S	コマンド専用サーバ
.k	$COMMAND_CHECK_LIMIT

fmlのデフォールトの挙動は

	メールの最所の３行のどこかが 
	# command（英文字だけの塊）
	の場合コマンドモードへ移行する

です。ちなみにこの３行の３は

	$COMMAND_CHECK_LIMIT           = 3;

で決めています。

これは 配送するのか？コマンドを実行するのか？の切替の合図に 

	# command options

形を使っているからです。
＃Emacs の C- (control) とか vi のモード切替えみたいなものです:-)

コマンドしか受け付けないアドレスなら "# command" syntax じゃなくてもい
いはずでず…	

	$COMMAND_ONLY_SERVER           = 1;

とすると 

	# command options 

ではなくメールは

	command options

の形と仮定します。つまり通常のメールもすべてコマンドとみなされてしまう
コマンド専用のサーバになります。


.S	コマンドor特殊目的専用のサーバへの変更
.k	コマンド専用のサーバへの変更
.key	特殊目的専用のサーバへの変更
.label	server-for-command-only

$CONTROL_ADDRESS にアドレスを登録するとコマンド専用野ＭＬサーバが作れ
ます。その場合 $CONTROL_ADDRESS に来た場合有無を言わさずすべてコマンド
と解釈します。

別の汎用の仕方として、

	$LOAD_LIBRARY = 'libfml.pl'; 

のようにバインドしたら コマンド専用だし、

	$LOAD_LIBRARY = 'libftpmail.pl'; 

とすれば、ftpmail 専用のアドレスに早変わりです。

それは $LOAD_LIBRARY が設定されていると、そのライブラリを評価して実行
するように作動します。この場合配送は行ないません。


.S	リモートで管理する設定
.xref	REMOTE-ADMINISTRATION
.xref	bin/passwd.pl

SMTPってしょせん…なのでデフォールトではリモートでサーバを管理するよう
にはなっていません。リモートで管理もできるようにモードを変えるには、

	コマンドラインオプションで --remote か

	$REMOTE_ADMINISTRATION = 1;

としてください。デフォールトではパスワードを要求する設定です。
＃つまり   $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1; の状態

パスワードは $DIR/etc/passwd に crypt された形で保存されます。

新たにパスワードを初期化する場合は
	bin/passwd -i mail-address new-passwod
のようにしてください。

例：
	% bin/passwd -i fukachan@sapporo.iij.ad.jp password

fukachan@sapporo.iij.ad.jp のパスワードを password という文字列に
設定する（実際にこんな間抜けなパスワードを付けてはいけません:-）

カスタマイズするべきファイル等は

   アドミンと認めるメンバーのリスト（Email-address）
   $ADMIN_MEMBER_LIST	= "$DIR/members-admin";

   アドミンのコマンドのHELPファイル
   $ADMIN_HELP_FILE	= "$DIR/help-admin";

   リモート管理にパスワードを要求する場合には１に
   $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1;

   その場合のパスワードを保存するファイル
   $PASSWD_FILE        = "$DIR/etc/passwd";

詳細は「リモート管理」の章を見てください。
.xref REMOTE-ADMINISTRATION 


.# ##########################################################
.include msend.wix
.include remote.wix
.include autoregist.wix


.C	コマンドの実行に関する２、３のこと…

.S	ＭＬで使えるコマンドを増やすor減らす
.l	add-procedures
.xref	add-admin-procedures

config.ph でコントロールできます。
いくつかの変数がありますが、次のように作動します

   1	@PermitProcedure が定義してあるなら
	@PermitProcedure で許しているコマンドだけを設定します。
	もし、定義されていなければデフォールトのすべてのコマンドが
	利用可能になります。
	これらの設定はグローバル変数の %Procedure に定義されます。

   2	%LocalProcedure が定義されているなら
	1 で定義された %Procedure を %LocalProcedure で上書きします。

   3	@DenyProcedure が定義されているなら
	@DenyProcedure のコマンドだけを使えなくする

例：
	○ guide と summary のみを使用可能、それ以外はすべて使用不可

	@PermitProcedure = ('guide', 'summary');

	○デフォールトに加え自分で定義した hack コマンドも使える

	%LocalProcedure = ('hack', 'ProcHack');

	もちろんこの場合はどこかで sub ProcHack { ...; } があって
	この関数を用意しておく必要がある。

	○デフォールトの中で get 関係は使えなくする
	@DenyProcedure = ('get', 'send', 'mget', 'msend');


.S	コマンドの # syntax は必要か？ 

“コマンド専用のアドレスにメールが来た時だけ”は考える必要がないですね
もし、コマンド専用のアドレスで

	# get 1
		も
	get 1

同じにコマンドとして動いて欲しいなら＃もちろん off bye 等も同様

	コマンドラインオプションで --commandonly か
	$COMMAND_ONLY_SERVER = 1; と config.ph に書く

かしてください。

もっとも、こうしておくと listserv とかわりませんな:-) 
.seealso fmlserv


.S	コマンドの書き方 [e.g. # get 1 と #get 1は同じものとみなす]
.k	# help ではなく #help 形式

以下は コマンドの書き方についてのオプションです。

	# get 1
	# help

のような書き方をしてきました。で、こうでない書き方は解釈してくれなかっ
たので、今度は

	# get 1 と #get 1は同じものとみなす（両方使える）
	すべてのコマンドで同じように "# " -> "#" 解釈する。
	さらに#getfile ...も# get ...と理解する。

としました。つまり、

	# get 1
	#get 1
	# getfile 1
	#getfile 1

は同じもの。同様に

	# help
	#help

を同じものにみなします。

.key	$COMMAND_SYNTAX_EXTENSION
	$COMMAND_SYNTAX_EXTENSION = 1;

両方解釈するなら１、"# summary" みたいな形式だけなら０


.S	コマンドは一辺に実行できるか？

例えば

	# get 1
	# get 2
	# get 3
	# help
	# summary

という内容のメールをＭＬサーバへ入れると

1、 2、 3 の記事を取り寄せ、ヘルプとさらにサマリファイルも取り寄せると
いう働きをします。bye を除き 一行一コマンドずつ順番にすべて実行します。

それは各行ごとにどんどん処理をするようになっているからです。
＃ ただし # exit はコマンドの終りです。ここで exit == end == quit


しかしながら

	uja
	# get 1
	# get 2

というメールの内容とエラーです。というのは、最初の３行のどこかで#では
じまる行があればコマンドモードとみなして処理を行なうためです。

最初の行は空行で２行目に#があるメールが、間違えて流れたりしないための
防止機構です。この“３”行の“３”を変えたいときは config.ph の中の

	$COMMAND_CHECK_LIMIT = 3;

を変えます（最初の３行をチェックする）。


.S	間違ったコマンドを送ってきた人への警告
.k	USE_WARNING 

デフォールトでは警告しません。

	$USE_WARNING = 1; 

でない限り、間違ったコマンドへの警告メールをだすことはありません。
これは signature を自動的に付ける設定をしている場合への対処です。
# exit 等で明示的にコマンド指定を終わらせるほうが推奨でしょうね


.S	コマンドの終り(シグニチャア対策)
.key	シグニチャア対策

	# exit 
	# end
	# quit

というコマンドを追加しました。このコマンドのところでアクションは終了し
ます。signature があってもいいように、こうしました。


.S	ＭＬサーバの作業エリア 
.key	$TMP_DIR

デフォールトでは $DIR/tmp (つまり $TMP_DIR = './tmp';) を使います。
変更したい場合は $TMP_DIR をセットして下さい。

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。
private communication なので public な場所にファイルを残すことはしない
方針なわけです。

その他にも 4.4BSD 風の directory 構造の中に各種のログやキャッシュが保
存されます。


.S	コマンドの結果を送り返すときにヘルプやなにかの情報も付加する設定

	$PREAMBLE_MAILBODY	（前）
	$TRAILER_MAILBODY	（後）
	を本文の前後に必ず付けます。

つまり、
	e.g. HELP コマンドにたいして、

	$PREAMBLE_MAILBODY	（前）
	HELPファイル本文
	$TRAILER_MAILBODY	（後）

のようになります。

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= $PREAMBLE_BODY.$e{'Body'}; #;
   ＃注：普通のＭＬのメールに $PREAMBLE_BODY がついて配送

と同じことですが、今は汎用性のためSMTPライブラリ中で処理される。

これと同様にすれば、本文にメールカウントを埋め込むことも可能になります。

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= "Mail Count: $ID\n\n".$e{'Body'}; #;

注意：このHOOKが走る関数中では %e == %Envelope 


.include forward.wix
.include fml_local.wix
.include fmlserv.wix


.# hikari beth
.# ##########################################################
.C	複数のメーリングリストの運用
.key	複数のメーリングリストの運用
.label	{plural-handling-1}
.xref	fml-process

ここでは

   fml がインストールされている時、メーリングリスト毎に一つ設定ファイ
   ルを保守するだけで複数のメーリングリストを運用するにはどうすればよ
   いか？

について説明します。


.S	複数のメーリングリストの運用時の設定の理論
.label	plural-handling-2
.xref	fml-process

.ptr{fml-process} (詳細はそちらを見て下さい)で説明されている通り

	fml.pl	MLのHOME(config.phのあるところ） libraryの場所

の形で与えることができます。なお、fml.pl と libなんとか.pl が同じ場所
にあるなら「libraryの場所」は不要です。
.xref	fml-process

fml は

	config.ph （とその置き場所以下の階層、つまりＭＬのホーム）

ですべての挙動が決まります。つまりこの部分さえ別に保守すれば複数のＭＬ
はすぐに操作可能です。


.S	２つのメーリングリストの運用の設定例
.k	２つのメーリングリストの運用の設定例
.k	複数のメーリングリストの運用の設定例

以下では Elena というＭＬともう一つ別の freekick というＭＬを設定
する時の例です。複数あっても以下同様です。

○ ＭＬのホーム（directory）を別々に作ります。

	/var/spool/ml/Elena
	/var/spool/ml/freekick

○ config.ph を分けるため

	/var/spool/ml/Elena/config.ph
	/var/spool/ml/freekick/config.ph

を作り、それぞれのＭＬ用に定義します。

○ sendmail から呼び出す時に

   /etc/aliases は

	Elena:	  :include:/usr/local/ml/include/Elena
	freekick: :include:/usr/local/ml/include/freekick

のように別のアドレス（当たり前）で別の INCLUDE ファイルを呼び出します。

この場合

	/usr/local/ml/include/Elena は
	"/usr/libexec/fml/fml.pl /var/spool/ml/Elena"

	/usr/local/ml/include/freekick は
	"/usr/libexec/fml/fml.pl /var/spool/ml/freekick"

のように呼び出します。この後 

	Elena ML は 	/var/spool/ml/Elena/config.ph 
	freekick ML は 	/var/spool/ml/freekick/config.ph 

に従い、それぞれの directory 以下の階層に記事やログを残すので
別々のＭＬとして挙動することになります。

○ :include: が使えないＯＳ

上述のようにfmlの呼び出し方をそれぞれ変えるので、
setuid program を各ＭＬ用に作ればいいわけです。

可変引数をとる setuid program は security hole になり得るので、ちゃん
と別の C program を作り、それぞれ compile し注意してインストールします。

fml.c を参考にして下さい。fml.c を

  Elena ML が

  execl("/usr/libexec/fml/fml.pl", "(fml)", "/var/spool/ml/Elena", NULL);

  freekick ML が
  execl("/usr/libexec/fml/fml.pl", "(fml)", "/var/spool/ml/freekick", NULL);

のように変更し、compileすればいいわけです。



.S	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.k	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.xref	fmlserv


.# ##########################################################
.include header.wix
.# .include configmisc.wix
.include archive.wix
.include expire.wix
.include href.wix


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996      fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
