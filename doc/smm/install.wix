.C	デバッグについて
=E.C	How to debug
.l	debug

コマンドラインオプションについては => .ptr{-d}
SMTPのログとり => .ptr{$SMTP_LOG}

.S	デバッグモード
=E.S	Debug mode
.k	デバッグモード
.label	debug-mode
.k	$debug

	$debug        = 1; (default 0)

デバッグモードのフラッグ。１がデバッグモード。配送以外の設定、コマンド
操作はすべて有効です。テストに使って下さい。０に設定しないと配送してく
れません。デバッグの内容をSTDERRに吐きます。
=E
In debug mode, fml.pl does not distribute (for test).

.S	デバッグモード レベル２
=E.S	Debug mode level 2 

$debug を2以上にすると、にデバッグ出力を
=E
If $debug >= 2, fml writes debug info the file

	$DEBUG_LOGFILE (default "$DIR/log.debug")

ファイルに吐きます。

.S	How to debug (1)

in fml-support: 5282
.if LANG == JAPANESE
.q
1. OSのメールのログを調べる。
   see INSTALL file Appendix A.

2. fml のログを調べる。$DIR/log (ML's HOME ログファイル)

3. fml からMTAへちゃんと渡せているかのログを調べる。
   ($DIR/var/log/_smtplog)

4. "makefml test ML" で fml 自体が動いているかを調べる。
   このテストはMTAとは完全に無関係に動くのでこれが動くならMTAの問題

	makefml test ML

と打つとデバッグモードでの動作テストができます。画面に debug 情報が一
杯出るので emacs の shell mode なり /usr/bin/script などでログをとるな
りして見て下さい。makefml test ML を起動すると配送のテストかコマンドの
テストか？選択をしろといわれます。
.~q
.fi
.if LANG == ENGLISH
.q
1. check OS's maillog.
   following the check list in INSTALL file Appendix A.

2. check fml log, $DIR/log.

3. check the connection between fml and MTA, $DIR/var/log/_smtplog.

4. "makefml test ML" helps you to test fml.

.~q
.fi

.S	How to debug (2)［デバッグのポイント］
=E.S	How to debug (2)
.k	debug

From: fml-support: 01411

…略…

○ 私 printf デバッグがすきなので $debug = 1; にした時の画面に出るエラー
情報から推測するのが多いです。
=E
* Printf debug is fundamental technique. FML has $debug variable. If
you know the details of processing, set $debug = 1, which helps your
debug. If $debug is 1, FML shows all debug information.

もしくは

○ perl -d オプションで perl debugger を使う
=E
* perl -d enables perl debugger. See perl manual for how to use it.

Example:

	% ($FML/bin/emumail.pl; echo something )|perl -d $FML/fml.pl $PWD
	....debugger starts ...
	<1> t
	<2> c
	.... debug information flood! ....


○ どのファイルか？は目的別なのでそれっぽい名前のことが多いですが…
=E
* Which file is libraries for an object?
  A lib"NAME".pl library corresponds to functions on "NAME".
  e.g. libsmtp.pl is SMTP (Simple Mail Transfer Protocol) routines.

	基本関数	fml.pl
	SMTP		libsmtp.pl
	その他		lib(それっぽい名前).pl

	[Naming Convention Example]
	ra  = remote administration
	fop = file operation
	...

とか省略系もあるけど… ちなみに
.ptr{library-lists} にライブラリの説明一覧があります。

.S	消してもいいファイル…
=E.S	I can remove this file or not?

プロセスがない時なら、すべてのファイルは手作業でなにしてもいいです。例
えば MTA を止めてメールを受けないようにしてしまえば何をしても大丈夫で
す。結局メールがきた時"だけ" fml.pl が動いているので、それ以外の時は何
をしても大丈夫です。まとめおくりのファイルについても msend.pl が走って
いる時を除けばvar/log/msendrc をいじっても大丈夫です。そうでないときな
ら手動 edit できます。
=E
If no process runs, you can edit any files :-). However in general we
do not know when mail comes in.  You should lock FML to edit files.

.if LANG == JAPANESE
makefml lock ML		MLをロックする。プロセスを殺すか
			3600秒たってTIMEOUTするまでロックは解除されない。
			例:
			% makefml lock elena &
			mule config.ph などなど
			プロセスを kill する		
			
makefml edit ML ファイル名
			% makefml edit ML cf
			lock して cf を編集できる。ロックの下で
			環境変数 EDITOR のエディターが起動される。
			エディターの終了後 lock ははずされる。
			もし環境変数 EDITOR が未定義だと
			どのエディターを使うか聞かれる。
.fi
.if LANG == ENGLISH
You need to do "makefml lock ML" locks before edit.

makefml lock ML		Lock ML. unlocked if this process is killed
			or timeouts in 3600 secs.
			e.g.
			% makefml lock elena &
			mule config.ph ...
			kill this process

makefml edit ML filename
			Under the ML is locked, editor is executed.
			Environment variable EDITOR is used.
			If it is not defined, makefml asks you what
			editor you use.
			After editor ends, makefml unlocks ML and exits.
			e.g.
			% makefml lock elena cf
.fi

そりゃさすがに code の debug は今動いているMLとは別のところでやったほ
うがいいですけど…
=E
I recommends the debug of codes apart from the current running ML :D

間違って消して一番困りそうなのは seq と var/log/msendrc あたりです :-)
もちろんメンバーリストも消すとやっかいです。
ようするにＭＬの今の記事番号や uniqueness を保存しているログです。
=E
Removing $DIR/seq, $DIR/actives, $DIR/members and $DIR/var/log/msendrc
must be critical. "actives" and "members" are the member list of ML.
"seq" is the current article number and "msendrc" is the log file of
msend (digest) which log saves the number of msend'ed articles.
If the content is lost, search for the following information.
The content of "seq" is the maximum number in spool dir articles.
Each "actives", "members" and "msendrc" has back up each file.
Restore them.

seq ファイルの番号が狂うと記事を上書きしたりはしないかわりに管理者にエ
ラーメールがきます。var/log にメールは保存されるので、復旧は簡単ですが
面倒は面倒です。

間違って seq を消してしまった時は 即効で spool の一番大きい番号を調べて
その値を seq へ書き込めばよいです。
=E
If you remove seq in accident, you should write the largest article
number in the spool as soon as possible. In the case of msendrc, you
have to write msendrc by reading log file ;_; If msendrc is lack,
msend.pl reconfigures the msendrc. But this msendrc must be not
continuous to msend'ed users since msendrc creates a new msendrc with
the latest article number.

msendrc 消しちゃうと msendrc のバックアップファイルを見て直すか log ファ
イルを参考にして直すかします。次回 msend.pl が起動する時に自動復旧され
ることを期待するか…ただ、これは最新のメールしか送らないから↑、たまっ
ていた分はログみないと不明のままになります。

actives, members などもバックアップファイルがあるので、それを見て再構成
してみて下さい。

.S	古典の printf debug の例
=E.S	printf debug
.k	debug: printf
 
.q
From: fukachan@phys.titech.ac.jp
X-Mail-Count: 00702 

例えば次のような適当な printf 構文をつっこむ
=E
For example, insert the following string.

	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";


&InitConfig;			# initialize date etc..
&Parsing;			# Phase 1(1st pass), pre-parsing here
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers

のあいだにはさんで、

	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&InitConfig;			# initialize date etc..
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&Parsing;			# Phase 1(1st pass), pre-parsing here
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";

とかしておいて、

% perl sbin/localtest.pl |sed 's/test/#guide/' | perl fml.pl $PWD -d 

とかして、この REQ:GUIDE の値の変化をみるというのはどうでしょう？

ただしいばあいは &Parsing のあと １になって そのままのはずですよね

.~q


.C	インストールについて
=E.C	Installation
.l	install


インストール作業については詳しくはINSTALLというファイルを見て下さい。
この章はINSTALLとのオーバーラップも多いですが、こまごましたことも少し
述べています。基本的にはINSTALLファイルの補助という位置付けでしょう。


.S	makefml によるインストール
=E.S	makefml installation

簡単なインストールインターフェイスとして makefml が用意されています。
=E
The simplest way to install Fml system is to run 

	make install
or
	perl makefml install

=E
in the top directory of the fml source. Please see INSTALL.English for
more details.

.S	makefml: 初心者向けインストール・インターフェイス
=E.S	makefml; an interface for beginners
.k	makefml: fmlのインストーラ
.l	sbin/makefml
.l	makefml

fml のソースファイルを広げて INSTALL というファイルを見て下さい。現在
では makefml という対話的にインストールや簡単なＭＬの設定を行なうイン
ターフェイスが附属しています。使い方は INSTALL というファイルにありま
す。
=E
For installation, extract FML package and see INSTALL for the detail.
FML provides "makefml" for interactive installation and configuration
interface. To see help of makefml, run just "makefml" or "makefml
help".

doc/op.jp というファイルと INSTALL の中間に当たるユーザーズガイドのよ
うなものが必要なのかも知れませんがそこまで手が回る暇がないす。
=E
I wound like to do re-structuring over documents but have no time.
If you would like to maintain them :-), I welcome it always.

.S	Version up について
=E.S	Version up
.l	version-up
.k	version up

.if LANG == JAPANESE
ソースを広げてインストールと同様に makefml install をして下さい。
makefml install install-directory (e.g. makefml install
/usr/local/fml)などとすると/usr/local/fml/.fml/system を読み込んで前回
インストールした時のパラーメータを自動的に使います。手動でも十分できま
すが、makefml の方がよいでしょう。
.fi
.if LANG == ENGLISH
Extract sources from FML package, change into it and run "make
install". It runs "makefml install" on UNIX. On Windows NT4.0 please
run ntinstall.cmd since we require special rewritings and so on.

"makefml install install-directory", for example, "makefml install
/usr/local/fml" uses the configuration parameter installed in the
previous time.
.fi
必要な作業は

	ロックして
	src/ bin/ sbin/ cf/ doc/ 群をコピー
	(必要なら path などを変更しながら)

などです。これらを makefml install が行なってくれます。
注意: fml 1.x 時代の場合の注意は .ptr{appendix:fmlR1}

.S	本当に残しておく必要のあるファイルは？
=E.S	Core part of FML package
.l	files-to-need

たまにどこが必要な部分ですか？と聞かれますが、makefml install を使えば
core の部分だけが概ねインストールされます。
=E
"makefml install" action installs core part of FML. It contains a set
of documents which is large. You can remove it if it is enough for you
to access the latest version always. The latest version of documents
are available via WWW. You can access the latest documents but not
back numbers, so you may lose the version specific descriptions.

makefml でインストールすると document 群も入れます。documents は大きい
です。インストール先の doc の下にまとまってるので、ここは消して構いま
せん。ドキュメントは「www.fml.org を見るから doc/html は要ら
ないから消す」という選択はありうるでしょう。ただ www では常に最新版の
内容だけが見られるという点に注意してください。ISPのシェルを使ってる場
合などならISP側ではなく自分の端末のローカルディスクに移しておくとゆう
手もあります。

それ以外に何を消していいかは機能をどこまで使うかに依存しているので一概
にはいえません。が document 以外で概ね 1M くらいです。ちなみに

	doc 	ドキュメント
	libexec 特殊なもの fml_local とかも含む
		fmlserv があるから消しちゃ駄目かもしれない
	bin 	fml 自体は使わない user 支援 program 群

etc, sbin, cf は消しちゃダメです。
=E
Except for documents, which files you can remove depends on functions
you want to use. DO NOT REMOVE "etc", "sbin", "cf" to use "makefml".

余談ですがFML.ORGのＭＬで調べるとだいたいMLのホームは 1000通 〜 4M く
らい必要と評価しておくといいみたいです。

.S	インストール後にＭＬの設定をいじる時
=E.S	Customize configurations
.l	how-to-customize-parameter
.xref	fml-maintenance
.xref	order-of-option-efficiency
.xref	init-data-structure

複数のやり方があります。本質的にはどれも設定ファイル(config.ph)を書き
換えるということです。コマンドラインオプションでも同じ設定が可能ですが、
保守や makefml インターフェイスとの整合性のため 2.1-RELEASE 以降ではコ
マンドラインオプションの使用は推奨されていません。
=E
You can rewrite config.ph to change mailing list configurations.  You
can also use "makefml" to change typical settings. Command line
options exist but I do not recommend to use it. It is used mainly for
debug today.

1	makefml
.k	makefml

初心者で内部構造がよくわからない場合はインストール時に使った makefml 
というコマンドを使って基本的な部分のＭＬの設定変更ができます。つまり 
"makefml config ML" で ＭＬのHOME/config.ph が変更できます。よく使いそ
うだと思われる基本的な設定はこれで十分でしょう。詳細については INSTALL 
を読んで下さい。
=E
"makefml" (CUI: Character User Interface) is an interface program for
a beginner. It is highly portable for CUI, so you can use the same
"makefml" on UNIX and NT4. Please see the file "INSTALL" for more
details.

インターフェイスが複雑になるのが嫌なので、ここでいじることのできる設定
は基本的なものに限っています。将来もできるだけ makefml config は少数精
鋭の設定のみを入れていく予定です(範囲を定めるのは難しいですが)。
=E
To configure config.ph you can use "makefml config". It covers a core
subset of config.ph configurations but it is enough for a beginner I
believe.

.if LANG == JAPANESE
[注意] 各ＭＬのHOMEには

	cf
	config.ph 

というファイルがあります。実は makefml config でいじっているのは cf で 
毎回 cf から config.ph を再生成しています。そのため config.ph をいじっ
ても、その後 makefml config をしてしまうと、ほとんどの設定は上書きされ
てしまいます。よって

・ cf を常にマスターとして、make config.ph で作成。ちょうど CF と 
sendmail.cf の関係のような関係になります。この場合は makefml config を
使っても大丈夫です。

・ 最初だけ makefml config でいじり、後は常に config.ph を手で編集
   MLをlock した状態でファイルを編集したいなら makefml edit config.ph 
   というコマンドもあります。

のどちらかのやり方で保守するべきです。
.fi
.if LANG == ENGLISH
"makefml config" changes ML HOME's "cf" file ($DIR/cf) and calls
translator to convert "cf" -> "config.ph". If "config.ph" is newer
than "cf", "makefml" finds and warns it. Hence if you change config.ph
by both makefml and hand, you need to maintain "cf" not
"config.ph". Typical methods for rewriting config.ph are follows:

Case 1: makefml	always

Use both makefml. In this case always rewrite "cf", and run "make
config.ph" to create new config.ph.

Case 2: manual edit 

After you create a new ML by "makefml newml ML", and "makefml config"
to set up ML, you always edit "config.ph" only by hand NOT USE
"makefml".
.fi

2	config.ph

それ以上のことがしたい場合は各メーリングリストの config.ph をいじって
下さい。
=E
Advanced setting is to rewrite config.ph.

3	sitedef.ph site_init.ph
.k	sitedef.ph
.k	site_init.ph

site_init.ph は FML のデフォールトの後で、config.ph の前に評価されます。
マシン共通の設定にこれを使うとちょっと便利かもしれません。config.ph で
上書きされる内容を書いてもしょうがないですが、config.phに通常現れない
設定のデフォールトを書いておいたりすると便利かも

複数のメーリングリストに共通の設定であれば makefml が fml.pl や 
libsmtp.pl を入れた場所に sitedef.ph というファイルを作ってこの中に書
いておくと config.ph の評価の後に sitedef.ph が評価されます。
config.ph の内容を強制上書きすることがあるような内容についてはこれを使
うと良いでしょう。なお評価順は
=E
site*ph files are common configurations. The difference of files are
evaluation order in fml.pl. Evaluation Order is

	FML default settings
	site_init.ph (default)
	config.ph    (each ML specific)
	sitedef.ph   (enforce this site configuration)

の順です。

Example: sitedef.ph で配送に使用するMTAのホストを決めうちする。
=E
Example: to enforce MTA's HOST to use as a distributor. in
/usr/local/fml/sitedef.ph

	$HOST = "mlrelay.dokka.org";
	1;

とか共通の設定を書く(この例では↑は配送に使うマシンをデフォールトから
mlrelay.dokka.org(注意:これは架空のホストです)というマシンに変更。

.S	:include: ファイル (fml.plの呼び方、引数の渡し方)
=E.S	:include: file
.k	:include: ファイル
.l	calling-fml.pl
.xref	fml-uid, plural-handling-1, plural-handling-2

fml の起動の仕方は
=E
How to kick off "fml.pl" is 

	fml.pl $DIR $LIBDIR

	$DIR	config.ph のある directory いわゆるMLのHOME
	$LIBDIR	library の path (必要なら)
=E
	$DIR	"ML's HOME directory, location of config.ph and so on
	$LIBDIR	library path (if needed)

の形です。このコマンドを起動して STDIN からメールを突っ込んで下さい。
つまり(PIPEで)
=E
MTA runs this command and injects mail to it. That is 

	| fml.pl $DIR $LIBDIR

ということです。これを sendmail にやらせるためには /etc/aliases 等に次
のように書きます。いろいろな書き方がありますが、それがちゃんと動くか否
かは sendmail の version に依存です。
例: Elena メーリングリストの場合
=E
Consider Elena mailing list setting. Sendmail reads the content of
/var/spool/ml/Elena/include (file to include) and checks the owner of
the file. Sendmail runs "|/usr/local/fml/fml.pl /var/spool/ml/elena "
(precisely e.g. sh -c "|/usr/local/fml/fml.pl /var/spool/ml/elena ")
as the owner process and passes mail for Elena to it.

   [/etc/aliases]

	Elena: :include:/var/spool/ml/Elena/include
	owner-Elena: fukachan
	Elena-request: fukachan
	Elena-admin: fukachan

   [/var/spool/ml/Elena/include]

	"|/usr/local/fml/fml.pl /var/spool/ml/elena "

$DIR が "/var/spool/ml/elena" で $LIBDIR は特に指定しない場合です。こ
の場合 include するファイル の所有者のIDで fml.pl が起動され、sendmail 
は そのプロセス(fml.pl)(のSTDIN)へML宛のメールを渡します。/etc/aliases 
を読んで /var/spool/ml/Elena/include を読み込むんだと知り、そのファイ
ルの中身の "|/usr/local/fml/fml.pl /var/spool/ml/elena " が起動されこ
のプロセスのSTDINにメールは入力されます。

なお単純にこれだけではだめでおまじないが必要なOSもいろいろあります。
OS によるfml.plの呼び方の違い一覧は次の章を見て下さい。
.xref{os-dependence}
=E
Please see .ptr{os-dependence} for OS dependence.

.S	C wrapper (:include: が使えない場合)
=E.S	C wrapper (when :include: does not work)
.label	c-wrapper
.k	fml
.k	fml.c

:include: 構文が使えない OS もしくは古い sendmail の場合は C wrapper 
を使う必要があります。
C wrapper は setuid して使います。setuid された program の引数でfml.pl 
を渡すとかいうことはしてはいけません。
＃そういうことをする外国のソフトがあるようですが…何考えてるんだろ
=E
When :include: statement does not work e.g. on old sendmail, you can
use C wrapper. C wrapper uses setuid(). Please pay attention to use
it. 

makefml newml すると見本の fml.c fml-ctl.c を作ってくれているのでそれ
を compile して作ります($DIRでmake)。fml-ctl.c は listname-ctl 用です。
fml.c は環境に併せて変更されていますが一応確認はしてみてください。
fml.c には実行する内容が hard coding されているので必要なら直接 edit 
して下さい。
=E
makefml newml creates examples of C wrappers, fml.c, fml-ctl.c. "make"
in $DIR.  Please check them and compile it under the ML's owner (NOT
POSIX). On POSIX or not, please see the following sections. fml.c is
for delivery program, fml-ctl.c is for command program.

Example:

	% cd /var/spool/ml/elena
	% make fml
	cc  -o fml fml.c
	chmod 4755 fml
	cc  -DCTLADDR -o fml-ctl fml.c
	chmod 4755 fml-ctl

(It is preferable to do "chmod 4555")

作成後 fml, fml-ctl をroot しか書けない場所へインストール。
=E
After compiling, install fml, fml-c to somewhere only root can access.

.if LANG == JAPANESE
[解説]

fml.c の内容は

	fml.plの場所   config.phのある場所   ライブラリの場所

を exec する C の program というだけのものです。ようするに include ファ
イルの中でやることと同じことを書きます。ちがうのは setuid() をするのが 
sendmail ではなくこの fml.c であることだけです。

例： fml.c

execl("/usr/local/fml/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/var/spool/ml/Elena",   /* config.ph は どこ？ */
      "/usr/local/fml",        /* fml package の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル (doc/op.jp) 等を見ながら直してみて下さい。

fml-ctl.c では
execl("/usr/local/fml/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/var/spool/ml/Elena",   /* config.ph は どこ？ */
      "/usr/local/fml",        /* fml package の library はどこ？ */
      "--ctladdr",             /* --ctladdr == コマンドモード */
      NULL);

になります。listname-ctl の方には fml-ctl を設定します。
.fi
.if LANG == ENGLISH
* Description

[fml.c]

  execl("_EXEC_DIR_/fml.pl", /* where is fml.pl */
	"(fml)", 
	"_ML_DIR_/_ML_", /* where is config.ph */
	"_EXEC_DIR_", /* library of fml package */
#ifdef CTLADDR
	"--ctladdr", /* --ctladdr, command mode */
#endif
	NULL);

  exit(0);
.fi

.S	C wrapper program fml on 4.3BSD
.k	fml.c
.k	fml

:include: 構文が使えない時は、setuid された fml という C の wrapper
program を経由して
=E
If :include: statement is not used, you can use C wrapper program. 
C wrapper does setuid() and runs

	/usr/local/fml/fml.pl $DIR $LIBDIR

を実行するという設定をします。makefml を使えば各メーリングリストごとに
専用の fml.c が作成されています。その directory で
=E
You can create C wrapper programs by

	% make fml 

とすると作成されます。fml.c の中で fml.pl directory ... という形で呼ぶ
ようになってます。
=E
Please see previous sections.

.S	C wrapper program fml on 4.4BSD or POSIX
.label	calling-fml.pl-POSIX
.key	POSIXなsetuid
.key	POSIX

もし POSIX 準拠OSを使っている場合は
=E
If under POSIX (latest OS's), runs "make"

	% make CFLAGS=-DPOSIX 

として fml を作成して下さい。uid と gid は makefml newml 時に fml.c に
埋め込まれています。fml ができたら root権限で
=E
Uid, gid are hard coded in executables in "makefml newml". After
compile, you switch user to root (su root), do change owners.

   # chown root fml
   # chmod 4755 fml
   # chown root fml-ctl
   # chmod 4755 fml-ctl

これで setuid が動くはずです。この場合は root の権限で一回動いてあなた
のuidに設定して fml.pl を起動します。install の仕方によっては 
permission をもっと厳しくできるはずです。設定には十分な注意を払って下
さい。setuid() を使うプログラム群 fml fml-ctl は root 以外は絶対に書け
ない場所にインストールして下さい。

それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。詳細については管理者の方と相談して見てください。
=E
Now you have root setuid() program. PLEASE TREAT THEM CAREFULLY. IT IS
BETTER TO CONSULT YOUR SYSTEM ADMINISTRATORS.

.S	まとめおくり
=E.S	Digest Delivery
.l	msend-intro
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.xref	msend

INSTALL ファイルの説明で設定だけはできるはずです。
それ以上の詳細については「まとめ送り」と「CRON」の章を見て下さい。
.xref	msend cron
=E
Please see INSTALL for set up of digest delivery. It must be enough.
For advanced settings, please see chapters .ptr{msend} and .ptr{cron}.

.if LANG == JAPANESE
まとめおくりとは

	特定時間になると配送リストに基づき
	その時間に送ることになっている人に
	まだ送っていなかった分のメールをスプールから取り出して送る

ということをすることです。送るべき時間になった時その場で作るため
各ユーザーごとに

   配送するべき時間
	N時間おき、一日一回等

   配送時のファイルのまとめ方

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を定義できます。matome (digestでもよい) コマンドで各ユーザが定義し
て下さい。
.fi
.if LANG == ENGLISH
Digest delivery is to store mails to deliver until the time and sends
a pack of mails periodically. FML provides each time, file format for
each user.

time
	unit is hour. e.g. once a three hours, or once just at 17 ...

file format (available formats for "mget" command) 
	UNIX FROM
	RFC934
	RFC1153
	MIME/Multipart
	tar + gzip
	lha + ish 
	...
.fi

.S	コマンドコントロール専用のアドレス
=E.S	Address for commands
.l	control-addr
.xref	calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス

makefml が作るデフォールトの config.ph では
=E
In config.ph makefml created, you see

	$CONTROL_ADDRESS = "Elena-ctl\@$DOMAINNAME";

のように設定されています。
注意: この変数はFMLにどのアドレスを使っているかを知らせるためのもので
この変数がOSの挙動を変えているわけではありません。ヘッダなどの表示にも
使われています。
=E
$CONTROL_ADDRESS is an address for commands. This variable is used in
header of reply mails but not concerned with MTA's configurations.
"makefml newml" creates examples based on $CONTROL_ADDRESS.  MTA's
configuration is another problem, e.g. sendmail is controlled by
/etc/aliases. Please set up /etc/aliases properly.

見本では コマンド専用の Elena-ctl アドレス宛のメールは include ではな
く include-ctl というファイルを :include: 構文で呼び出すように設定され
ています(include-ctl では fml.pl --ctladdr という形で呼び出す設定がさ
れているのが重要なポイントです)。

Elena-ctl宛のメールはコマンドのルーチンだけしか呼ばないようになります。
つまりこのアドレスにくれば間違ったシンタックスのメールがきても配送はし
ません。ちなみに
=E
For $CONTROL_ADDRESS addr-spec style is preferable. But both below for
$CONTROL_ADDRESS are available.

	'Elena-ctl';
	'Elena-ctl@axion.phys.titech.ac.jp';

どちらでもいいんですが、フルにアドレスを書く方が良いです。

最もローカルからコマンドメールを出す時のことを考えると、
フルアドレスじゃないほうが望ましいという意見もあります。
＃ sendmail.cf 等に依存した話なので断言はできませんが…

.if LANG == JAPANESE
なお、この場合/etc/aliasesに

	Elena-ctl: :include:/var/spool/ml/elena/include-ctl

とか書いてあることが必要です。ちゃんと書いたかチェックと newaliasesも
忘れずに。makefml の指示通りにすればこの設定もしているはずですけど。
.fi

.# beth
.S	メンバーチェックと自動登録について
=E.S	Member check and automatic registration
.xref	auto-regist delivery-mode

設計思想としてＭＬサーバはあくまでプライベート・コミュニケイションの延
長であると考えています。デフォールトではサーバーはメンバーチェックを行
ないます。また、そういう意味で自動登録よりも管理者がチェックした後に手
で登録を行なうのがより良いといえるでしょう。それはまた security 上も望
ましいことです。
.xref auto-regist
=E
We assume as a design policy that ML should be a method for private
communication. It is preferable to check whether a sender to ML is a
member or not. ML maintainers should edit and control member list
manually for subscription requests. It is default but you can change
this policy in config.ph.

"makefml newml" が終った状態つまりデフォールトの挙動では『メンバーとし
て登録されているアドレス』からのみ『投稿やコマンドメール』を送ることが
できます。
=E
Just when "makefml newml" is done, default state, FML can permit a
post and command mail from members registered to ML.

そうでない状態例えば自動登録などに設定を変更するなら"makefml config"を
使って設定を変更するないしcfやconfig.phを手で編集する必要があります。
自動登録は『メンバー以外からのメールが来た時に自動登録ルーチンを動かす』
という風に設定します。
=E
If you want to change this configuration, you can use "makefml
config", editing cf or config.ph manually.  Automatic registration is
available when you set $REJECT_COMMAND_HANDLER to be "auto_regist".

メンバーのアクセス制御については Chapter .ptr{access_policy} を参照し
て下さい。『メンバー以外からのメールが来た時に何をするか？』は
=E
Access control and the reaction is controlled by $REJECT_*_HANDLER
variables, like a

[$REJECT_COMMAND_HANDLER]

	$REJECT_COMMAND_HANDLER = "auto_regist"; (default "reject")

という変数で設定しています。

デフォールトは reject でメンバー以外の人がメールをＭＬに投げると『あん
たはメンバーでないからだめやねん』というメールを送り主に送り返します。
これを auto_regist に設定すると自動登録を行ないます。
=E
The default value is "reject". If ML receives mail from a not
member, ML rejects the request and sends back warning to a sender.  If
you set it to be "auto_regist", FML do automatic registration.

自動登録は次のような設定が典型的です。
=E
This is a typical case of "automatic registration".

	$CONTROL_ADDRESS               = "elena-ctl\@$DOMAINNAME";
	$PERMIT_COMMAND_FROM           = "members_only";
	$REJECT_COMMAND_HANDLER        = "auto_regist";

「メンバー以外からのメールは拒否するが、その際自動登録処理」に入る。以
下いくつかの設定パターンについて考えます。
=E
If $PERMIT_COMMAND_FROM is "members_only" and mail (subscribe
request) comes from a not member, fml.pl calls $REJECT_COMMAND_HANDLER
function. In default $REJECT_COMMAND_HANDLER is "reject", so fml.pl
notifies denial of service to the requester.  If
$REJECT_COMMAND_HANDLER is "auto_regist", fml.pl calls auto_regist
hander to sets in the automatic registration routine.

.# obsolete
.if LANG == JAPANESE
なお、昔は $ML_MEMBER_CHECK という変数で決めていましたが、今これは内部
変数として使われています。HOOK等で使われるだろうということを想定し歴史
的変数として残っています。$ML_MEMBER_CHECK が重要なのはこの変数によっ
て メンバーリストと配送リストが異なるからです。
.fi

[$PERMIT_POST_FROM    だれからの投稿を許すか？]
[$PERMIT_COMMAND_FROM だれからのコマンドメールを許すか？]
=E
[$PERMIT_POST_FROM    permit post from whom ?]
[$PERMIT_COMMAND_FROM permit command from whom ?]

○ メンバーチェックについて
=E
* member check

メンバーか否か？は $MEMBER_LIST (デフォールト members) の中に From: 行
のアドレスが存在するか否か？を調べています。
=E
fml.pl compares From: address and entries in $MEMBER_LIST
(@MEMBER_LIST if defined).

なお $REJECT_ADDR にマッチするアドレスはメンバーチェックに関わらず拒否
されます。例えば MAILER-DAEMON からのＭＬへの投稿などがそれに当てはま
ります。これはループなどの検出にも役に立ちます。
=E
fml.pl denies mail from $REJECT_ADDR e.g. root, mailer-daemon. It is
useful to check mail error loops and also to deny mail from public
users (mail from "nobody"? who are you?) since we assume ML is private
communication.

モデレータの場合はちょっと違うのでモデレータの章を参照 .ptr{moderators}。
=E
When $PERMIT_POST_FROM == "moderator", please see .ptr{moderators}.

○ 自動登録について
=E
* Automatic registration

自動登録はキーワードを必要とするとか登録したいアドレスを指定したい時に
どうするか？等に関して様々なバリエーションがあります。
詳細については「自動登録」の章を見て下さい。
.xref auto-regist
=E
See the chapter .ptr{autoregist} for more details of automatic
registration.
.xref auto-regist

.if LANG == ENGLISH
Described above, if $PERMIT_COMMAND_FROM == "members_only", mail
(subscribe request) comes from a not member and
$REJECT_COMMAND_HANDLER == "auto_regist", fml.pl calls auto_regist
hander to set in the automatic registration routine.

$AUTO_REGISTRATION_TYPE controls actions of routines.  If request
succeeds, fml.pl add From: address to $FILE_TO_REGIST (default is
$MEMBER_LIST).
.xref autoregist $AUTO_REGISTRATION_TYPE
.fi

メンバーチェックは @MEMBER_LIST で定義されたファイル群の中に(デフォー
ルトでは $FILE_TO_REGIST, $MEMBER_LIST, そして $ADMIN_MEMBER_LIST)の中
に From: 行のアドレスが存在するか否か？を調べています。そこに存在しな
い場合は(例えば From: 行の)アドレスを自動的に $FILE_TO_REGIST
($MEMBER_LISTがデフォールト) に登録し管理者へその旨を知らせます。

配送は $MEMBER_LIST のみに従って配送されます(注意)。つまり自動登録時は 
$MEMBER_LIST しか使っていないのです。なお、このモードでは $ACTIVE_LIST
と $MEMBER_LIST は同じものに設定されています。
=E
ATTENTION: In automatic registration, fml.pl delivers mail to
members in $MEMBER_LIST not $ACTIVE_LIST. This is historical (but I
cannot change it for backward compatibility;-). It does not annoy you
if you do not edit member lists by hand. Please see .ptr{auto-regist}
for several subscription styles ($AUTO_REGISTRATION_TYPE).

.S	メンバーチェックの際のアドレスのチェックの厳しさ
=E.S	How severely FML checks the validity of the address

アドレスのチェックを緩めたりきつくしたりしたい場合は
.xref $ADDR_CHECK_MAX
=E
* How severely fml.pl checks address syntax
please see .ptr{$ADDR_CHECK_MAX} for $ADDR_CHECK_MAX.

.S	$MAINTAINER というアドレス
=E.S	$MAINTAINER
.key	UNIX_FROM
.key	$MAINTAINER

ＭＬの管理者のアドレスです。エラ−メ−ルの帰る場所もこのアドレスです。
$MAINTAINER と $MAIL_LIST が同じになっているとエラーメールがＭＬに返っ
てきて無限ループします。
=E
Roughly speaking $MAINTAINER is an address which a user contacts ML
maintainers with and error mails returns to. In default fml.pl sets up
listname-admin and listname-request for listname ML. fml.pl uses
listname-admin as a maintainer address and prepares listname-request
as an alias. Historically it is good for you to prepare
listname-request also.

インターネットでは歴史的に listname (MLの名前) に対して
『listname-request は管理者のアドレス』であることが多いです(絶対ではあ
りません)。ちょっと request というのが直感に反するところもありますが…
いつも僕はこの事実との整合性とわかりやすさのために

	listname-admin 		管理者のアドレス
	listname-request 	listname-adminへフォワード

のように設定しています。そのためどちらのアドレスへ送られても管理者へそ
のメールは届くわけです。makefml のデフォールトは listname-admin です。
プロバイダではそれぞれの設定があったりするので注意して下さい。
=E
However some ISP services cannot provide listname-request or
listname-admin. Please consult with your ISP around on this point.

.S	ＭＬのスプールの read permission
=E.S	read permission for ML's spool ($SPOOL_DIR)

通常ＭＬ管理者の権限で fml は走っています。そしてＭＬの全てのファイル
は管理者以外の人が見れない様になっています。
=E
FML runs as an owner of a ML maintainer. In default the only maintainer
can read articles, spools, ...

例外としてメーリングリストの directory でも htdocs だけはすべての人が
読めるようになっています。これは httpd がどのユーザ権限で走っているか
わからないためです(通常 nobodyとかで走っている)。
=E
Some exceptional files exist. For example directories under htdocs/ is
world readable for httpd.

セキュリティについては .ptr{security}
=E
See .ptr{security} for security.

.S	スプールに記事をためない
=E.S	Not spooling of articles
.k	スプールに記事をためない
.l	$NOT_USE_SPOOL

DISKが足りない等で記事をためずに配送するだけにしたいなら
=E
If you have not enough disk, you may not spool articles. If so, set

	$NOT_USE_SPOOL = 1;

と設定してください。もちろんその場合は古い記事の取り寄せ等ができません
(当たり前)。
=E
Of course, "get", "mget" commands do not work.

.C	複数のメーリングリストの運用
=E.C	Run plural ML's
.k	複数のメーリングリストの運用
.l	plural-handling-1
.xref	fml-process

.S	複数のメーリングリストを作る。
=E.S	Create plural mailing lists

INSTALL を見て下さい。メーリングリストを作るには
=E
Please see INSTALL for how to create new ML's. Just run

	makefml newml listname

で listname というメーリングリストが準備されます。/etc/aliases に設定
を書いて newaliases を実行すればそれで終りです。
=E
and cut and paste an example of aliases to /etc/aliases and
"newaliases". That's end!

以下では実装の理屈について説明します。

.S	複数のメーリングリストの運用時の設定の理論
=E.S	How FML runs in plural ML's
.l	plural-handling-2
.xref	fml-process

.ptr{fml-process} (詳細はそちらを見て下さい)で説明されている通り
=E
Please see .ptr{fml-process} also. fml.pl runs after reading config.ph
for the ML, which config.ph is determined by the ARGV. If fml.pl is
called as "| fml.pl $DIR $LIBDIR", fml.pl reads $DIR/config.ph where
$DIR is ML's HOME directory. Hence plural ML's can run.

	fml.pl	MLのHOME(config.phのあるところ） libraryの場所

の形で与えることができます。なお、fml.pl と libなんとか.pl が同じ場所
にあるなら「libraryの場所」は不要です。
.xref	fml-process

fml は

	config.ph (とその置き場所以下の階層、つまりMLのホーム)

ですべての挙動が決まります。つまりこの部分さえ別に保守すれば複数のＭＬ
が独立に同時に動くわけです。

.S	２つのメーリングリストの運用の設定例
=E.S	Examples
.k	複数のメーリングリストの運用例

以下では Elena というＭＬともう一つ別の freekick というＭＬを設定
する時の例です。複数あっても以下同様です。
=E
Consider two ML's, Elena and freekick.

○ ＭＬのホーム（directory）を別々に作ります。makefml newml を使うと必
要なファイルは全部用意してくれますし directory も生成されます。
=E
create ML HOME. It is better to use "makefml newml" which prepares all
required examples automatically. 

	makefml newml Elena
	makefml newml freekick

=> (created)

	/var/spool/ml/Elena
	/var/spool/ml/freekick

○ makefml newml が作った config.ph を確認します。もし makefml を使わ
ないなら手で用意しなければなりません。このファイルがないと fml.pl は走
りません。エラーになります。
=E
makefml creates these config.ph's. If you do not use makefml, you can
set up them by hand.

	/var/spool/ml/Elena/config.ph
	/var/spool/ml/freekick/config.ph

を作り、それぞれのＭＬ用に定義します。

○ sendmail の場合: /etc/aliases を変更します。/etc/aliases に張りつけ
る内容は
=E
Rewrite /etc/aliases if you use sendmail. The content to write is in

	/var/spool/ml/Elena/aliases
	/var/spool/ml/freekick/aliases

に作られています。
=E
Example: 

	Elena:	  :include:/usr/local/ml/include/Elena
	freekick: :include:/usr/local/ml/include/freekick

.if LANG == JAPANESE
のように別のアドレス（当たり前）で別の include ファイルを呼び出します。
この場合

	/usr/local/ml/include/Elena は
	"/usr/local/fml/fml.pl /var/spool/ml/Elena"

	/usr/local/ml/include/freekick は
	"/usr/local/fml/fml.pl /var/spool/ml/freekick"

のように呼び出します。この後 

	Elena ML は 	/var/spool/ml/Elena/config.ph 
	freekick ML は 	/var/spool/ml/freekick/config.ph 

に従い、それぞれの directory 以下の階層に記事やログを残すので
別々のＭＬとして挙動することになります。
.fi

○ :include: が使えないOS
=E
* If you can not use :include:, please see .ptr{c-wrapper}.

.if LANG == JAPANESE
上述のようにfmlの呼び出し方をそれぞれ変えるので、setuid program を各Ｍ
Ｌ用に作ればいいわけです。

可変引数をとる setuid program は security hole になり得るので、ちゃん
と別の C program を作り、それぞれ compile し注意してインストールします。

それぞれの directory に作られている見本の fml.c を参考にして下さい。
fml.c は

  Elena ML が
    execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/Elena", NULL);

  freekick ML が
    execl("/usr/local/fml/fml.pl", "(fml)", "/var/spool/ml/freekick", NULL);

のようになります。
.fi

.S	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
=E.S	one command interface for plural mailing lists
.k	複数のＭＬがあるがコマンドの処理は一つのアドレスで一括処理
.xref	fmlserv

Please see the chapter "fmlserv" for more details.
.xref fmlserv


.S	ロックアルゴリズムの選択
=E.S	Lock Algorithm
.xref	how-to-lock

FML uses flock(2) in default. If you use flock(2), set

	$USE_FLOCK    = 1; (default 1)
.k	$USE_FLOCK

を設定すると flock system call をロックに使います。
=E
If flock(2) does not work on your OS, set

	$USE_FLOCK    = 0;

とすると link(2) を使うやり方にセットできます。デフォールトはflockです。
=E
to use a lock based on link(2). This algorithm uses lockfiles whereas
flock(2) is only in kernel.  If the machine shutdowns or reboots
suddenly, temporary lock files may be left in the lock spool. If
exists, please remove them. 


.S	MLを止めて(ロックして) config.phの edit をしたい
=E.S	Lock ML and edit its config.ph
.k	vipw.pl
.l	bin/vipw.pl
.k	maintenance.pl

ＭＬを動かしたまま config.ph を edit するのちょっと恐いです。夜中とか
メールがまず来ないと思っている時間ではなく、普通にメールが来得る時間帯
にメインテナンスをしたい時にはロックを書けた状態で editor を呼び出すこ
とが必要です。"makefml edit ML [file]" はこの機能を提供します。
=E
To edit files (e.g. cf, config.ph) under locking a ML like vipw(8),
FML provides the mechanism by "makefml".

	% makefml edit ML [file]

file が省略されると config.ph になります。

Example: to edit elena/config.ph 
	% makefml edit elena
	% makefml edit elena config.ph

Example: to edit elena/cf
	% makefml edit elena cf

注意: これを使って config.ph を edit してしまうと makefml config は基
本的に使えない。ということを意味するので注意して下さい。makefml config 
は毎回
=E
enables you to edit config.ph by hand.
==
ATTENTION: "makefml config" edits $DIR/cf and creates $DIR/config.ph
from $DIR/cf. If you use "makefml config" usually but now need to set
up FML over "makefml config" spec, you need to edit $DIR/cf manually
and run "make config.ph".

	 cf -> config.ph 

の生成手順を行なうため、cf ファイルがマスターになります。cf ファイルの
内容は makefml config でも保存されるので、makefml config を使う場合は 
cf を設定のマスターファイルにする必要があります。ちょうど sendmail.cf 
と CFの設定ファイルの関係のようになっています。

注意: 昔あった maintenance.pl や vipw.pl は削除されましたが、それと同
じことをする機能です。


.# $FML: install.wix,v 2.9 1999/05/11 10:54:59 fukachan Exp $
.# Copyright (C) 1993-1999,2001 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1999,2001 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
