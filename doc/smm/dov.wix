.C	ＭＬサーバ Overview
=E.C	ML Overview

-- ＭＬサーバとは何をすればいいのだろうか？

   ・日々の routine work をいかに自動処理化できるか？

   ・可能な限り user および ＭＬ管理者 にとっての自由度をあげる

   ・デフォールトは単に配送とユーザ用のコマンド(help や記事の取り
     寄せ、配送先の変更/停止等)

   ・しかしそれ以外の様々な機能もひととおり準備されていると便利
     これらの高度な設定は管理者が明示的に設定しなければならない。
     というのは管理者は何をしているのか知っているべきだし、
     何をしているかの把握はセキュリティ的にも望ましい。

    ………


.S	ML Server Process Overview

ＭＬサーバは本質的にフィルタリングをするものです。ＭＬ宛のメールが来た
ら配送プログラムから起動されいろいろな処理をした後、配送するべき(MLの)
メンバーリストを配送プログラムへ渡します。後は配送プログラムが配送を行
ないます。つまり配送はＭＬサーバの役目ではありません。
=E
A ML Server is a filtering process. 

[図]
=E
[Figure]

あるホスト                                    ＭＬサーバのマシン
=E
<a host>                                      <ML Server Host>

ＭＬのメンバーからのメール
=E
a mail from a member

   |
   V
  MTA (e.g. sendmail)  ------------------>     MTA (e.g. sendmail)

                                                |  kick off the ML server
                                                V

                                            ＭＬサーバ(ドライバともいう)
=E
                                            ML server (driver)

                                                |  
                                                V

                                    MTA (e.g. sendmail)  配送プロセス
=E		
                                    MTA (e.g. sendmail)  distribution process

                                             |  |  |  |  |  |
                                             V  V  V  V  V  V

                                             ＭＬのメンバー
=E
                                             members of the Maling List 

配送プロセスは上図のように動きます。ＭＬサーバが普通のメールではなくあ
る命令(ＭＬを辞める、過去の記事を読むなど)を含んだメールをうけた場合は、
それを実行して答えをリクエストした人へ配送します(コマンド)。

また上図からわかるとおりＭＬ宛のメールが来た時だけＭＬサーバは起動され
ます。つまり"不定期"にです。そのためリアルタイムにＭＬの記事(メール)を
読みたくない人、例えば3時間に一度過去3時間のメールをまとめて読む「まと
め送り」の場合は"定期的に"まとめ送り(.ptr{msend})を実行するプログラム
が起動される必要があります。FMLは定期的に起動しなければならないプログ
ラム群はcronというオペレーティングシステムが提供する機能を使っています。


.S	Historical View

FML 2.1 は Mailing List Server の package (Perl Scripts package) で、
僕が壱から Full Scratch したものです。
＃おまけCDROMつき雑誌等にある「…の改良」の記述は間違った推測なのです

これからＭＬをはじめる方にはそのままＭＬサーバをカスタマイズして使いた
いとおもっている方には改造の PLATFORM として利用してもらうことを想定し
ています。


.S	歴史(なりゆき?:-)とおおまかな視点
=E.S	Brief History and Overview

最初の発端は(フリーソフトの例にもれず)

	bug っているサーバ、
	機能の足りないサーバ、
	直すより自分で書いた方が早い

単にそういう話でした(ま、よくある話ですね:-)。

歴史的に hml 1.6 を一時期使っていて、その設定ファイルをコンバートする
のは面倒でした。そのため デフォールトの emulation は hml 1.6 を 
support しています(「なりゆき」ともいいますね)。


.S	FML 2.1

   Mailing List は Private Communication を便利にするツール(Filter) 

という観点を重視しているため、デフォールトではメンバーのみが投稿やコマ
ンドを使える という考え方を尊重しています。

結局のところ、日々の routine work をいかに自動処理化できるか？が重要で
す。逆にユーザにみえるインターフェイスはどうでもいいわけです。デフォー
ルトは

	投稿用のアドレス
	コマンド用のアドレス
	があり、それらのアドレスでMTA (e.g. sendmail)が受けて
	fml.pl を起動する

という形態です。しかし

   可能な限り user および ＭＬ管理者 にとっての自由度をあげる
   (簡単に設定できる自由度をできるだけ確保するべき)

という理想も追求したいところです。その結果として

   ・設定ファイルには sendmail.cf なみに様々な変数が定義されている

のを筆頭に

   ・コマンド用のアドレスは listserv(majordomo) スタイルでも可能

   ・ sendmail が動いていなくても POP3 を使ってＭＬを実行する

等様々なインターフェイスがパッケージ中に収録されています。

ＭＬサーバというものは一番肝心な部分はかなり簡単なのですが、実際にはそ
れ以外のさまざまな例外処理が発生します。それをいかに封じ込めるかをノウ
ハウというわけですが…また、環境による違いを吸収するためにさまざまな関
数をサポートする必要がありました。例えば ish, lha サポート

一方セキュリティ的には

   ・必要なことはしても、できるだけ何もしない
   ・機能の増加は簡単な configuration で、しかし明示的に指定しない限り
     よきにはからって動くべきではない

といえます。これが

   ある機能をONにする変数はあるが、明示的に指定しない限りONにはしない
   つまりデフォールトでは様々な機能はOFFにされている。	

ということの背景です。

多くの変数があるのは、簡単にある変数の値を変えるだけで挙動が変えられる
ようにするためです。また、それにより設定を操作するためのインターフェイ
スを割と簡単に書くことができます。

例えば makefml です。makefml を使ってのインストールや簡単な設定の変更
が可能です(ある程度以上複雑なことは手でやって下さい)。また頑張ればWWW
インターフェイスもすぐ書けるでしょう。

各種機能はそれぞれの目的に応じて選んでみて下さい。例えば『あるＭＬのロー
カルな再配送』のような場合はコマンド機能を落して使うべきでしょう。

例：

ip-connection を受けるアドレス (include ファイルを呼び出すアドレス)に
使う時は、makefml config listname で 配送モード指定を「誰でもPOST可能」
にする。

	$PERMIT_POST_FROM = "anyone";


.S	FML 2.1 機能の概要

ＭＬサーバはおおまかに


				設定ファイル(config.ph)の変数
	_____________________________________________________
	
	配送用のアドレス	$MAIL_LIST	
	コマンド用のアドレス	$CONTROL_ADDRESS
.l 	$MAIL_LIST
.l	$CONTROL_ADDRESS

からなります。特別な場合には(歴史的理由により) hml 1.6 (正確にはその元
祖の shell script) というサーバを Emulate します。特別な場合とは 

	配送用のアドレス==コマンド用のアドレス
	($MAIL_LIST == $CONTROL_ADDRESS)

の時です。

ＭＬサーバの現在の代表的な機能は以下のようなものです。

   ○ 配送用のアドレスとコマンド用のアドレス 
	-- Chapter .ptr{access_policy}

	それぞれについてアクセス制御や自動登録の設定
	なお特別な場合「配送用のアドレス==コマンド用のアドレス」は hml 1.6

   ○ 様々な自動登録方式
	-- Chapter .ptr{auto-regist}

	前述のどのアドレスで？ x 4種類 x 各カスタマイズ変数…

   ○ リモートメインテナンス/リモート管理
	-- Chapter .ptr{remote} .ptr{pgp}

	PGP, パスワード認証等の選択

   ○ 様々なヘッダカスタマイズ
	-- Chapter .ptr{header-custom}

   ○ 様々なコマンド
	-- Chapter .ptr{mget}

	ファイル取り寄せのコマンド mget コマンドのいろいろなファイル形
	式のサポート

   ○ まとめおくり
	-- Chapter .ptr{msend}

   ○ SMTP配送方式(リレー)
	-- Chapter .ptr{smtp}

   ○ その他(MIME処理等)

   ○ スプール
	-- Chapter .ptr{archive} .ptr{expire} .ptr{href}
	HTML自動化処理(thread化)、アーカイブ、Expire等

   ○ 複数のインターフェイス (listserv や majordomo style)
	-- Chapter .ptr{fmlserv}

	みかけがあたかも listserv のように fml のコマンド群を使う

必要に応じて設定ファイルで機能の追加・削減を行うことができます。
簡単なものは makefml で可能です。


.S	インストール

とりあえず細かいチューニングを行なわなくてよいなら
=E
The simplest way to install Fml system is to do in the top directory
of the fml source
# Hence a lot of variables are pre-defined.

	perl makefml 

=E
when you make a new ML 
=S
	perl makefml newml ML-Name
=S
e.g. to make elena@your-domain mailng list
=S
	perl makefml newml elena

ことで、インストールをします。ML の作成は

	perl makefml newml ＭＬの名前

で何個でも作れます。説明は INSTALL というファイルを見て下さい。
=E
Please see the file INSTALL for the detail.



.C	fml の機能についての概要
=E.C	Brief Overview of functions

注意: インストールやＭＬの作成の仕方についての詳細は INSTALL というファ
イルを読んで下さい。

.S	Directoryの使い方

基本的に directory は2箇所からなります。
インストール時に makefml で指定できます。

	１ /usr/local/fml の下に必要な実行ファイルとライブラリ群
	２ 各ＭＬ群が /var/spool/mailing-lists/ に作られる

	   /var/spool/mailing-lists/elena/	(elena ML)
	   /var/spool/mailing-lists/mirei/	(mirei ML)
	   ...

elena ML 関係の全てのファイルは /var/spool/mailing-lists/elena/ 以下に
作られます。設定ファイル(config.ph) や記事のスプールも同様です。
複数のＭＬを作成すると /var/spool/mailing-lists/ 以下に並びます。


.S	インストーラ 〜 高度/複雑な設定

対話的処理をする makefml という簡単なインターフェイスがついてきます。
これがインストールやＭＬの作成簡単な設定の変更を可能にしています。

初心者には、最初は何をやっているか良くわからないものです。とりあえず簡
単なものはこれでできるはずです。詳細については INSTALL というファイル
を見て下さい。より高度な設定についてはこの文書/パッケージ中の doc/op
『FML 2.1 の設計と実装)』を読んで下さい。

代表的な『ある動作をするか？否か？』についてはすべて設定ファイルで操作
することができます。アーカイブやスプール、help ファイルの場所 や『tar
ish lha のような system のコマンド』のようなものもすべて hard coding 
ではなく user が外部から制御できる変数として定義されています。
変数リストについて興味があれば cf/MANIFEST を見るとわかります。


.S	たくさんのドキュメント(複数のフォーマットで)

PLAINTEXT 版はパッケージ中の doc/ にあらかじめ用意されています。README
や INSTALLマニュアル の HTML 版も ぱっけーじ/doc/html/ の下に用意され
ています。doc/op のHTML 版は巨大なのでパッケージにはついていません。
必要なら

	shell% make doc 

でつくって下さい。ドキュメントの最新版は
.url	http://www.sapporo.iij.ad.jp/staff/fukachan/fml/
.url	http://www.fml.org/fml/
にあります。


.S	一般ユーザー権限ということ

一般ユーザーできればＭＬ用の特別なユーザーでFMLを動かすのが望ましいで
す。通常このユーザーは makefml で作られる include というファイルの所有
者です。

特別なユーザー 例えば daemon 等で動かすのはセキュリティ上好ましくあり
ません。また FML は実装上 Trusted User 等を気にする必要はないので 
daemon で動かす必要もありません。

ＭＬサーバのメカニズムとしてはユーザー権限で動かすために setuid() を行
なった後 fml.pl へ渡します。POSIX 準拠 OSは setuid() をちゃんと行なえ
る user は root に限られます。これはこれで正しい選択だし、ターゲットの 
4.4BSD もそういう実装をとっています。そのため setuid() はできるだけ 
sendmail 等の SMTP を受けるプログラムを信頼します(includeファイルの扱
い等のこと)。

sendmail 等がうまく setuid() を実行できない場合 4.3 BSD では fml.c を 
compile して使えば良いでしょう。makefml でインストールしていれば 
makefml が作った Makefile を使うと

	shell prompt% make fml

で fml が生成され、setuid されます。4.3BSD ではこれで十分です。

POSIX 準拠等OSでは ＊非常に危ないですが＊ この fml を root 権限に 
setuid しなければなりません。fml.c のコードと fml をどこにおいて使うべ
きか？について自信がない場合あなたのサイトもしくはそのマシンの管理者に
よく相談して下さい。



.S	ライブラリ・モジュールとダイナミック・ローディング


モジュールにすることにより

	マスターコードの保守
	自分だけのモジュールを独立に保守

することが容易になります。

もともとは SMTP部分の独立保守と 常時使うわけではないコマンド部分を切り
離すことを目的としたモジュール化でしたが、現在では必要に応じて dynamic
loading するさまざまなライブラリが提供されています。
ファイルは一杯ありますが、常に使われるのは2、3個くらいで後は必要がある
場合のみ使われます。

モジュールはインターフェイス仕様さえ不変なら独立に保守できます。
contribution され独立に保守されているコードも同様にライブラリに入って
います。例えば libtraffic.pl は

	libfml.pl の関数呼びだしインターフェイスに合わせれば、後は
	すべて user defined で作れる

というよい例です。
＃ぼくは中身についてタッチしていません。fml master code tree とは独立
＃に保守されています（感謝）


FML はこのライブラリ群が本体で、その動きを設定ファイル(config.ph)でカ
スタマイズするようになっています。そのためライブラリ・モジュールは一箇
所にまとめておくと『ひとつのfmlで複数のＭＬを扱うように拡張』等も容易
になり、また version up も楽です。makefml でインストールする場合はそう
いう形態になります。

例:
	ライブラリは /usr/local/fml の下に全部入れる
	ＭＬ群は /var/spool/mailing-lists/each-ml/
	   (e.g. /var/spool/mailing-lists/each-ml/config.ph )


ＭＬを配送ではなく特定の目的のサーバのみを dynamic loading して
『特定の目的のサーバ』にすることも簡単にできます。
＃config.ph で特定のファイル名を $LOAD_LIBRARY に設定する

これにより、

	コマンド 専用サーバ
	ftp 用サーバ
	ftpmail  専用サーバ 
	メールで request をうけてURLの中身を返すサーバ

等の専用サーバに設定することもできます。	

.include files.wix


.S	設定ファイル(config.ph)


できるだけソースコードを直接いじらなくてもたくさんの制御変数とフックで
カスタマイズできるようになっています。カスタマイズ可能な変数は 
config.ph 中に簡単な説明とともに書いてあるのでこれを変更することで行な
います。基本的なものについては makefml で変更ができます。



.S	アクセス制御と自動登録


前述のとおりデフォールトは来たメールの From: を見て、メンバーチェック
をします。FML 2.1 では投稿とコマンドそれぞれについて以下の

	・誰からの投稿を許すか？
		だれでもOK			anyone
		登録されているメンバーだけ	members_only
		モデレーターだけ		moderator (.ptr{moderators})

	・もし、登録されているメンバー以外から来た場合にはどうするか？
		許否				reject
		自動登録			auto_regist
		無視(管理者へ報告だけする)	ignore

を設定できます。デフォールトはいずれも

	メンバーのみ(members_only) 投稿/コマンドの使用 が可能
	もしメンバー以外から来たら許否(reject)

です。自動登録は"投稿がメンバーだけ"(members_only)の場合に

	もしメンバー以外から来たら自動登録 → auto_regist へ変更

することで行ないます。自動登録のタイプは4種類あります。
.xref	autoregist


.S	ファイル操作: 取り寄せとまとめ送り


get, mget, matome 等のコマンドにはオプションで tar.gz で固めてとか 
MIME/Multipart 形で記事をまとめて送り返して欲しい 等の変更ができます。
.xref	mget, msend

mget と まとめおくりでの User interface は次のようなものが取り揃えられ
ています。mget コマンド毎に指定を変えることができます。


	PLAINTEST 
		UNIX FROM
		RFC934	
		RFC1153
		MIME/Multipart

	COMPRESSED FILE
		gzip UNIX FROM file
		Lha + Ish 	（自動ＳＪＩＳ変換可）
		Lha + uuencode 	（自動ＳＪＩＳ変換可）
		tar + gzip
		uuencode

mget で取り寄せられるのはデフォールトは $SPOOL_DIR (default "spool") 
ですが対象は標準のＭＬの記事スプール以外にも @ARCHIVE_DIR に指定するこ
とで増やすことができます。

ファイル操作の応用編としてユーザーが put も get できるように拡張された
コマンドも実装しています（library コマンド）。
.xref library

ただしデフォールトでは、put するファイル名は security 上選べません。ファ
イル名を明示的に指定する場合は安全のため管理者が変更するべきです。

配送用のアドレスとコマンド用のアドレスが同じ場合($MAIL_LIST と 
$CONTROL_ADDRESS が同じ場合)記事とコマンドを見わける必要があります。こ
れは最初の3行のどこかに "# command（英文字Only）" シンタックスを見つけ
た場合にコマンドとして認識することで区別しています。

しかしこれ以外の場合↑は # でモードを切替える必要はありません。当然、
Listserv 形式のシンタックスをうけつけるように拡張されたインターフェイ
ス(libexec/fmlserv.pl)を使う場合には、どっちでもいいわけです。


.S	 MIME や base64 等の処理 
.xref	href

基本的にすどおしですが、MIME 処理は下請けにだして、Subject を decode 
してサマリーを作る等が可能です。またHTMLでは base64 の画像等の変換処理
を下請けのプログラムに渡して行ないます。つまりメール中の gif ファイル
を変換してメールの記事の html を生成します。


.S	リモートでＭＬを管理すること
.xref	remote
.xref	pgp

デフォールトではできません。設定ファイルで

	$REMOTE_ADMINISTRATION  = 1;

を設定するとできるようになります(makefmlでも設定できます)。
管理者として登録された人に対し

	From: 行での認証
	管理者一人ごとのパスワード	(秘密鍵暗合)
	PGPベースでの認証		(公開鍵暗合)

の組合せで認証をします。デフォールトは

	From: 行での認証
	管理者一人ごとのパスワード	(秘密鍵暗合)

です。どうせやるなら PGPベースが推奨です:)
.xref	pgp

FML 1.0 で『管理者が本当に操作しているかどうか?という点に関して保証で
きない』という理由ではずしたリモート管理(アドミンコマンド)を再実装し、
サポートします。保証できないという意味は From: での認証は簡単に偽造で
きるからです。

そのため普通パスワードも併用します。このパスワードは 各管理者ごとに設
定できます。管理者全体で一つの共通パスワードというようなださい実装はし
ません。これは普通の UNIX の パスワードシステム のミニチュア版です。サー
バ側では etc/passwd に 管理者ごとにパスワードを保存しています。 保証の
度合が上がったわけではありませんが、パスワードは crypt し保存していま
す。一応かつての UNIX 程度の保証はされます。
パスワードの保存を MD5 にすることもできます。

しかしながら、メールの中では平文パスワードを書く必要がありますし、ひと
りの管理者のパスワードは毎回同じで使い捨てではありません(時系列に沿っ
て)。よって、間違ってメールが読まれた場合を考えると危険なわけです。


PGPベースではこの心配はありません(もちろんあるメール全体を読まれていれ
ばそのメールと全く同じ内容を実行だけは可能なはずですが)。
.xref	pgp


.S	.forward
.xref	.forward

通常 include ファイルを設定するのは /etc/aliases ですが .forward は本
質的に同じものです。もっとも .  forward の場合ユーザー名以外のものを使
うことはできないわけですが。だから include は .forward に設定すれば同
じです。詳細は
.xref	.forward


.S	Listserv/Majordomo
.xref	fmlserv

   Listserv 互換用インターフェイス 	libexec/fmlserv.pl

fmlserv.pl を呼ぶようにした場合 コマンドは

	コマンド ＭＬ名前 オプション

になります。ようは Listserv 形式のしんたっくすで fml のコマンドを使え
るようにしたインターフェイスです。

	listserv:  fmlserv
	majordomo: fmlserv
	fmlserv: :include:/var/spool/ml/include/fmlserv

のようにしても大丈夫です。


.S	MTAとの通信 (e.g. sendmail)

デフォールトでは fml は sendmail 等の SMTP配信エージェントと自力で通信
します。

	$Envelope{'mci:mailer'} = 'ipc'; 

がデフォールトですが、

	$Envelope{'mci:mailer'} = 'prog';

とすることで $SENDMAIL という変数のプログラムを起動してそれに配送をさ
せることもできます。

	$Envelope{'mci:mailer'} = 'ipc'; 

の場合 $HOST で指定されているマシンに配送をまかせます。デフォールトは
自分のマシンで走っている sendmail と通信しようとしますが、

SMTP を理解してくれるなら sendmail である必要もないし配送用に使える
SMTPサーバ があれば動きます。それは必ずしも自分のマシンで sendmail が
走っている必要はありません。各サイトで走っているSMTPを理解してくれる配
送プログラムがあればよいです。

sendmail が走っているマシンが一つもなければ、sendmail を 'prog' で起動
するように 'prog' を指定すればよいです。


.S	メール → ＭＬサーバ

逆にどうやってメールを受けとるかという問題があります。通常 SMTP を理解
する受けとるサーバが走っていて、メールを受けとり fml.pl へ渡します。

例えば一定時間間隔で POP をかけてＭＬを動かし、配送はサイトの SMTP サー
バにやらせることでＭＬを実行するこは可能です。
.xref	popfml


.S	その他の機能

ロックは flock によるロック処理をデフォールトにしています。が flock() 
が動かない場合 UNIX V7 以来の link() によるロックを使います。

% hack によるリレーサーバを処理します。例えば、関東方面、関西方面にこ
ねがあって、マシンが調達できる場合、関東方面のメールを一回そのマシンに
送ることで関東方面へおくるメールを一つのメールでいっきにおくって、配送
はそのリレー先にまかすことで、配送を高速化できます。

プロバイダ等でDISKに制限があったりする場合は、古い記事は消したいとおも
いますが、そのための Expire 機能をサポートします。

また、同様に newsyslog をサポートし、古いログは自動的に
	e.g. log -> var/log/log.0 
のように変換し保存するようにしています。デフォールトでは members file 
や まとめおくりのログに対して newsyslog を実行しています。

一つのマシン上にある ＭＬ間のクロスポスト の場合、
複数のＭＬに入っている人には一通しか送らないようにします。
＃サイトにまたがる場合はデータのシンクロが必要なため実験段階です

おまけ機能として、スタートレックの宇宙歴をサポート（笑）します。
contrib/Utilities に宇宙歴をつけるmh, mh-e user interface つき:-)です。
.xref	startrek x-stardate


.C	Version Up と互換性について

.S	how to version up
.xref	version-up

makefml を使ってインストールしてもらのが確実です。
makefml の使い方については INSTALL マニュアルを見て下さい。


.S	新しい機能を有効にするには？

なお、新しい機能は config.ph へ差分だけを付け加えないと使えません 
(makefml で設定できる部分もある)。つまり、新しい機能・オプションは明示
的に指定しない限り単に動かないだけです。


.S	互換性について
.l	non-compat-1-2
.l	compatibility

FML では config.ph という設定ファイルが振舞いを決めます。
config.ph にも version という概念があります。

	$CFVersion
.k	$CFVersion

という変数で指定されています。現在の version は 3 です。version が異な
る場合、ほとんどの変数について自動的に補正が加えられ昔作った config.ph 
をそのまま使っても大丈夫なようになっています。

config.ph でちょっと複雑な HOOK を書けている場合はちょっと注意がいるで
しょう。というのはHOOKで使う関数や変数等が今でもサポートされているとは
限らないからです。

できるだけ互換性を保つように作られています。ただ 

    config.ph の $CFVersion が 3

で、なおかつ

   『$MAIL_LIST と $CONTROL_ADDRESS が違う場合の $MAIL_LIST の挙動』

の時は従来と異なり『配送専用』です。ここだけは互換性がありません。しか
し

	$MAIL_LIST と $CONTROL_ADDRESS が同じ場合は
	昔と同じで配送用のアドレス $MAIL_LIST で
	コマンド(# command の形)を受け付けます。

従来 $MAIL_LIST != $CONTROL_ADDRESS の場合にヘッダやHELP等では「コマン
ドは $CONTROL_ADDRESS へ送ってね」と書いてあるにも関わらず $MAIL_LIST 
でもコマンドは受けられたという変な挙動がありました。これを互換性と解釈
するかバグと解釈するかは微妙ですが、FML 2.1 のアクセス制御ルールの導入
時に上記の解釈になりました。

______________________________________________________
[比較表]

	elena		配送専用
	elena-ctl	コマンドだけ

になります。2.1 リリース以前(2.1 Gamma series)では 

	elena		配送もコマンドも処理する
	elena-ctl	コマンドだけ

のように振舞いました。elena でのコマンドの「配送とコマンドの切り分け」
はメール本文が"# command"であるか？否か？で決めています。

2.1 でも配送用とコマンド用のアドレスが同じ場合は

	elena		配送もコマンドも処理する

になります。この場合「コマンドなのか？否か？はメール本文が"# command"
であるか？否か？」で決まります。これがもともとの hml 1.6 互換のスタイ
ルです。
______________________________________________________


.S	補正ライブラリのダイナミック・ローディング

cf/config という生成コマンドで作るようになった時 $CFVersion = 2; とい
う version が与えられました。さらに、それ以前の手動編集のみだった時代
の config.ph を使っている場合は 1 と定義されています。

	$COMPAT_CF1 = 1;
.k	$COMPAT_CF1 

がセットされているか $CFVersion が２より小さい場合は自動的に

	libcompat_cf1.pl
.k	libcompat_cf1.pl

が dynamic loading されます。また 3 以下と判定された場合は

	libcompat_cf2.pl
.k	libcompat_cf2.pl

が自動的にローディングされます。


.S	FML 1.6 より前からの移行について

1.6では、基本的なデータ構造を call by reference 用に書き直したので、
いままでの SMTP_OPEN_HOOK 等の カスタマイズはそのままでは反映されません。
libcompat.pl にBackward compatibility のためのコードがあります。
昔の設定を変えたくないなら、config.ph に 

	$COMPAT_FML15 = 1; 
.k	$COMPAT_FML15

と書くと複雑なフックをしかけていない限り compatible にできます。
コードの都合上どうしても実現できないカスタマイズもありえます_o_

昔できたことは今の実装でも必ずできるのでこのドキュメントを参照してみて
下さい。


.S	FML 2.0 〜 2.1 の間の compatible
.k	$COMPAT_FML20

	$COMPAT_FML20 = 1;

これに関係する部分は

   現在の get コマンドは resend ですが、これを昔のもの(2.0以前)に戻す。

くらいです。なお前述の $MAIL_LIST の非互換性は 2.1 gamma → 2.1 delta 
の時に導入されました。
.xref	non-compat-1-2

(HOOKは難しいですが)これ以外のものについてはできるだけ backward
compatible になるように作っていますが、変なことがあればＭＬへでもメー
ルを御一報下さい。


.S	 hml 1.6 との compatibility

   0	members や log file 等はそのままでよい

   1 	fml をインストールし

   2 	makefml か手で config.ph で
	$MAIL_LIST と $CONTROL_ADDRESS の内容を同じにする。 

これで同じになります。



.C	設計指針に関するいくつかの考察…

.S	From: はすべてを認めるべきだろうか？
.k	$REJECT_ADDR

現在は $REJECT_ADDR で定義されたアドレス群を From: に含むものはエラー
として管理者へフォワードされます。それは個人を代表しているとみなされな
いアドレスにたいしてです。というのはＭＬとは個人と個人を結び付けるもの
だと思われるからです。現在は

    $REJECT_ADDR = 'root|postmaster|MAILER-DAEMON|msgs|nobody';

のように設定されています。From:がこれらのアドレスだった場合管理者へフォ
ワードし伺いを立てます。そこから後はＭＬ管理者の判断でしょう。

この他にも uudecode や sysdiag(苦笑) のような attack で出てきそうなア
ドレスもありますが、まぁまず使ってないでしょう。果たしてこれは増やすべ
きなのか、減らすべきなのか？私見としては、もっと増やすべきではないだろ
うかと思うのですが…

正規表現でマッチした Email アドレスをはじく機能もあります。
$REJECT_ADDR_LIST 中に正規表現を定義します。デフォールトは(CF に合わせ
て) spamlist というファイルです。


.S	ML無限ループのチェックメカニズム
.k	$CHECK_MESSAGE_ID

デフォールトは $CHECK_MESSAGE_ID がセットされています。この時は
「Message-ID: フィールドはメールそれぞれについて時空全体で unique であ
る」という定義を利用したループチェックを行ないます。
.xref	$LOG_MESSAGE_ID

これ以外にもチェックはしていますが、理論上はこの uniqueness がもっとも
美しいでしょうね。


.S	newsyslog(8) について
.k	newsyslog(8)
.k	/usr/bin/newsyslog
.k	libnewsyslog.pl

/usr/bin/newsyslog に対応するものとして、libnewsyslog.pl が実装されて
います。昔の /etc/daily 等では

	…
	rename log.0 log.1
	rename log log.0
	…

とやっていたログファイルの整理を行なうプログラムです。NetBSD では、も
ともと MITの Athena Project で作られたプログラムが使われています。

fml.pl がnewsyslog を使って処理するデフォールトのファイル群は
.k	@NEWSYSLOG_FILES
.k	$NEWSYSLOG_MAX
.k	&NewSyslog

で次のファイルに定められています。

    @NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak");

つまり、まとめおくり、配送・認証リスト等の変更があった時にできるバック
アップファイルです。

また関数Call 自体(&NewSyslog)の引数(配列)は整理したいファイル群です。
変数
	$NEWSYSLOG_MAX 	

は「整理するのは何個までか？」を決めます。デフォールトは４、つまり

	log.4 log.3 ... log.0 log 

まで順番にまわって保存・整理されます。また、

	@NEWSYSLOG_FILES

は msend が日曜の朝 newsyslog をかけるファイル群を指定しています。


.S	Date: == サーバが配送した時間

オリジナルにしたい人はそうカスタマイズすればいいだけですが。

元々の理念は、サーバをどう考えるか？という観点で

1	サーバが単にリレーしてるだけ (passive?)

なのか

2	サーバまでの通信路はＯＫでした、はい。
	じゃ今からサーバ→メンバーへ配送するね(active?)

最初のデザイン当時 2 を重視したと。で、Posted: がサーバまでの配送の最
低限の pointer として残して、Date: にはサーバ→メンバー配送のための情
報としてサーバの localtime() をつけたと。そんな歴史的背景がありますね
＃まぁ当時からUUCPは除いて大抵２つはほとんど同じだったですけどね

Date: と Posted: の時間差でネットワークのDELAY情報が分かるのは副次的効
果です。

その他の副産物として時間順ソートをするだけでＭＬの記事を追うことができ
ます。つまりサーバが受けとった順ですね。
＃配送は途中のパスすべてに依存するのでメールを出したオリジナルの時間が
＃情報の順番とは限らないからです。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Received: をけずる

・出した人〜ＭＬサーバまでのパスの mail reachability は管理者のみが理
解していればよい。それ以外のメンバーは知らなくてもよい。

・Too many hops を防ぐためにけずった方がよい

という考えがあります。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Return-Receipt-To: も削るべき

配送したメンバー全員からメールが返ってくるからですね。

もちろん本来はヘッダの意味を考えてメールを書かない”そのメールを出した
人”が悪いのはいうまでもありまん。


.# $Id$
.# Copyright (C) 1993-1997 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1997 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
