.C	ＭＬサーバ Overview


サマリ:
	・日々の routine work をいかに自動処理化できるか？

	・可能な限り user および ＭＬ管理者 にとっての自由度をあげる

	・デフォールトは単に配送とユーザ用のコマンド(help や記事の取り
	  寄せ、配送先の変更/停止等)

	・しかしそれ以外の様々な機能もひととおり準備されていると便利
	  これらの高度な設定は管理者が明示的に設定しなければならない。
	  というのは管理者は何をしているのか知っているべきだし、
	  何をしているかの把握はセキュリティ的にも望ましい。


.S	歴史(なりゆき?:-)とおおまかな視点
=E.S	Brief History and Overview

fml 2.1 は Mailing List Server package(Perl Scripts package)で、
僕が壱から Full Scratch したものです。
＃おまけCDROMつき雑誌等にある「…の改良」の記述は間違った推測なのです

最初の発端は(フリーソフトの例にもれず)

	bug っているサーバ、
	機能の足りないサーバ、
	直すより自分で書いた方が早い

単にそういう話でした(ま、よくある話ですね:-)。

歴史的に hml 1.6 を一時期使っていて、その設定ファイルをコンバートする
のは面倒でした。そのため デフォールトの emulation は hml 1.6 を 
support しています(「なりゆき」ともいいますね)。

また、Mailing List == Private Communication を便利にするツール（Filter） 
という観点を重視しているため、デフォールトでは メンバーチェック をする
という考え方を尊重しています。

その辺は設定ファイル(config.ph)でいくらでも変えられるので、まぁ拘る必
要はないのですが、設計思想を知っていると設定のデフォールトがどうなって
いるかを推測するに役立つでしょう。

結局のところ、日々の routine work をいかに自動処理化できるか？が重要な
ので、ユーザにみえるインターフェイスはどうでもいいわけです。

ＭＬサーバというものは一番肝心な部分はかなり簡単なのですが、実際にはそ
れ以外のさまざまな例外処理が発生します。それをいかに封じ込めるかをノウ
ハウというわけですが…また、環境による違いを吸収するためにさまざまな関
数をサポートする必要がありました。例えば ish, lha サポート

これらを踏まえての基本的方針は

   『可能な限り user および ＭＬ管理者 にとっての自由度をあげる』

としています。またそれらの Configuration を簡単に設定できるようにする
べきです。そして、

    『必要なことはしても、できるだけ何もしない』
    『機能の増加は簡単な configuration で、しかし明示的に指定しない限り
      よきにはからって動くべきではない』

そのことは、これからＭＬをはじめる方にはそのままＭＬサーバをカスタマイ
ズして使いたいとおもっている方には改造の PLATFORM として利用してもらう
ことを想定しています。

多くの変数があるのは、簡単に例えばある変数の値を変えるだけで挙動が変え
られるようにするためで、変数についてはこのドキュメントに述べられていま
す。また変数設定方式であれば簡易インターフェイスを割と簡単に書くことが
できます。例えば makefml です。これはインストールや簡単な設定の変更が
可能です。ある程度以上複雑なことは手でやって下さい。
また頑張ればWWWインターフェイスもすぐ書けるでしょう。


このドキュメントは簡単なカスタマイズ以上のことをするための関数の説明や
設計思想についても議論しています。


各種機能はそれぞれの目的に応じて選んでみて下さい。例えば『あるＭＬのロー
カルな再配送』のような場合はコマンド機能を落して使うべきでしょう。

例：

ip-connection を受けるアドレス (include ファイルを呼び出すアドレス)に
使う時は、makefml config listname で 配送モード指定を「誰でもPOST可能」
にする。

	$PERMIT_POST_FROM = "anyone";


.S	fml 2.1 Overview

ML server, management tool, .forward 等メールを使う各種インターフェイスの
集合体です。

特別な場合には(歴史的理由により)デフォールトでは hml 1.6 (正確にはその
元祖の shell script) というサーバを Emulate します。なお特別な場合とは 
配送用のアドレス==コマンド用のアドレスの時つまり 

	$MAIL_LIST == $CONTROL_ADDRESS
.xref $MAIL_LIST, $CONTROL_ADDRESS

現在の代表的な機能は以下のようなものです。

   ○ 配送用のアドレスとコマンド用のアドレス
	それぞれについてアクセス制御や自動登録の設定
	なお特別な場合「配送用のアドレス==コマンド用のアドレス」は hml 1.6

   ○ 様々な自動登録方式
	前述のどのアドレスで？ x 4種類 x 各カスタマイズ変数…

   ○ リモートメインテナンス/リモート管理
	PGP, パスワード認証等の選択

   ○ 様々なヘッダカスタマイズ

   ○ 様々なコマンド、コマンドのカスタマイズ
	mget コマンドのいろいろなファイル形式のサポート

   ○ まとめおくり

   ○ SMTP配送方式(リレー)

   ○ その他(MIME処理等)

   ○ スプール
	HTML自動化処理(thread化)、アーカイブ、Expire等

   ○ 複数のインターフェイス (listserv や majordomo style)
	みかけがあたかも listserv のように fml のコマンド群を使う

必要に応じて設定ファイルで機能の追加・削減を行うことができます。
簡単なものは makefml で可能です。


.S	インストール

とりあえず細かいチューニングを行なわなくてよいなら
=E
The simplest way to install Fml system is to do in the top directory
of the fml source
# Hence a lot of variables are pre-defined.

	perl makefml 

=E
when you make a new ML 
=S
	perl makefml newml ML-Name
=S
e.g. to make elena@your-domain mailng list
=S
	perl makefml newml elena

ことで、インストールをします。ML の作成は

	perl makefml newml ＭＬの名前

で何個でも作れます。説明は INSTALL というファイルを見て下さい。
=E
Please see the file INSTALL for the detail.


.S	FML 1.x との互換性
.l	non-compat-1-2

FML 2.1 で互換性のないのはデフォールトでのアドレスの振舞いです。異なる
配送用のアドレス(elena)とコマンド用のアドレス(elena-ctl)がある時に

[FML 2.1]
	elena		配送専用
	elena-ctl	コマンドだけ

になります。2.1 リリース以前(2.1 Gamma series)では 

	elena		配送もコマンドも処理する
	elena-ctl	コマンドだけ

のように振舞いました。elena でのコマンドの「配送とコマンドの切り分け」
はメール本文が"# command"であるか？否か？で決めています。

2.1 でも配送用とコマンド用のアドレスが同じ場合は

	elena		配送もコマンドも処理する

になります。この場合「コマンドなのか？否か？はメール本文が"# command"
であるか？否か？」で決まります。これがもともとの hml 1.6 互換のスタイ
ルです。

FML 1.x を使っていて FML 2.x に入れ換える場合、基本的にはperl script 
群だけを入れ換えれば動きます。ほとんどすべての差異はFML内部で自動補正
を行ない吸収できます。

しかし config.ph でちょっと複雑な HOOK を書けている場合はちょっと注意
がいるでしょう。というのはHOOKで使う関数や変数等が今でもサポートされて
いるとは限らないからです。


.S	 hml 1.6 との compatibility

   0	members や log file 等はそのままでよい

   1 	fml をインストールし

   2 	makefml か手で config.ph で
	$MAIL_LIST と $CONTROL_ADDRESS の内容を同じにする。 

これで同じになります。


.C	fml の機能についての概要
=E.C	Brief Overview of functions

注意: インストールやＭＬの作成の仕方についての詳細は INSTALL というファ
イルを読んで下さい。

.S	Directoryの使い方

基本的に directory は2箇所からなります。
インストール時に makefml で指定できます。

	１ /usr/local/fml の下に必要な実行ファイルとライブラリ群
	２ 各ＭＬ群が /var/spool/mailing-lists/ に作られる

	   /var/spool/mailing-lists/elena/	(elena ML)
	   /var/spool/mailing-lists/mirei/	(mirei ML)
	   ...

elena ML 関係の全てのファイルは /var/spool/mailing-lists/elena/ 以下に
作られます。設定ファイル(config.ph) や記事のスプールも同様です。
複数のＭＬを作成すると /var/spool/mailing-lists/ 以下に並びます。


.S	インストーラ 〜 高度/複雑な設定

対話的処理をする makefml という簡単なインターフェイスがついてきます。
これがインストールやＭＬの作成簡単な設定の変更を可能にしています。

初心者には、最初は何をやっているか良くわからないものです。とりあえず簡
単なものはこれでできるはずです。詳細については INSTALL というファイル
を見て下さい。より高度な設定についてはこの文書/パッケージ中の doc/op
『FML 2.1 の設計と実装)』を読んで下さい。

代表的な『ある動作をするか？否か？』についてはすべて設定ファイルで操作
することができます。アーカイブやスプール、help ファイルの場所 や『tar
ish lha のような system のコマンド』のようなものもすべて hard coding 
ではなく user が外部から制御できる変数として定義されています。
変数リストについて興味があれば cf/MANIFEST を見るとわかります。


.S	たくさんのドキュメント(複数のフォーマットで)

PLAINTEXT 版はパッケージ中の doc/ にあらかじめ用意されています。README
や INSTALLマニュアル の HTML 版も ぱっけーじ/doc/html/ の下に用意され
ています。doc/op のHTML 版は巨大なのでパッケージにはついていません。
必要なら

	shell% make doc 

でつくって下さい。ドキュメントの最新版は
.url	http://www.sapporo.iij.ad.jp/staff/fukachan/fml/
.url	http://www.fml.org/fml/
にあります。


.S	一般ユーザー権限ということ

一般ユーザーできればＭＬ用の特別なユーザーでFMLを動かすのが望ましいで
す。通常このユーザーは makefml で作られる include というファイルの所有
者です。

特別なユーザー 例えば daemon 等で動かすのはセキュリティ上好ましくあり
ません。また FML は実装上 Trusted User 等を気にする必要はないので 
daemon で動かす必要もありません。

ＭＬサーバのメカニズムとしてはユーザー権限で動かすために setuid() を行
なった後 fml.pl へ渡します。POSIX 準拠 OSは setuid() をちゃんと行なえ
る user は root に限られます。これはこれで正しい選択だし、ターゲットの 
4.4BSD もそういう実装をとっています。そのため setuid() はできるだけ 
sendmail 等の SMTP を受けるプログラムを信頼します(includeファイルの扱
い等のこと)。

sendmail 等がうまく setuid() を実行できない場合 4.3 BSD では fml.c を 
compile して使えば良いでしょう。makefml でインストールしていれば 
makefml が作った Makefile を使うと

	shell prompt% make fml

で fml が生成され、setuid されます。4.3BSD ではこれで十分です。

POSIX 準拠等OSでは ＊非常に危ないですが＊ この fml を root 権限に 
setuid しなければなりません。fml.c のコードと fml をどこにおいて使うべ
きか？について自信がない場合あなたのサイトもしくはそのマシンの管理者に
よく相談して下さい。



.S	ライブラリ・モジュールとダイナミック・ローディング


モジュールにすることにより

	マスターコードの保守
	自分だけのモジュールを独立に保守

することが容易になります。

もともとは SMTP部分の独立保守と 常時使うわけではないコマンド部分を切り
離すことを目的としたモジュール化でしたが、現在では必要に応じて dynamic
loading するさまざまなライブラリが提供されています。
ファイルは一杯ありますが、常に使われるのは2、3個くらいで後は必要がある
場合のみ使われます。

モジュールはインターフェイス仕様さえ不変なら独立に保守できます。
contribution され独立に保守されているコードも同様にライブラリに入って
います。例えば libtraffic.pl は

	libfml.pl の関数呼びだしインターフェイスに合わせれば、後は
	すべて user defined で作れる

というよい例です。
＃ぼくは中身についてタッチしていません。fml master code tree とは独立
＃に保守されています（感謝）


FML はこのライブラリ群が本体で、その動きを設定ファイル(config.ph)でカ
スタマイズするようになっています。そのためライブラリ・モジュールは一箇
所にまとめておくと『ひとつのfmlで複数のＭＬを扱うように拡張』等も容易
になり、また version up も楽です。makefml でインストールする場合はそう
いう形態になります。

例:
	ライブラリは /usr/local/fml の下に全部入れる
	ＭＬ群は /var/spool/mailing-lists/each-ml/
	   (e.g. /var/spool/mailing-lists/each-ml/config.ph )


ＭＬを配送ではなく特定の目的のサーバのみを dynamic loading して
『特定の目的のサーバ』にすることも簡単にできます。
＃config.ph で特定のファイル名を $LOAD_LIBRARY に設定する

これにより、

	コマンド 専用サーバ
	ftp 用サーバ
	ftpmail  専用サーバ 
	メールで request をうけてURLの中身を返すサーバ

等の専用サーバに設定することもできます。	

.include files.wix


.S	設定ファイル(config.ph)


できるだけソースコードを直接いじらなくてもたくさんの制御変数とフックで
カスタマイズできるようになっています。カスタマイズ可能な変数は 
config.ph 中に簡単な説明とともに書いてあるのでこれを変更することで行な
います。基本的なものについては makefml で変更ができます。



.S	アクセス制御と自動登録


前述のとおりデフォールトは来たメールの From: を見て、メンバーチェック
をします。FML 2.1 では投稿とコマンドそれぞれについて以下の

	・誰からの投稿を許すか？
		だれでもOK			anyone
		登録されているメンバーだけ	members_only
		モデレーターだけ		moderator

	・もし、登録されているメンバー以外から来た場合にはどうするか？
		許否				reject
		自動登録			auto_regist
		無視(管理者へ報告だけする)	ignore

を設定できます。デフォールトはいずれも

	メンバーのみ(members_only) 投稿/コマンドの使用 が可能
	もしメンバー以外から来たら許否(reject)

です。自動登録は"投稿がメンバーだけ"(members_only)の場合に

	もしメンバー以外から来たら自動登録 → auto_regist へ変更

することで行ないます。自動登録のタイプは4種類あります。
.xref	autoregist


.S	ファイル操作: 取り寄せとまとめ送り


get, mget, matome 等のコマンドにはオプションで tar.gz で固めてとか 
MIME/Multipart 形で記事をまとめて送り返して欲しい 等の変更ができます。
.xref	mget, msend

mget と まとめおくりでの User interface は次のようなものが取り揃えられ
ています。mget コマンド毎に指定を変えることができます。


	PLAINTEST 
		UNIX FROM
		RFC934	
		RFC1153
		MIME/Multipart

	COMPRESSED FILE
		gzip UNIX FROM file
		Lha + Ish 	（自動ＳＪＩＳ変換可）
		Lha + uuencode 	（自動ＳＪＩＳ変換可）
		tar + gzip
		uuencode

mget で取り寄せられるのはデフォールトは $SPOOL_DIR (default "spool") 
ですが対象は標準のＭＬの記事スプール以外にも @ARCHIVE_DIR に指定するこ
とで増やすことができます。

ファイル操作の応用編としてユーザーが put も get できるように拡張された
コマンドも実装しています（library コマンド）。
.xref library

ただしデフォールトでは、put するファイル名は security 上選べません。ファ
イル名を明示的に指定する場合は安全のため管理者が変更するべきです。

配送用のアドレスとコマンド用のアドレスが同じ場合($MAIL_LIST と 
$CONTROL_ADDRESS が同じ場合)記事とコマンドを見わける必要があります。こ
れは最初の3行のどこかに "# command（英文字Only）" シンタックスを見つけ
た場合にコマンドとして認識することで区別しています。

しかしこれ以外の場合↑は # でモードを切替える必要はありません。当然、
Listserv 形式のシンタックスをうけつけるように拡張されたインターフェイ
ス(libexec/fmlserv.pl)を使う場合には、どっちでもいいわけです。


.S	 MIME や base64 等の処理 
.xref	MIME, href

基本的にすどおしですが、MIME 処理は下請けにだして、Subject を decode 
してサマリーを作る等が可能です。またHTMLでは base64 の画像等の変換処理
を下請けのプログラムに渡して行ないます。つまりメール中の gif ファイル
を変換してメールの記事の html を生成します。


.S	リモートでＭＬを管理すること
.xref	remote pgp

デフォールトではできません。設定ファイルで

	$REMOTE_ADMINISTRATION  = 1;

を設定するとできるようになります(makefmlでも設定できます)。
管理者として登録された人に対し

	From: 行での認証
	管理者一人ごとのパスワード	(秘密鍵暗合)
	PGPベースでの認証		(公開鍵暗合)

の組合せで認証をします。デフォールトは

	From: 行での認証
	管理者一人ごとのパスワード	(秘密鍵暗合)

です。どうせやるなら PGPベースが推奨です:)
.xref	pgp

FML 1.0 で『管理者が本当に操作しているかどうか?という点に関して保証で
きない』という理由ではずしたリモート管理(アドミンコマンド)を再実装し、
サポートします。保証できないという意味は From: での認証は簡単に偽造で
きるからです。

そのため普通パスワードも併用します。このパスワードは 各管理者ごとに設
定できます。管理者全体で一つの共通パスワードというようなださい実装はし
ません。これは普通の UNIX の パスワードシステム のミニチュア版です。サー
バ側では etc/passwd に 管理者ごとにパスワードを保存しています。 保証の
度合が上がったわけではありませんが、パスワードは crypt し保存していま
す。一応かつての UNIX 程度の保証はされます。
パスワードの保存を MD5 にすることもできます。

しかしながら、メールの中では平文パスワードを書く必要がありますし、ひと
りの管理者のパスワードは毎回同じで使い捨てではありません(時系列に沿っ
て)。よって、間違ってメールが読まれた場合を考えると危険なわけです。


PGPベースではこの心配はありません(もちろんあるメール全体を読まれていれ
ばそのメールと全く同じ内容を実行だけは可能なはずですが)。
.xref	pgp


.S	.forward
.xref	.forward

通常 include ファイルを設定するのは /etc/aliases ですが .forward は本
質的に同じものです。もっとも .  forward の場合ユーザー名以外のものを使
うことはできないわけですが。だから include は .forward に設定すれば同
じです。詳細は
.xref	.forward


.S	Listserv/Majordomo
.xref	fmlserv

   Listserv 互換用インターフェイス 	libexec/fmlserv.pl

fmlserv.pl を呼ぶようにした場合 コマンドは

	コマンド ＭＬ名前 オプション

になります。ようは Listserv 形式のしんたっくすで fml のコマンドを使え
るようにしたインターフェイスです。

	listserv:  fmlserv
	majordomo: fmlserv
	fmlserv: :include:/var/spool/ml/include/fmlserv

のようにしても大丈夫です。


.S	MTAとの通信 (e.g. sendmail)

デフォールトでは fml は sendmail 等の SMTP配信エージェントと自力で通信
します。

	$Envelope{'mci:mailer'} = 'ipc'; 

がデフォールトですが、

	$Envelope{'mci:mailer'} = 'prog';

とすることで $SENDMAIL という変数のプログラムを起動してそれに配送をさ
せることもできます。

	$Envelope{'mci:mailer'} = 'ipc'; 

の場合 $HOST で指定されているマシンに配送をまかせます。デフォールトは
自分のマシンで走っている sendmail と通信しようとしますが、

SMTP を理解してくれるなら sendmail である必要もないし配送用に使える
SMTPサーバ があれば動きます。それは必ずしも自分のマシンで sendmail が
走っている必要はありません。各サイトで走っているSMTPを理解してくれる配
送プログラムがあればよいです。

sendmail が走っているマシンが一つもなければ、sendmail を 'prog' で起動
するように 'prog' を指定すればよいです。


.S	メール → ＭＬサーバ

逆にどうやってメールを受けとるかという問題があります。通常 SMTP を理解
する受けとるサーバが走っていて、メールを受けとり fml.pl へ渡します。

例えば一定時間間隔で POP をかけてＭＬを動かし、配送はサイトの SMTP サー
バにやらせることでＭＬを実行するこは可能です。
.xref	popfml


.S	その他の機能

ロックは flock によるロック処理をデフォールトにしています。が flock() 
が動かない場合 UNIX V7 以来の link() によるロックを使います。

% hack によるリレーサーバを処理します。例えば、関東方面、関西方面にこ
ねがあって、マシンが調達できる場合、関東方面のメールを一回そのマシンに
送ることで関東方面へおくるメールを一つのメールでいっきにおくって、配送
はそのリレー先にまかすことで、配送を高速化できます。

プロバイダ等でDISKに制限があったりする場合は、古い記事は消したいとおも
いますが、そのための Expire 機能をサポートします。

また、同様に newsyslog をサポートし、古いログは自動的に
	e.g. log -> var/log/log.0 
のように変換し保存するようにしています。デフォールトでは members file 
や まとめおくりのログに対して newsyslog を実行しています。

一つのマシン上にある ＭＬ間のクロスポスト の場合、
複数のＭＬに入っている人には一通しか送らないようにします。
＃サイトにまたがる場合はデータのシンクロが必要なため実験段階です

おまけ機能として、スタートレックの宇宙歴をサポート（笑）します。
contrib/Utilities に宇宙歴をつけるmh, mh-e user interface つき:-)です。
.xref	startrek x-stardate


.C	Version up と Compatibility 

.S	version up
.xref	version-up

makefml を使ってインストールしてもらのが確実です。
makefml の使い方については INSTALL マニュアルを見て下さい。


.S	新しい機能を有効にするには？

なお、新しい機能は config.ph へ差分だけを付け加えるか コマンドラインで
指定するかしないと使えません。
つまり、新しい機能・オプションは明示的に指定しない限り単に動きません


.S	Backward Compatibility 

『$MAIL_LIST と $CONTROL_ADDRESS が違う場合の $MAIL_LIST の挙動』が従
来と異なり『配送専用』です。
.xref	non-compat-1-2

それ以外のものについては可能な限り backward compatible に作られていま
す。


.S	CF VERSION による Backward Compatibility 
.k	$CFVersion
.k	$COMPAT_CF1 

fml 2.1 の標準の config.ph は $CFVersion = 2; です。これは cf/config 
を使って生成されるものです。これ以前の config.ph を使っている場合は

	$COMPAT_CF1 = 1;

がセットされているか $CFVersion が２より小さい場合は自動的に

	libcompat_cf1.pl
.k	libcompat_cf1.pl

が dynamic loading されます。


.S	1.6より前からの移行について

1.6では、基本的なデータ構造を call by reference 用に書き直したので、
いままでの SMTP_OPEN_HOOK 等の カスタマイズはそのままでは反映されません。
libcompat.pl にBackward compatibility のためのコードがあります。
昔の設定を変えたくないなら、config.ph に 

	$COMPAT_FML15 = 1; 
.k	$COMPAT_FML15

と書くと複雑なフックをしかけていない限り compatible にできます。
コードの都合上どうしても実現できないカスタマイズもありえます_o_

昔できたことは今の実装でも必ずできるのでこのドキュメントを参照してみて
下さい。


.S	2.0 〜 2.1 の間の compatible
.k	$COMPAT_FML20

	$COMPAT_FML20 = 1;

これに関係する部分は

   現在の get コマンドは resend ですが、これを昔のもの(2.0以前)に戻す。

くらいです。なお前述の $MAIL_LIST の非互換性は 2.1 gamma → 2.1 delta 
の時に導入されました。
.xref	non-compat-1-2

(HOOKは難しいですが)これ以外のものについてはできるだけ backward
compatible になるように作っていますが、変なことがあればＭＬへでもメー
ルを御一報下さい。



.C	設計指針に関するいくつかの考察…

.S	From: はすべてを認めるべきだろうか？
.k	$REJECT_ADDR

現在は $REJECT_ADDR で定義されたアドレス群を From: に含むものはエラー
として管理者へフォワードされます。それは個人を代表しているとみなされな
いアドレスにたいしてです。というのはＭＬとは個人と個人を結び付けるもの
だと思われるからです。現在は

    $REJECT_ADDR = 'root|postmaster|MAILER-DAEMON|msgs|nobody';

のように設定されています。From:がこれらのアドレスだった場合管理者へフォ
ワードし伺いを立てます。そこから後はＭＬ管理者の判断でしょう。

この他にも uudecode や sysdiag(苦笑) のような attack で出てきそうなア
ドレスもありますが、まぁまず使ってないでしょう。果たしてこれは増やすべ
きなのか、減らすべきなのか？私見としては、もっと増やすべきではないだろ
うかと思うのですが…

正規表現でマッチした Email アドレスをはじく機能もあります。
$REJECT_ADDR_LIST 中に正規表現を定義します。デフォールトは(CF に合わせ
て) spamlist というファイルです。


.S	ML無限ループのチェックメカニズム
.k	$CHECK_MESSAGE_ID

デフォールトは $CHECK_MESSAGE_ID がセットされています。この時は
「Message-ID: フィールドはメールそれぞれについて時空全体で unique であ
る」という定義を利用したループチェックを行ないます。
.xref	$LOG_MESSAGE_ID

これ以外にもチェックはしていますが、理論上はこの uniqueness がもっとも
美しいでしょうね。


.S	newsyslog(8) について
.k	newsyslog(8)
.k	/usr/bin/newsyslog
.k	libnewsyslog.pl

/usr/bin/newsyslog に対応するものとして、libnewsyslog.pl が実装されて
います。昔の /etc/daily 等では

	…
	rename log.0 log.1
	rename log log.0
	…

とやっていたログファイルの整理を行なうプログラムです。NetBSD では、も
ともと MITの Athena Project で作られたプログラムが使われています。

fml.pl がnewsyslog を使って処理するデフォールトのファイル群は
.k	@NEWSYSLOG_FILES
.k	$NEWSYSLOG_MAX
.k	&NewSyslog

で次のファイルに定められています。

    @NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak");

つまり、まとめおくり、配送・認証リスト等の変更があった時にできるバック
アップファイルです。

また関数Call 自体(&NewSyslog)の引数(配列)は整理したいファイル群です。
変数
	$NEWSYSLOG_MAX 	

は「整理するのは何個までか？」を決めます。デフォールトは４、つまり

	log.4 log.3 ... log.0 log 

まで順番にまわって保存・整理されます。また、

	@NEWSYSLOG_FILES

は msend が日曜の朝 newsyslog をかけるファイル群を指定しています。


.S	Date: == サーバが配送した時間

オリジナルにしたい人はそうカスタマイズすればいいだけですが。

元々の理念は、サーバをどう考えるか？という観点で

1	サーバが単にリレーしてるだけ (passive?)

なのか

2	サーバまでの通信路はＯＫでした、はい。
	じゃ今からサーバ→メンバーへ配送するね(active?)

最初のデザイン当時 2 を重視したと。で、Posted: がサーバまでの配送の最
低限の pointer として残して、Date: にはサーバ→メンバー配送のための情
報としてサーバの localtime() をつけたと。そんな歴史的背景がありますね
＃まぁ当時からUUCPは除いて大抵２つはほとんど同じだったですけどね

Date: と Posted: の時間差でネットワークのDELAY情報が分かるのは副次的効
果です。

その他の副産物として時間順ソートをするだけでＭＬの記事を追うことができ
ます。つまりサーバが受けとった順ですね。
＃配送は途中のパスすべてに依存するのでメールを出したオリジナルの時間が
＃情報の順番とは限らないからです。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Received: をけずる

・出した人〜ＭＬサーバまでのパスの mail reachability は管理者のみが理
解していればよい。それ以外のメンバーは知らなくてもよい。

・Too many hops を防ぐためにけずった方がよい

という考えがあります。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Return-Receipt-To: も削るべき

配送したメンバー全員からメールが返ってくるからですね。

もちろん本来はヘッダの意味を考えてメールを書かない”そのメールを出した
人”が悪いのはいうまでもありまん。


.C	用語

以下で使う用語について2、3説明しておきます。

.S	MLのHOME
.k	MLのHOME

ML(fml) の HOME は config.ph のある場所です。例えば config.ph が 
/var/spool/ml/elena/config.ph にあるとすると、directory
/var/spool/ml/elena をMLのHOMEと呼んでいます。


.S	SMTP
.k	SMTP
.k	Simple Mail Transfer Protocol

SMTP == Simple Mail Transfer Protocol。 sendmail 間の通信方式のこと。


.S	メールサーバ/SMTPサーバ, MTA

sendmail というプログラムが元祖であり、もっとも代表的なプログラムです
が、SMTPを理解すればうけるのは何でも構いません。より正確には $HOST で
指定する(デフォールトは自分自身 "localhost")で smtp/tcp ポートがメール
を受けとってくれれば何が走っていて構わないという意味です。

MTAなら qmail (http://www.qmail.org/) のような他のMTAもあるし、MTAでは
なく例えば TIS (Trusted Information System) の Gauntlet という 
Firewall では smap というプログラムが受けて queue だけをします。

世の中にはそれ以外にも sendmail もどきのプログラムはありますから、
sendmail に拘る必要はありません。

この文書ではターゲットマシンが 4.4BSD なので、sendmail と perl を使う
場合について解説しています。


.S	sendmail
.k	/usr/sbin/sendmail
.k	sendmail

現在も Eric Allman がメンテしている メール配送エージェントのこと。
sendmail は BSD の標準装備です。

どんな複雑な環境でも適応できる柔軟性を兼ね備えている分、security hole 
もありえます。bug つぶしのupdateは非常にはやいです。そのため常に最新版
を使うようにして下さい。
例えば

	ftp://ftp.cert.org/pub/tools/sendmail/
	ftp://ftp.sendmail.org/

国内のミラーは例えば

	ftp://ftp.iij.ad.jp/pub/network/sendmail/

です。


.S	sendmail.cf 
.k	/etc/sendmail.cf 
.k	sendmail.cf 

sendmail をコントロールする configration file。これの読み書きができな
いとネットワーク管理者にはなれません(なりたくないって?(泣))。

大抵の場合 motonori さん(motonori@wide.ad.jp) のメンテしている CF パッ
ケージで sendmail.cf を簡単に作ることができるが、この見本で十分実用で
す。

詳しくは、このCFパッケージの日本語マニュアルも参照して下さい。

国内のミラーは例えば

	ftp://ftp.iij.ad.jp/pub/network/sendmail/


.S	newaliases
.k	/usr/sbin/newaliases
.k	newaliases

/etc/aliases から aliases データベースを作るための操作のこと。
/etc/aliases をいじったら必ず newaliases というコマンドを実行しなけれ
ばなりません。


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
