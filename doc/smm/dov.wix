.C	ＭＬサーバ Overview

.S	Brief Hisotry and Overview

最初の発端は例によって

	bug っているサーバ、
	機能の足りないサーバ、
	直すより自分で書いた方が早い

単にそういう話でした(ま、よくある話ですね)。

歴史的に hml 1.6 を一時期使っていて、その設定ファイルをコンバートする
のは面倒でした。そのため デフォールトの emulation は hml 1.6 を 
support しています(「なりゆき」ともいいますね)。

また、Mailing List == Private Communication を便利にするツール（Filter） 
という観点を重視しているため、デフォールトでは メンバーチェック をする
という考え方を尊重しています。

その辺は設定(config file or command line option)でいくらでも変えられる
ので拘る必要はないのですが、設計思想をしっていると設定のデフォールトが
どうなっているかを推測するに役立つでしょう。


結局のところ、日々の routine work をいかに自動処理化できるか？が重要な
ので、ユーザにみえるインターフェイスはどうでもいいわけです。

デフォールトが hml 1.6 ですが、単なる distributer (配送プログラム)にす
ることもコマンドだけを実行するようにすることも、BITNET伝統の味(謎)の 
listserv のようにユーザには見えるように動かすこともできます。


ＭＬサーバというものは一番肝心な部分はかなり簡単なのですが、実際にはそ
れ以外のさまざまな例外処理が発生します。それをいかに封じ込めるかをノウ
ハウというわけですが…また、環境による違いを吸収するためにさまざまな関
数をサポートする必要がありました。例えば ish, lha サポート

これらを踏まえて基本的方針は

   『可能な限り user および ＭＬ管理者 にとっての自由度をあげる』

としています。またそれらの Configuration を簡単に設定できるようにする
べきです。そして、

    『必要なことはしても、できるだけ何もしない』
    『機能の増加は簡単な configuration で、しかし明示的に指定しない限り
      よきにはからって動くべきではない』

そのことは、これからＭＬをはじめる方にはそのまま、 ＭＬサーバをカスタ
マイズして使いたいとおもっている方には改造の PLATFORM として利用しても
らうことを想定しています。

多くの変数があるのは、簡単に例えばある変数の値を変えるだけで挙動が変え
られるようにするためで、変数についてはこのドキュメントに述べられていま
す。

またこのドキュメントはそれ以上のことをするための、関数の説明、設計思想 
について議論するためのものでもあります。


各種機能はそれぞれの目的に応じて選んでみて下さい。例えば『あるＭＬのロー
カルな再配送』のような場合はコマンド機能を落して使うべきでしょう。
例：
   ip-connection を受けるアドレスに使う時は --distribute モードで使う


.S	fml 2.1 Overview

fml 2.1 は Mailing List Server package(Perl Scripts package)で、
僕が壱から Full Scratch したものです。
＃おまけCDROMつき雑誌等にある「…の改良」の記述は間違った推測なのです

ML server, management tool, .forward 等メールを使う各種インターフェイスの
集合体です。

これは（歴史的理由により）デフォールトでは hml 1.6 という Perl Script 
を Emulationします。
＃正確にはその元祖の shell script の program というべきであらう

subset として ユーザにとってもＭＬ管理者にとっても使い勝手が同じになる
ように作動させることができます。

デフォールトの挙動はそうですが、さまざまな動作を実行できます

	○コマンド機能等を一切使わずにフォワードするだけ等
	   配送だけして「spoolingするaliasesと同じ」
	○hml のシンタックスで使う （Default Emulation）
	○listserv or majordomo インターフェイス
	   みかけがあたかも listserv のように fml のコマンド群を使う
	○forward でのMLのための仕組み(slocal や vacation)
	   .forward に仕掛けて slocal や
	   .forward から fml の機能を使うことで自分のaccountでMLを実行
	○まとめおくり等の配送の仕方の制御
	   メールをリアルタイムに配送したり、
	   一定時間ごとにためてまとめておくる

等はすぐに実行できます。例えばリモートでＭＬを管理や HTML へ変換してス
プールするとか expire をかける等さまざまな機能はモジュールとして配布パッ
ケージに１セットになっています。

必要に応じて、コマンドラインオプション か Configuration file で機能の
追加・削減を行うことができます。

ようは、インターフェイスだけを変えて、ユーザにとってどう見えるか？とい
う部分を用意すればよいので、様々なコマンド、ライブラリ群を好きなインター
フェイスで使えるということです。


.S	インストール

とりあえず非常に細かいチューニングを行なわなくてよいなら

	○対話的プログラムで行なう 
	○コマンドラインで引数を２つほど指定して make する

ことで、ＭＬの設定は終ります。その時、自動的に環境に合わせた各種見本設
定も自動生成しますので、それを cut and paste すればインストールは終り
です。

詳しくは INSTALL というファイルを見て下さい。


.S	fml 1.x とのCompatibility

fml 1.x を使っていて fml 2.x に入れ換える場合
   そのまま perl script 群だけを入れ換えれば動きます。
   config.ph で複雑な HOOK を書けている場合は
   ちょっと注意がいるかもしれません。
   ＃詳しくは doc/op 参照

.S	 hml 1.6 との compatibility

members や log file等をそのままに、*pl 群と config.phを差し替えればい
きなり動きます。


.C	Brief Overview of functions [fml の機能についてのサマリ]

以下、代表的な機能一覧について見る

.S	基本機能

	fml 2.1 が hml 1.6 と同様に目指したものは
	(以下 hml 1.6 README.jpn より)

	＊ 大規模なメーリング・リストでの使用に耐えます。
	＊ 豊富なコマンドを持っています。
	   ヘルプ、過去の記事の一覧、入手、一時的な離脱／再開など。
	＊ メンバのアドレスのチェックをしていますので、非メンバからの不法な
	   アクセスを防止することが可能です。
	＊ perl で書いてあるので改造が容易です。


.S	簡単なインストーラーから複雑な設定まで


初心者には、簡単なインストーラーによるお手軽インストールでよいとおもい
ます。最初は何をやっているか良くわからないものです。

しかし、必要なら複雑な設定まで（コードを直接いじることなく）できるべき
だとおもいます。

そうでないとソフトの複数のプラットホームでの作動が保証できないというの
ことでもあります。

そこで、代表的な『ある動作をするか？否か？』についてはすべて config
file もしくはコマンドラインオプションで ON OFF することができます。

そして、アーカイブやスプール、help ファイルの場所 や
『tar ish lha のような system のコマンド』
のようなものもすべて hard coding ではなく user が外部から制御できる変数
として定義されています。
＃変数リストは cf/MANIFEST を見て下さい。


.S	たくさんのドキュメント（複数のフォーマットで）

PLAINTEXT版はあらかじめ用意されています。

HTML 版は var/html/ の下に用意されいますが、
operation manual (旧FAQ) は巨大なのでこれの HTML 版は
shell% make doc でつくってください
最新版は
   http://www.iij.ad.jp/sapporo/staff/fukachan/fml/
をのぞいてみてください


.S	user 権限で実行

daemon とかで動かすのはなく user 権限で動かすために setuid() 
を行なった後 fml.pl へ渡します。

fml は実装上 Trusted User 等を気にする必要はありませんから daemon で動
かす必要はありません。

POSIX 準拠 OSは setuid() をちゃんと行なえる user はroot に限られます。
これは、これで正しい選択ですし、ターゲットの 4.4BSD もそういう実装をとっ
ています。そのため setuid() はできるだけ sendmail 等の SMTP をうけるプ
ログラムを信頼します。

sendmail 等がうまく setuid() を実行できない場合、 4.3 BSD では fml.c 
を compile して使えば良いでしょう。

fml.c を user 環境にあわせて compile するには直接 edit してもよいです
が、make すれば自動的に環境に合わせて fml という wrapper program を生
成します。これはすでに setuid() されています。

POSIX 準拠等では ＊非常に危ないですが＊ この fml を root 権限に setuid 
しなければなりません。fml.c のcode と fml をどこにおいて使うべきか？に
ついて自信がない場合あなたのサイト or マシンの管理者に相談するとよいで
しょう。



.S	モジュール化 


モジュール化にすることにより、 メンテもしやすいですが、自分だけのモジュー
ルを独立にメンテすることも容易になります。

もともとSMTP部分の独立保守と 常時使うわけではないコマンド部分を切り離
すことを目的としたモジュール化でしたが、現在では必要に応じて dynamic
loading するさまざまなライブラリをデフォールトで提供しています。

また、libtraffic.pl のように contribution されたコードも同様に配布して
います。libtraffic.pl は 

	libfml.pl の関数呼びだしインターフェイスに合わせれば、後は
	すべて user defined で作れる

というよい例です。
＃ぼくは中身についてタッチしていません。fml master code tree とは独立
＃に保守されています（感謝）

module はＭＬに configuration file と別の場所におくとよいでしょう。そ
うすることで、『ひとつのfmlで複数のＭＬを扱うように拡張』が容易になり
ますし、version up も楽です。


ＭＬを配送ではなく特定の目的のサーバのみを dynamic loading して
『特定の目的のサーバ』にすることも簡単にできます。
＃ $LOAD_LIBRARY に設定するだけ

これにより、
	コマンド 専用サーバ
	ftp 用サーバ
	ftpmail  専用サーバ 
	メールで request をうけてURLの中身を返すサーバ

等をカスタマイズできます。	

whois や ftpmail はライブラリモジュールとして提供されています。	

その他にもさまざまな改造事例集(contrib/)がついています
例： 	投票サーバ例
	WWW-MAIL(Mail で WWW Server とのリレーをし返送)
	Whois（ローカルキャッシュと本物の whois の両方）


.include files.wix


.S	容易なカスタマイズとその保守

各種変数は user が define できます。また Lisp のように多くのフックが用
意されています。
そのため、ソースコードを直接いじらなくてもたくさんの制御変数とフックで
カスタマイズできます。

また、それで不十分な場合モジュール化されているため、自分のモジュールを
書いて置き換え、それだけをメンテナンスすればよいことになります。

カスタマイズは config.ph とコマンドラインオプション両方で行えます。


.S	自動的にメンバー登録をするとかしないとか…


前述のとおりデフォールトは来たメールの From: を見て、メンバーチェック
をします。

自動的に登録することも、メンバーチェックをせずにす通しをすることもでき
ます。


各種動作モード等

	す通しをする。つまりスプールし再配送するだけ
	メンバーチェックし、メンバーなら配送しコマンドもうけつける
	メンバーチェックし、メンバーでないなら
		中身に関わらず登録
		Subject: に subscribe のようなキーワードを必要
		本文に subscribe のようなキーワードを必要

ちなみにキーワードは変えられます。


.S	豊富なファイル操作：取り寄せとまとめ送りと…

それぞれのユーザごとに細かく設定可能です。

get, mget, matome 等のコマンドにはオプションで MIME/Mulitpart 形で記事
をまとめて送り返して欲しい 等の変更ができます。

mget と まとめおくりでの User interface は次のようなものが取り揃えられ
ています。


	PLAINTEST 
		UNIX FROM
		RFC934	
		RFC1153
		MIME/Multipart
	COMPRESSED FILE
		gzip UNIX FROM file
		Lha + Ish 	（自動ＳＪＩＳ変換可）
		Lha + uuencode 	（自動ＳＪＩＳ変換可）
		tar + gzip
		uuencode

mget で取り寄せられるのは デフォールトは $SPOOL_DIR (default "spool") 
ですが、対象は標準のＭＬの記事スプール以外にも @ARCHIVE_DIR でいくらで
も設定できます。


ファイル操作の応用編として user が put も get できるように拡張されたコ
マンドも実装しています（library コマンド）。

ただし、デフォールトでは、put するファイル名は security 上選べません。
ファイル名を明示的に指定する場合は安全のため管理者が変更するべきです。


コマンドを認識するようになっている場合、デフォールトは最初の3行のどこ
かに "# command（英文字Only）" syntax をコマンドと認識します。
これは配送メールとコマンドメールを識別するために必要な処理です。

しかし専用サーバなら # でモードを切替える必要はないわけで、 コマンド 
インターフェイス は拡張され、コマンド専用の場合 # はなくてもかまいません。
コマンド操作の誤チェック機能も実装しました。

当然、Listserv 形式のシンタックスをうけつけるように拡張されたインター
フェイス(libexec/fmlserv.pl)を使う場合には、どっちでもいいわけです。


.S	 MIME や base64 等の処理 


基本的にすどおしですが、MIME 処理は下請けにだして、Subject をdecode し
てから save 等が可能です。

また、base64 の HTML モードでの画像等の変換処理をも行ないます。
つまり、メール中の gif ファイルを変換してメールの記事の html を生成し
ます。


.S	リモートでＭＬを管理すること


管理者として登録された人に対し

	From: 行での認証
	管理者一人ごとのパスワード

の２つで認証をします。デフォールトは2段階ですが、パスワードがいらない
というのであれば、外すことができます。
＃ $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 0;


fml 1.0 で『管理者が本当に操作しているかどうか?という点に関して保証で
きない』という理由ではずしたリモート管理(アドミンコマンド)を再実装し、
サポートします。

保証できないという意味は From: での認証は簡単に偽造できるからです。

そのため普通パスワードも併用します。このパスワードは 各管理者ごとに設
定できます。管理者全体で一つの共通パスワードというような ださい実装な
んかしていません。

これは普通の UNIX の パスワードシステム のミニチュア版です。
サーバ側では etc/passwd に 管理者ごとにパスワードを保存しています。 
保証の度合が上がったわけではありませんが、Password は crypt し保存して
います。一応かつての UNIX 程度の保証はされます。

しかしながら、メールの中では平文パスワードを書く必要がありますし、ひと
りの管理者のパスワードは毎回同じで使い捨てではありません（時系列に沿っ
て）。
よって、間違ってメールが読まれた場合を考えると危険なわけです。


S/KEY 版を実装し、管理用のメールも 使い捨てパスワード にし安全の度合を
あげる予定です。


.S	 さまざまなインターフェイス

   ~/.forward インターフェイス 	 	libexec/fml_lcoal.pl

通常 /etc/aliases をいじるのですが、.forward は本質的に同じものです。
もっとも .forward の場合 user 名以外のものを使うことはできないわけです
が。


   Listserv 互換用インターフェイス 	libexec/fmlserv.pl

fmlserv.pl を呼ぶようにした場合 コマンドは

	コマンド ＭＬ名前 オプション

になります。ようは Listserv 形式のしんたっくすで fml のコマンドを使え
るようにしたインターフェイスです。

	listserv:  fmlserv
	majordomo: fmlserv
	fmlserv: :include:/var/spool/ml/include/fmlserv

のようにしても大丈夫です。

fmlserv.pl のコマンドラインでの --majordomo オプションは 今まで 
majordomo 構造だった directory structure もうけつけるようにするための 
emulation 命令です。



.S	sendmail との通信

デフォールトでは fml は sendmail 等の SMTP配信エージェントと自力で通信
します。

	$Envelope{'mci:mailer'} = 'ipc'; 

がデフォールトですが、

	$Envelope{'mci:mailer'} = 'prog';

とすることで、$SENDMAIL という変数のプログラムを起動して、それに配送を
させることもできます。

	$Envelope{'mci:mailer'} = 'ipc'; 

の場合、自分のマシンで走っている sendmail と通信しようとしますが、
必ずしも自分のマシンで sendmail が走っている必要はありません。

もっとも SMTP を理解してくれるなら sendmail である必要もないですし
配送用に使えるSMTPサーバ があれば動きます。
サイトで走っているSMTPを理解してくれる配送プログラムがあればよいです。
それもなければ、sendmail を 'prog' で起動すればよいだけでよいわけですが…


逆にどうやってメールを受けとるかという問題があります。通常 SMTP を理解
する受けとるサーバが走っていて、メールを受けとり fml.pl へ渡します。

しかし、そうでなくてもよいわけで、例えば 一定時間間隔で POP をかけてＭ
Ｌを動かし、配送はサイトのSMTPサーバにやらせることでＭＬを実行するこは
可能です。


.S	その他の機能


ロックは flock によるロック処理をデフォールトにしています。が flock() 
が動かない場合 UNIX V7 依頼の link() によるロックを使います。

% hack によるリレーサーバを処理します。例えば、関東方面、関西方面にこ
ねがあって、マシンが調達できる場合、関東方面のメールを一回そのマシンに
送ることで関東方面へおくるメールを一つのメールでいっきにおくって、配送
はそのリレー先にまかすことで、配送を高速化できます。

プロバイダ等でDISKに制限があったりする場合は、古い記事は消したいとおも
いますが、そのための Expire 機能をサポートします。

また、同様に newsyslog をサポートし、古いログは自動的に
	e.g. log -> var/log/log.0 
のように変換し保存するようにしています。デフォールトでは members file 
や まとめおくりのログに対して newsyslog を実行しています。

一つのマシン上にある ＭＬ間のクロスポスト の場合、
複数のＭＬに入っている人には一通しか送らないようにします。
＃サイトにまたがる場合はデータのシンクロが必要なため実験段階です


おまけ機能として、スタートレックの宇宙歴をサポート（笑）します。
contrib/Utilities に宇宙歴をつけるmh, mh-e user interface つき:-)です。


.C	Version up と Compatibility 

.S	cp *.pl your-fml-directory

ひろげて src/ の下にある *.pl だけ今使っているところへコピーしてくださ
い(おしまひ)。


.S	新しい機能を有効にするには？

なお、新しい機能は config.ph へ差分だけを付け加えるか コマンドラインで
指定するかしないと使えません。
つまり、新しい機能・オプションは明示的に指定しない限り単に動きません

.S	Backward Compatibility 

Backward Compatibility は保証していますが 万が一 consistencyのないもの
があったら ＭＬ 等へ御一報ください。
変数の定義の仕方の変更等はあっても基本的に内部で自動的に補整してますの
で気にしなくて大丈夫です。
他の定義方法に replcase されたため削除したものについてはこのドキュメン
ト中でふれられています。
＃注意：複雑なフックの場合は注意がいると思います。
＃
＃古いライブラリも一応Packageに一緒に入ってます。
＃lib/Compatibility に移動しておきました。
＃サーバ本体と関係ないもの若干は ./bin の下に移動したものもあります。


.S	CF VERSION による Backward Compatibility 
.k	$CFVersion
.k	$COMPAT_CF1 

fml 2.1 の標準の config.ph は $CFVersion = 2; です。これは cf/config 
を使って生成されるものです。これ以前の config.ph を使っている場合は

	$COMPAT_CF1 = 1;

がセットされているか $CFVersion が２より小さい場合は自動的に

	libcompat_cf1.pl
.k	libcompat_cf1.pl

が dynamic loading されます。


.S	1.6より前からの移行について

1.6では、基本的なデータ構造を call by reference 用に書き直したので、
いままでの SMTP_OPEN_HOOK 等の カスタマイズはそのままでは反映されません。
libcompat.pl にBackward compatibility のためのコードがあります。
昔の設定を変えたくないなら、config.ph に 

	$COMPAT_FML15 = 1; 

と書くと複雑なフックをしかけていない限り compatible にできます。
コードの都合上どうしても実現できないカスタマイズもありえます_o_

昔できたことは今の実装でも必ずできるのでこのドキュメントを参照してみて
下さい。



.C	設計指針に関するいくつかの考察…

.S	From: はすべてを認めるべきだろうか？
.k	$REJECT_ADDR

現在は $REJECT_ADDR で定義されたアドレス群を From: に含むものはエラー
として管理者へフォワードされます。それは個人を代表しているとみなされな
いアドレスにたいしてです。というのはＭＬとは個人と個人を結び付けるもの
だと思われるからです。現在は

    $REJECT_ADDR = 'root|postmaster|MAILER-DAEMON|msgs|nobody';

のように設定されています。From:がこれらのアドレスだった場合管理者へフォ
ワードし伺いを立てます。そこから後はＭＬ管理者の判断でしょう。

この他にも uudecode や sysdiag(苦笑) のような attack で出てきそうなア
ドレスもありますが、まぁまず使ってないでしょう。果たしてこれは増やすべ
きなのか、減らすべきなのか？私見としては、もっと増やすべきではないだろ
うかと思うのですが…


.S	ML無限ループのチェックメカニズム
.k	$CHECK_MESSAGE_ID

デフォールトは $CHECK_MESSAGE_ID がセットされています。この時は
「Message-ID: フィールドはメールそれぞれについて時空全体で unique であ
る」という定義を利用したループチェックを行ないます。
.xref	$LOG_MESSAGE_ID

これ以外にもチェックはしていますが、理論上はこの uniqueness がもっとも
美しいでしょうね。


.S	newsyslog(8) について
.k	newsyslog(8)
.k	/usr/bin/newsyslog
.k	libnewsyslog.pl

/usr/bin/newsyslog に対応するものとして、libnewsyslog.pl が実装されて
います。昔の /etc/daily 等では

	…
	rename log.0 log.1
	rename log log.0
	…

とやっていたログファイルの整理を行なうプログラムです。4.4BSD では、も
ともと MITの Athena Project で作られたプログラムが使われています。

fml.pl がnewsyslog を使って処理するデフォールトのファイル群は
.k	@NEWSYSLOG_FILES
.k	$NEWSYSLOG_MAX
.k	&NewSyslog

で次のファイルに定められています。

    @NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak");

つまり、まとめおくり、配送・認証リスト等の変更があった時にできるバック
アップファイルです。

また関数コール自体(&NewSyslog)の引数(配列)は整理したいファイル群です。

変数
	$NEWSYSLOG_MAX 	

は「整理するのは何個までか？」を決めます。デフォールトは４、つまり

	log.4 log.3 ... log.0 log 

まで順番にまわって保存・整理されます。また、

	@NEWSYSLOG_FILES

は msend が日曜の朝 newsyslog をかけるファイル群を指定しています。


.S	Date: == サーバが配送した時間

オリジナルにしたい人はそうカスタマイズすればいいだけですが。

元々の理念は、サーバをどう考えるか？という観点で

1	サーバが単にリレーしてるだけ (passive?)

なのか

2	サーバまでの通信路はＯＫでした、はい。
	じゃ今からサーバ→メンバーへ配送するね(active?)

最初のデザイン当時 2 を重視したと。で、Posted: がサーバまでの配送の最
低限の pointer として残して、Date: にはサーバ→メンバー配送のための情
報としてサーバの localtime() をつけたと。そんな歴史的背景がありますね
＃まぁ当時からUUCPは除いて大抵２つはほとんど同じだったですけどね

Post: との時間差が単純なネットワークのDELAy情報が分かるのは副次的効果
です。

その他の副産物として時間順ソートをするだけでＭＬの記事を追うことができ
ます。つまりサーバが受けとった順ですね。
＃配送は途中のパスすべてに依存するのでメールを出したオリジナルの時間が
＃情報の順番とは限らないからです。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Received: をけずる

・出した人〜ＭＬサーバまでのパスの mail rechability は管理者のみが理解
していればよい。それ以外のメンバーは知らなくてもよい。

・Too many hops を防ぐためにけずった方がよい

という考えがあります。
＃ See fml-support's ML Count: 01816, 01821 for the discussion


.S	Return-Receipt-To: も削るべき

配送したメンバー全員からメールが返ってくるからですね。

もちろん本来はヘッダの意味を考えてメールを書かない”そのメールを出した
人”が悪いのはいうまでもありまん。



.C	用語

以下で使う用語について2、3説明しておきます。

.S	MLのHOME
.k	MLのHOME

ML(fml) の HOME は config.ph のある場所です。例えば config.ph が 
/var/spool/ml/elena/config.ph にあるとすると、directory
/var/spool/ml/elena をMLのHOMEと呼んでいます。

現在の実装は config.ph はなくてもかまいません。ですから spool
(/var/spool/ml/elena/spool) や log (/var/spool/ml/elena/log)が作られる
directory (/var/spool/ml/elena) のことだとおもってください。

.S	SMTP
.k	SMTP
.k	Simple Mail Transfer Protocol

SMTP == Simple Mail Transfer Protocol。 sendmail 間の通信方式のこと。

.S	SMTPでうけるサーバ

sendmail というプログラムが元祖であり、もっとも代表的なプログラムです
が、SMTPを理解すればうけるのは何でも構いません。
例えば、TIS (Trusted Information System) の Gauntlet という Firewall 
では smap というプログラムが受けて queue だけをします。

世の中にはそれ以外にも sendmail もどきのプログラムはありますから、
sendmail に拘る必要はありません。

この文書では Target machine が 4.4BSD なので、sendmail と perl を使う
場合について解説しています。


.S	sendmail
.k	/usr/sbin/sendmail
.k	sendmail

現在も Eric Allman がメンテしている メール配送エージェントのこと。
sendmail は BSD の標準装備です。

どんな複雑な環境でも適応できる柔軟性を兼ね備えている分、security hole 
もありえます。bug つぶしのupdateは非常にはやいです。そのため常に最新版
を使うようにして下さい。
例えば

	ftp://ftp.cert.org/pub/tools/sendmail/
	ftp://ftp.sendmail.org/

国内のミラーは例えば

	ftp://ftp.iij.ad.jp/pub/network/sendmail/

です。


.S	sendmail.cf 
.k	/etc/sendmail.cf 
.k	sendmail.cf 

sendmail をコントロールする configration file。これの読み書きができな
いとネットワーク管理者にはなれません(なりたくないって?(泣))。

大抵の場合 motonori さん(motonori@wide.ad.jp) のメンテしている CF パッ
ケージで sendmail.cf を簡単に作ることができるが、この見本で十分実用で
す。

詳しくは、このCFパッケージの日本語マニュアルも参照して下さい。

国内のミラーは例えば

	ftp://ftp.iij.ad.jp/pub/network/sendmail/


.S	newaliases
.k	/usr/sbin/newaliases
.k	newaliases

/etc/aliases から aliases データベースを作るための操作のこと。
/etc/aliases をいじったら必ず newaliases というコマンドを実行しなけれ
ばなりません。


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996      fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
