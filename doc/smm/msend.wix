.C	まとめおくり
.label	{msend-c}
.key	samples/crontab


.S	まとめおくりの仕組み（基本原理、まとめおくり概論)

”まとめおくりのプロセス”がどう動くかというと

	for(;;) {
		寝て、待つ	（待機）
		やることがあるかどうかチェックスル	
		やることがあるなら エントリにしたがって 実行する
	}

のように動いて、一定時間ごとにまとめて配送しようとするわけです。

これをどう実行するか？ということですが、システムが一定時間ごとにチェッ
クしてくれるわけではありません。システムに一定時間ごとに仕事がないかチェッ
クしろ！と教える必要があります。それが「 cron をしかける」という意味です。


.S	プログラム群との対応

ちなみにプログラム群のそれぞれどの部分に対応するかというと

	for(;;) {		(bin/cron.pl)
		寝て、待つ	(bin/cron.pl)
		やることがあるかどうかチェックスル	(msend.pl)
		やることがあるなら エントリ(actives の m= 部分)にしたがって 
		実行する(msend.pl -> libsmtp.pl)
		（で、実行結果の保存 ＞ var/log/msendrc)
	}


です。bin/cron.pl を システムの Cron におきかえれば 同じ論法が成立します。


.S	プログラムの名称の変更 MSendv4.pl -> msend.pl
.key	MSendv4.pl -> msend.pl

最初実験プロジェクトのつもりではじめた時の version 4 というのがついた
MSendv4.pl というプログラム名のまま使ってきましたが、msend.pl に正式に
変更しました。backward compatibility のため MSendv4.pl には link がはっ
てあります。


.S	プログラムのログファイルの名称の変更 $MSEND_RC
.key	MSendrc -> var/log/msendrc
.key	$MSEND_RC

また デフォールトは MSendrc -> var/log/msendrc です。
config.ph で $MSEND_RC が明示的に指定していないと msend.pl は
$MSEND_RC を定義してくれ〜とログを(logファイルへ)吐くでしょう。

まとめおくりが”よきにはかって”動くようにすることはできるのですが、
「中途半端に動くより今何をやっているか？を管理者が知っていること」を重
視して、わざと $MSEND_RC を明示的に指定してくれというようになっていま
す。

＃注意：実は fml の他の部分はほとんどよきにはからえで動きます(^^)
＃まとめおくりが例外です。それは間違って大量のメールを送ったりしては大
＃変だからです。


.S	システムの cron の代わりに bin/cron.pl を使う場合

歴史的な流れを見てる人には見えてるとおもいますけど、bin/cron.pl って 
４．３ＢＳＤ用に開発したものです。Crontab の Syntax は 4.4 ですが

Implicit に doc/op にかいてあるとおり Vixie Cron をいれてるとか POSIX 
なＯＳは個人のCronエントリがかけます。

Cron は 昔からある Unix の Daemon process で １分に一回掟、やることが
ないか調べて、やることがあれば、実行、しなければ、６０秒間ねて待つ と
いうことをします。

今時の CRON はユーザー権限で走ってくれるとおもうのですが、
詳しくは man cron でマニュアルを読んでください。

『ユーザがUnixマシンの機能を使えるサービス内容で、それにお金を払ってい
る契約の場合』（契約書はよく読んでくださいね、そうでないところもありま
す）は迷うことなく加入している provider に聞いて見るのが確実でしょう
(^^)

どうしてもわからない時は、そのマシンの管理者に尋ねてみるとよいでしょう。
ただ volunteer で管理者をやってるケースも多いですからできるだけ自分で
やることが望ましいです。
＃ネットワーク管理者は激務なのでいたわってあげてください（お願い）


UNIX PROGRAMMING ENVIRONMENT:

cron.pl がおちるかもしれない？ という可能性があります。

システムの cron は /etc/rc が実行するので、いいんですが…もしマシンが
おちたら、それにきづくまで、まとめおくり実行されません

そのため、fml.pl が cron.pl をたちあげなおす という必要があります。
ここは、別に手動でやってもかまわないわけですが、まぁどっちでもいいと。

それが、HOOK でやってることです。


.# .S	msend.pl (MSendv4.pl) 
.# man msend 
.include msend-pl.wix


.S	まとめおくり 
.label	{matome-3}
.key	MSendv4.pl
.key	crontab	
.key	MatomeOkuri-ctl.sh
.key	cron

＃注意： 旧名称 では Release 4 と呼ばれていました。


「まとめおくり」とは「msend.pl を使い、メールを一定時間ごとにある程度
まとめてメンバーへ配送する」システムの総称だと思ってください。

まとめおくり を行う時間間隔と まとめるやり方 は ユーザごとに自由に設定
できます。設定はユーザが自分でリモートでコントロールできます。
matome もしくは digest というコマンドでです。
コマンドについては後の節で説明します。

英語では何というのかよくわかりませんが（苦笑）、たぶん digest とでも呼
んでいるんでしょう。
＃ちなみに matome というコマンドと digest というコマンドは同じです。


.S	まとめおくり（Ｒ４）の仕組み

activesがこんなかんじだとしましょう。
-------- actives --------
katri
pollyanna	m=6u
-------- actives --------

	cron で一時間に一度 MatomeOkuri-ctl.sh(これはあくまで見本ね) を呼びます。

			↓

	activesをしらべて pollyanna はまとめおくりで６時間に一度で
	gzipかけないで配送（uがついてる）希望だとわかる。
	＃このとき各ユーザーにどういうふうに送るかも読み取る

			↓

	もし 今の時間 % 6 が０（ｍｏｄ　６） なら、つまり、６、１２、
	１８、２４時なら、配送することにして
	＃２９なら 一日一回午前５時です。

			↓

	var/log/msendrc(旧 MSendrc)という、今までの配送記録を見て、ス
	プールとくらべ 送ってない分を決定する

			↓

	そして、その送ってない分をスプールから掘り出して配送する。

「特定時間になるとそれまでためたメールを送る」

		のではなく、

「特定時間になるとactivesの情報に基づき、その時間におくることになって
いる人に、まだ送っていなかった分のメールをスプールから取り出して送る」


ただし、Ｒ１にくらべると、ちょっと重いことになります、
送る人一人一人について独立に走るので。
その代わりに、１時間〜２３時間おき（＝一日一回とおなじ、無意味:-)）まで
任意の時間指定が可能になります。

	% echo "# matome 6"|Mail -v ml-address 

のように、ユーザー個人がまとめおくりのコントロールをすることができます。

mget と同じだけ自由に送り方の設定をユーザーごとに設定することができます（次節）
＃ help をみてね



.S	まとめおくりの設定例

例：
	３時間おきにUNIX FROMの形で	 

	% echo "# matome 3u"|Mail -v ml-address 



例： MatomeOkuri-ctl.sh（見本） を crontab に書いて使用します

	fml-1.x.x/etc/crontab-4.3	
	fml-1.x.x/MatomeOkuri-ctl.sh
を参考にしてカスタマイズしてみて下さい。
＃ crontab-4.3	は 4.3BSD の形
＃ crontab-4.4	は 4.4BSD の形です。あなたのＯＳがどちらの形なのかは
＃ man crontab とかで調べて下さいませ

配送情報とかエラーメッセージとかを出力しながらmsend.plは走るので、
cron のなかで、MatomeOkuri-ctl.sh の出力をたえずメールで管理者に送ると
かしておくとよいとおもいます。
＃一日２４通増えちゃいますけど、そのくらい誤差でしょ:-)

	msend.pl $DIR -q  

とすると、OUTPUTをだしません（エラーとかは STDERR にだします）




.S	各ユーザーごとにどういうふうに送るかを決める

1.4.1 からは できるようになりました。
デフォールトは UNIX FROM の gzip したやつです。

ただし、RFC1153 をデフォールトに変更すると、1153はまとめおくりの記事に
番号をつけるので、この機能と矛盾してしまいます。
まぁ番号きにしないならいいんですが…


.S	msend.pl (Rel.4) のコマンド一覧(help fileより)

まとめ送り希望の方へ：（基本的に Ｎ時間“おき”）
# matome 数字(0-23)	配送時間は実はmodulus（笑）if(0 == (24 % time))
			だから 17 なんてやっても一日一回と同じです(_o_)
			default は gzip した Unix From つきのファイルの固まり
# matome 数字(13-29)	上の特別の場合で、一日一回Ｎ時にまとめおくり
			１３〜３６の数字がこのケースに当てはまります
			午前５時に一回だけまとめおくり慕いときは、
			２４＋５＝２９ をおくりこんでください。午後５
			時は１７でいいんですが、午前中はこうしないと判
			別がつかないので…

# matome 数字オプション
# matome 数字u		とすれば plain(unpack)、つまりplain textををかえします
# matome 数字i 		とすれば lha + ish で

			オプションなしは GZIP(UNIX FROM) と同じ

		オプションなしはGZIP(UNIX FROM)
	u	PLAINTEXT(UNIX FROM)
	uf	PLAINTEXT(UNIX FROM)
	i	lha + ish 
	ish	lha + ish 
	mp	MIME/Muptilpart	PLAINTEXT
	d	RFC1153 format 	PLAINTEXT
	b	RFC934 format 	PLAINTEXT(mh-burst)
	rfc934	
	ish	lha + ish 
	lhaish
	i
	li
	lu	lha + uuencode
	lhauu
	unpack	PLAINTEXT(UNIX FROM)


# matome 0		普通の配送へ戻す

   例：
   # matome 1		まとめ送り １時間に一回(gzipd)
   # matome 2		まとめ送り ２時間に一回(gzipd)
   # matome 2u		まとめ送り ２時間に一回(plain text)
   # matome 2mp		まとめ送り ２時間に一回 MIME/Multipart形式で
   # matome 17		まとめ送り 一日一回と同じ(gzipd)
			#この場合は１７時に来る
   # matome 29		まとめ送り 一日一回と同じ(gzipd)
			#この場合は午前５時に来る
			＃matome 5 は５時間“おき” という意味

			

.S	CRON(Systemのcron)を使わないまとめおくり その1
.label	{Matomeokuri-not-cron_1}
.key	Matomeokuri-not-cron_1
.key	store-and-deliver.ph
.key	store-and-deliver.pl
.key	$START_HOOK

cronを使わずに、Ｎ通溜ったら まとめ送りの人に配送 という動作をする

例： 10通たまったら配送としましょう
＃もっとも10にみたない時は 日が開ける時に deliverします

store-and-deliver.ph	(configuration file)
store-and-deliver.pl
が lib/MatomeOkuri-NOCRON に入っています。

各ＭＬごとのまとめおくりのし方は store-and-deliver.ph というファイルで
設定してください（ＭＬごとに設定は変えられる）
＃ lib/Matomeokuri-NOCRON/store-and-deliver.ph に見本があります

何通おきに配送するか？	
.key	$MATOME_OKURI_VER5
$MATOME_OKURI_VER5      = 10; 

前回のまとめおくりのときどこまで送ったかのカウント
.key	$MATOME_OKURI_SEQ
$MATOME_OKURI_SEQ       = "$TMP_DIR/matome-seq";

実行するコマンド	＃-a は anytime という意味だす。
.key	$MATOME_OKURI_VER5_EXEC
$MATOME_OKURI_VER5_EXEC = "$LIBDIR/msend.pl $DIR $LIBDIR -a"; 

store-and-deliver.pl がINCLUDE PATH のどこかにいれて、
あとは config.ph で

	$START_HOOK = q#
		require 'store-and-deliver.pl';
	#;

と書いておけばＯＫです。


.S	CRON (Systemのcron)を使わないまとめおくり その２
.label	{Matomeokuri-not-cron_2}
.key	Matomeokuri-not-cron_2
.key	cron.pl

.# bin/cron/p
.include cron.wix


.S	まとめおくりで１、３、６時間おきとか任意時間選択したい（まとめおくり Rel.4）
.label	{msend-3}

version 3 ならユーザーに自分がＮ時間おきに配送してほしかったら
コマンド "# matome N（数字）" を使ってもらえばいいだけです。

でも、１、２だとそれぞれに架空アドレスとコントロールアドレスが必要です
ね（めんどうくさい）。


.S	まとめおくりの いつ送るか？の判定を変える

msend.pl の sub MSendP を変える。
例：今の設定

if (($ID - $Request{$who}) >= 0) {
送るべきメールがあるか？

	return 1 if(0 == ($HOUR % $When{$who}));
	$When{$who} おきに送るのだが、いまの時間は？
		
	return 1 if($When{$who} > 12 && ($HOUR + 24 == $When{$who}));
	一日一回送る人には 今がその時か？
…



.S	まとめおくり一応旧名称との対応表

version 1 一箇所にまとめておいて時間が来たら配送（ユーザーは時間は自由
に選べない）
version 2 １の改良型
version 3 MSend-cron.pl
version 4 とは msend.pl 3の改良型
version 5 は cronを使わずに 10通溜ったらまとめ送りの人へ配送する 
というタイプで パッチが lib/Matomeokuri-NOCRON にあります。
version 6 は 1153形の digest機能を提供します。

Release 1 と呼んでいるのは、架空のアドレスを用いる旧バージョンです。
version 1, 2 はこの文書には一応書いておきますが、obsolete です。
Contrib/Matomeokuri、Contrib/Matomeokuri2、
msend.pl $DIR $LIBDIR -a として cron を動かせば同じなので。


.S	以下は OBSOLETEなまとめおくり の記述の再録です…


.S	まとめおくり	Release 1 (OBSOLETE)
.label	{matome-1}
.http lib/MatomeOkuri/README
.key	msend.pl

「特定時間になるとそれまでためたメールを送る」というシンプルなコード。
本質的に fml 本体とは独立した別のサーバというべきものです
１時間おきと３時間おきのまとめ送りがしたいときは別の架空アドレス等が必要
になります。

fml の actives のエントリーをみながら走ります。その意味で fml とは一体
型です。基本的に３時間に一度のような走らせ方しかできません。
-------- actives --------
katri
pollyanna	matome 6u
-------- actives --------

のように matome のキーワードが書いてある人について配送をします。
まとめおくりをする or 解除は普通のコマンドで行なえます
＃helpファイルを御覧下さい

e.g.
% echo "# matome 6" |Mail -v Elena@phys.titech.ac.jp

Contrib/Matomeokuri、Contrib/Matomeokuri2、の下に一式コードが入ってい
ます。Ｒ１の詳細についてはContrib/Matomeokuri/READMEを読んで下さい。



.S	まとめおくりだと３００行越えちゃいますけど？（まとめおくり Rel.1）
.label	{msend-1}

＃ いまどき３００行は関係ないと思うぞ＞おれ。ＮＩＦだって３０００かな？

確かに「特定時間になるとそれまでためたメールを送る」というシンプルなコー
ドだと、３００行って何にも考えてないんですよね。でも、うかつに切るのは
メールのないように手を加えるみたいで気が引けますが…とりあえず

	msend-300.pl	or msend2-300.pl

ってのが強引に３００（ヘッダがあるので念のため２７５行）行で複数のメー
ルに分ける処理をします。

	$MATOMEOKURI_MAXLINE = 275;

をかえると“何行か”の制御ができます。
＃普通は１０００（だいたい５０ｋくらい）でいいんじゃないかな？

msend.pl は config.ph の$MAIL_LENGTH_LIMIT = 1000; を見ています。こ
こを変更して下さい。


.S	まとめおくりで３時間おきとかはどうしましょう？（まとめおくり Rel.1）
.label	{msend-2}

Ｒ４を使うというのが前向きですが。１、２でやりたいなら

----- control -----
#!/bin/sh

HOUR=`date '+%h'`
X=`expr  $HOUR / 3`
P=`expr $HOUR - 3 \* $X`

if [ 0 -eq  $P ] 
then
	perl msend.pl DIR LIBDIR
fi
---------------

とかをcronに仕掛けて…でいいんじゃないでしょうか？


.# Id: README.eng,v 1.1 1995/10/11 11:30:11 fukachan Exp 
.# $Id$
