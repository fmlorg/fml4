.C	まとめおくり
.label	{msend-c}
.key	samples/crontab


.S	まとめおくりの基本原理

”まとめおくりのプロセス”がどう動くかというと

   for (;;) {
	寝て、待つ(待機)
	やることがあるかどうか($ACTIVE_LISTと$MSEND_RCを)チェック
	やることがあるなら エントリにしたがって 実行する
   }

のように動いて、一定時間ごとにまとめて配送しようとするわけです。

これをどう実行するか？ということですが、システムが勝手に一定時間ごとに
チェックしてくれるわけではありません。

	システムに一定時間ごとに仕事がないかチェックしろ！

と教える必要があります。それが「cron をしかける」という意味です。


まとめおくり を行う時間間隔と まとめるやり方 は ユーザごとに自由に設定
できます。設定はユーザが自分でリモートでコントロールできます。
matome もしくは digest というコマンドでです。
コマンドについては後の節で説明します。

英語では何というのかよくわかりませんが（苦笑）、たぶん digest とでも呼
んでいるんでしょう。
＃ちなみに matome というコマンドと digest というコマンドは同じです。


.S	プログラム群との対応

ちなみにプログラム群のそれぞれどの部分に対応するかというと

	for(;;) {		(bin/cron.pl)
		寝て、待つ	(bin/cron.pl)
		やることがあるかどうかチェックスル	(msend.pl)
		やることがあるなら エントリ(actives の m= 部分)にしたがって 
		実行する(msend.pl -> libsmtp.pl)
		（で、実行結果の保存 ＞ var/log/msendrc)
	}


です。bin/cron.pl を システムの Cron におきかえれば 同じ論法が成立します。


 .S	まとめおくりサーバ msend.pl 

まとめおくりを実行する スクリプト

SYNOPSIS
	msend.pl    [ options ] $DIR [ options ]  [ $LIBDIR [ options ] ]

	fml.pl MSendv4.pl fmlserv.pl は同じ引数のとりかたをします。
	注意：fml_local.pl は MH を意識してるので異なります。

オプションと引数が共存するときは、引数が -ではじまるならオプション、そ
れ以外は Directoryの変数 だと仮定します。順番は関係ありません
Directory に関しては そのDirectoryが存在すれば、引数の順に $DIR、
$LIBDIR にセットされます。


	-d		デバッグモード
			（ＭＬへの配送以外すべてを実行可能）
	-bt   		アドレステストモード	(Become Test)
			（メンバーチェックのところまで。ＭＬへの配送やコマンドは実行しない）
			いまのところ debug mode とかわらへんねん:-)
	-bd		デーモンモード	(Become Daemon)
	-sOPT $OPT 	をセットする。(e.g. -sdebug == -d)
	-uOPT $OPT 	をオフする。  (e.g. -udebug は $debug = 0; と同じ）
	-lfile	file を $LOAD_LIBRARY 変数に代入する (e.g. -llibfml.pl 下↓参照)
	-q		quiet mode (エラーとかWarnig以外は何も出力しない)
			POSIX の cron では OUTPUT をひろうので、-q なら
			エラー時以外はメールが来ないようにするため

これ以外に long line options が使えます。


.S	crontab の見本

INSTALL 時に make していれば samples/crontab に cron の設定のしかたの
見本があります。

4.4BSD では各個人ごとに cron の設定が可能ですから、その場合は

   (shell prompt)% crontab samples/crontab 

で個人ごとのcronが設定できます。samples/crontab は例えば

0 * * * *	/var/spool/ml/Elena/msend.pl /var/spool/ml/Elena

とかきます。

まとめおくりは msend.pl が行ないますが、自動では行ないません。
1時間に一回 msend.pl を実行しなさいとマシンに教える設定が必要です。
それがこの cron の設定です。



.S	プログラムの名称の変更 MSendv4.pl -> msend.pl
.key	MSendv4.pl->msend.pl

最初実験プロジェクトのつもりではじめた時の version 4 というのがついた
MSendv4.pl というプログラム名のまま使ってきましたが、msend.pl に正式に
変更しました。backward compatibility のため MSendv4.pl には link がはっ
てあります。


.S	プログラムのログファイルの名称の変更 $MSEND_RC
.key	MSendrc -> var/log/msendrc
.key	$MSEND_RC

デフォールトが MSendrc -> var/log/msendrc に変更されています。
fml 1.x から version up する時に問題になるかも知れません。

config.ph で $MSEND_RC が明示的に指定していないと msend.pl は
$MSEND_RC を定義してくれと警告を(logファイルへ)吐くでしょう。

まとめおくりが”よきにはかって”動くようにすることはできるのですが、
「中途半端に動くより今何をやっているか？を管理者が知っていること」を重
視して、わざと $MSEND_RC を明示的に指定してくれというようになっていま
す。

＃注意：実は fml の他の部分はほとんどよきにはからえで動きます(^^)
＃まとめおくりが例外です。それは間違って大量のメールを送ったりしては大
＃変だからです。


.S	各ユーザーごとにどういうふうに送るかを決める

fml 1.4.1以降は各ユーザーごとにどういうふうに送るかを決めることができます。
デフォールトは UNIX FROM の gzip したフォーマットです。

各ユーザはコマンドをサーバに送ることで自分でユーザごとの設定をすること
ができます。

例： ３時間おきにUNIX FROMの形で送って欲しい場合

	# matome 3u

をコマンドとして送ります。UNIXのSHELL上なら

   (shell prompt)% echo "# matome 3u" | Mail mail-list@domain


.S	msend.pl のコマンド一覧 (help fileより)
.k	まとめ送りコマンド一覧

まとめ送り希望の方へ：（基本的に Ｎ時間“おき”）
# matome 数字(0-23)	配送時間は実はmodulus（笑）if(0 == (24 % time))
			だから 17 なんてやっても一日一回と同じです(_o_)
			default は gzip した Unix From つきのファイルの固まり
# matome 数字(13-29)	上の特別の場合で、一日一回Ｎ時にまとめおくり
			１３〜３６の数字がこのケースに当てはまります
			午前５時に一回だけまとめおくり慕いときは、
			２４＋５＝２９ をおくりこんでください。午後５
			時は１７でいいんですが、午前中はこうしないと判
			別がつかないので…

# matome 数字オプション
# matome 数字u		とすれば plain(unpack)、つまりplain textををかえします
# matome 数字i 		とすれば lha + ish で

			オプションなしは GZIP(UNIX FROM) と同じ

		オプションなしはGZIP(UNIX FROM)
	u	PLAINTEXT(UNIX FROM)
	uf	PLAINTEXT(UNIX FROM)
	i	lha + ish 
	ish	lha + ish 
	mp	MIME/Muptilpart	PLAINTEXT
	d	RFC1153 format 	PLAINTEXT
	b	RFC934 format 	PLAINTEXT(mh-burst)
	rfc934	
	ish	lha + ish 
	lhaish
	i
	li
	lu	lha + uuencode
	lhauu
	unpack	PLAINTEXT(UNIX FROM)


# matome 0		普通の配送へ戻す

   例：
   # matome 1		まとめ送り １時間に一回(gzipd)
   # matome 2		まとめ送り ２時間に一回(gzipd)
   # matome 2u		まとめ送り ２時間に一回(plain text)
   # matome 2mp		まとめ送り ２時間に一回 MIME/Multipart形式で
   # matome 17		まとめ送り 一日一回と同じ(gzipd)
			#この場合は１７時に来る
   # matome 29		まとめ送り 一日一回と同じ(gzipd)
			#この場合は午前５時に来る
			＃matome 5 は５時間“おき” という意味



.S	まとめ送りとRFC1153とフォーマット…

ただし、RFC1153 をデフォールトに変更すると、1153はまとめおくりの記事に
番号をつけるので、この機能と矛盾してしまいます。
まぁ番号きにしないならいいんですが…


.S	捕捉：まとめおくりと$ACTIVE_LISTと$MSEND_RCと実際の動き…

activesがこんなかんじだとしましょう。
-------- actives --------
katri
pollyanna	m=6u
-------- actives --------

	cron で一時間に一度 MatomeOkuri-ctl.sh(これはあくまで見本ね) を呼びます。

			↓

	activesをしらべて pollyanna はまとめおくりで６時間に一度で
	gzipかけないで配送（uがついてる）希望だとわかる。
	＃このとき各ユーザーにどういうふうに送るかも読み取る

			↓

	もし 今の時間 % 6 が０（ｍｏｄ　６） なら、つまり、６、１２、
	１８、２４時なら、配送することにして
	＃２９なら 一日一回午前５時です。

			↓

	var/log/msendrc(旧 MSendrc)という、今までの配送記録を見て、ス
	プールとくらべ 送ってない分を決定する

			↓

	そして、その送ってない分をスプールから掘り出して配送する。

「特定時間になるとそれまでためたメールを送る」

		のではなく、

「特定時間になるとactivesの情報に基づき、その時間におくることになって
いる人に、まだ送っていなかった分のメールをスプールから取り出して送る」


ただし、Ｒ１にくらべると、ちょっと重いことになります、
送る人一人一人について独立に走るので。
その代わりに、１時間〜２３時間おき（＝一日一回とおなじ、無意味:-)）まで
任意の時間指定が可能になります。

	% echo "# matome 6"|Mail -v ml-address 

のように、ユーザー個人がまとめおくりのコントロールをすることができます。

mget と同じだけ自由に送り方の設定をユーザーごとに設定することができます（次節）
＃ help をみてね



.S	まとめおくりの いつ送るか？の判定を変える

msend.pl の sub MSendP を変える。
例：今の設定

if (($ID - $Request{$who}) >= 0) {
送るべきメールがあるか？

	return 1 if(0 == ($HOUR % $When{$who}));
	$When{$who} おきに送るのだが、いまの時間は？
		
	return 1 if($When{$who} > 12 && ($HOUR + 24 == $When{$who}));
	一日一回送る人には 今がその時か？
…


.S	システムの cron の代わりに bin/cron.pl を使う場合

歴史的な流れを見てる人には見えてるとおもいますけど、bin/cron.pl は
4.3BSD用に開発したものです。crontab の Syntax は 4.4 ですが

Vixie cron をいれてるとか POSIX なOSは個人のcronエントリが設定できます。

cron は 昔からある Unix の Daemon process で １分に一回掟、やることが
ないか調べて、やることがあれば、実行、しなければ、６０秒間ねて待つ と
いうことをします。

今時の cron はユーザー権限で走ってくれるとおもうのですが、
詳しくは man cron でマニュアルを読んでください。

『ユーザがUnixマシンの機能を使えるサービス内容で、それにお金を払ってい
る契約の場合』（契約書はよく読んでくださいね、そうでないところもありま
す）は迷うことなく加入している provider に聞いて見るのが確実でしょう
(^^)

どうしてもわからない時は、そのマシンの管理者に尋ねてみるとよいでしょう。
ただ volunteer で管理者をやってるケースも多いですからできるだけ自分で
やることが望ましいです。
＃ネットワーク管理者は激務なのでいたわってあげてください（お願い）

.#########################################################################
.# BIN/CRON.PL
.# .include cron.wix

.# $Id$
