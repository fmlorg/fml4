.C	まとめおくり (MatomeOkuri or Digest)
.l	msend
.k	msend
.k	digest
.k	まとめおくり
.k	$DIR/crontab


.S	まとめおくりの基本原理

"まとめおくりのプロセス"がどう動くかというと

   for (;;) {	# 無限ループ
	寝て、待つ(待機)
	やることがあるかどうか($ACTIVE_LISTと$MSEND_RCを)チェック
	やることがあるなら エントリにしたがって 実行する
   }

のように動いて、一定時間ごとにまとめて配送しようとするわけです。

これをどう実行するか？ということですが、システムが勝手に一定時間ごとに
チェックしてくれるわけではありません。

	システムに一定時間ごとに仕事がないかチェックしろ！

と教える必要があります。それが「cron をしかける」という意味です。

まとめおくり を行う時間間隔と まとめるやり方 は ユーザごとに自由に設定
できます。設定はユーザが自分でリモートでコントロールできます。
matome もしくは digest というコマンドです。
コマンドについては後の節で説明します。

英語では束は bunch だけど、 digest とか呼んでるような気がする。
＃ちなみに matome というコマンドと digest というコマンドは同じです。

ちなみにプログラム群のそれぞれどの部分に対応するかというと

   for(;;) {		(cron)
	寝て、待つ	(cron)
	やることがあるかどうかチェックする	(msend.pl)
	やることがあるなら エントリ(actives の m= 部分)に従って
	実行する (msend.pl)
	(で、実行結果の保存 > var/log/msendrc というファイルへ)
   }

です。cron の部分はシステムのcronが使えればその方が良いのですが、不可
能なら bin/cron.pl をシステムのcronの代わりに使えばよいわけです。


.S	まとめおくりサーバ  msend.pl 
.k	msend.pl
.k	MSendv4.pl

まとめおくりを実行する スクリプト

SYNOPSIS
   msend.pl    [ options ] $DIR [ options ]  [ $LIBDIR [ options ] ]

   fml.pl msend.pl fmlserv.pl は同じ引数のとりかたをします。
   注意：fml_local.pl は MH を意識してるので異なります。

オプションと引数が共存するときは、引数が - ではじまるならオプション、
それ以外は Directoryの変数 だと仮定します。順番は関係ありません
Directory に関しては そのDirectoryが存在すれば、引数の順に $DIR、
$LIBDIR にセットされます。

次のようなオプション及びlong line options を取ります。

   -d		デバッグモード
			（ＭＬへの配送以外すべてを実行可能）
   -bt   		アドレステストモード	(Become Test)
			（メンバーチェックのところまで。ＭＬへの配送やコマンドは実行しない）
			いまのところ debug mode とかわらへんねん:-)
   -bd		デーモンモード	(Become Daemon)
   -sOPT $OPT 	をセットする。(e.g. -sdebug == -d)
   -uOPT $OPT 	をオフする。  (e.g. -udebug は $debug = 0; と同じ）
   -lfile	file を $LOAD_LIBRARY 変数に代入する 
		e.g. -llibfml.pl 
   -q		quiet mode (エラーとかWarnig以外は何も出力しない)
		POSIX の cron では OUTPUT をひろうので、-q なら
		エラー時以外はメールが来ないようにするため


.S	crontab の見本
.k	crontab (4.4BSD)
.k	$DIR/crontab

INSTALL 時に make していれば $DIR/crontab に cron の設定のしかたの見本
ができています。ここで $DIR は各ＭＬのHOMEです(config.phのある場所)。

4.4BSD では各個人ごとに cron の設定が可能です。その場合、

   (shell prompt)% crontab $DIR/crontab 

を実行することで個人ごとのcronが設定できます。$DIR/crontab は例えば

0 * * * * /usr/libexec/fml/msend.pl /var/spool/ml/Elena /usr/libexec/fml

のように書きます。

上述のように「まとめおくりは msend.pl が行ないますが、自動では行なえま
せん。1時間に一回 msend.pl を実行しなさいとマシンに教える」設定が必要
です。それがこの cron の設定なわけです。



.S	プログラムの名称 msend.pl (旧 MSendv4.pl)
.k	MSendv4.pl->msend.pl

最初実験プロジェクトのつもりではじめた時の version 4 というのがついた
MSendv4.pl というプログラム名のまま使ってきましたが、msend.pl に正式に
変更しました。ただし backward compatibility のため、 MSendv4.pl には 
link がはってあります。


.S	プログラムのログファイル $MSEND_RC (名称が変更されました)
.k	MSendrc -> var/log/msendrc
.k	$MSEND_RC

デフォールトが MSendrc -> var/log/msendrc に変更されています。
fml 1.x から version up する時に問題になるかも知れません。

config.ph で $MSEND_RC が明示的に指定していないと msend.pl は
$MSEND_RC を定義してくれと警告を(logファイルへ)吐くでしょう。

まとめおくりが”よきにはかって”動くようにすることはできるのですが、
「中途半端に動くより今何をやっているか？を管理者が知っていること」を重
視して、わざと $MSEND_RC を明示的に指定してくれというようになっていま
す。

＃注意：実は fml の他の部分はほとんどよきにはからえで動きます(^^)
＃まとめおくりが例外です。それは間違って大量のメールを送ったりしては大
＃変だからです。


.S	コマンドで各ユーザーごとにどういうふうに送るかを決めること

fml-1.4.1 以降、各ユーザーごとにまとめ送りの様式を決めることができま
す。デフォールトは UNIX FROM の gzip したフォーマットです。

各ユーザはコマンドをサーバに送ることで、自分で設定を変更することがで
きます。

例： ３時間おきにUNIX FROMの形で送って欲しい場合

	# matome 3u

をコマンドとして送ります。UNIXのSHELL上なら

   (shell prompt)% echo "# matome 3u" | Mail コマンド用のアドレス

ですね


.S	まとめ送りメールに付くSubjectの設定
.k	$MSEND_DEFAULT_SUBJECT	

syntax:
	$MSEND_DEFAULT_SUBJECT モード表示 (1/N) ($ML_FN)

で設定します。

例：    
	$MSEND_DEFAULT_SUBJECT = "ML BUNCH SERVICE";

とすると

	ML BUNCH SERVICE Article 311 [PLAINTEXT(UNIX FROM)] (1/1) (Elena Lolabrigita ML)


.S	まとめ送り処理をhookする場合
.k	$MSEND_START_HOOK

$MSEND_START_HOOK 
実際の配送作業の始まる直前に評価されます。

.k	$MSEND_HEADER_HOOK
$MSEND_HEADER_HOOK
msend の Subject: 等を変更する場合に使用します。


.S	まとめ形式のデフォールト
.k	$MSEND_MODE_DEFAULT
.xref	$MGET_MODE_DEFAULT
.k	$USE_RFC1153_DIGEST
.k	$USE_RFC1153
.k	$USE_RFC934


gzip で複数のファイルを一つにして送るのがデフォールトですが、 
$MSEND_MODE_DEFAULT の値で、まとめ送りサーバの設定を変更することが出来
ます。使えるパラメータは $MGET_MODE_DEFAULT と同様です。

なお便利なように、これらの簡易設定があります。

	$USE_RFC1153_DIGEST	デフォールトをRFC1153
	$USE_RFC1153		デフォールトをRFC1153
	$USE_RFC934		デフォールトをRFC934

に設定する(詳細以下)。


.S	まとめおくりのデフォールトで RFC934 形をつかうか？
.k	$USE_RFC934

	$USE_RFC934 = 0 or 1;

まとめおくりで、0はデフォールトのUNIX FROMで区切られたメールを送り出す
が、1なら次のような形のものを送るようになる。これは mh のburstで複数の
mailに展開できます。＃あと、どういうソフトがあるのか知らない…:-)

[934形式の例]

	------- Forwarded Message
	From: uja
	Subject: daa 

	うじゃ
	------- Forwarded Message
	From: uja
	Subject: daa
	
	あおいちゃんパニック もいいけど せいふくもの もよくてよ
	------- Forwarded Message


.S	まとめ送りのデフォールトを RFC1153 digest にする
.l	msend-RFC1153
.k	RFC1153
.k	$USE_RFC1153
.k	$USE_RFC1153_DIGEST

これには、それぞれまとめた束に、通し番号をつけなければなりません。よっ
てまとめおくりのデフォールトを1153に統一することになります。ユーザがコ
マンド # matome 3 としても、 gzip ではなく 1153 形を意味するようになり
ます。この形式では通し番号はばらばらで各ユーザ毎に適当についてます。

config.ph で $USE_RFC1153 = 1; としてください。
＃ Backward Compat で $USE_RFC1153_DIGEST も同じ意味

もし細かい所を変えたい場合は、 librfc1153.pl でフォーマットを決めてく
ださい

RFC1153 をデフォールトに変更すると、1153はまとめおくりの記事に番号をつ
けるので、個人個人に1153で送ると人によって番号が食い違い、矛盾がおきて
しまいます。
＃NetNewsなんかで1153形式を見ればわかるとおもうんですが…

まぁ番号を気にしないならいいんですが…

[注意]
一時期 デフォールトで 3時間に 強制的に設定しておいてある version があ
りますが、ようは番号の整合性をとるためです。１時間おきの１１５３送りの
人と、３時間おきの１１５３送りの人、があると番号が食い違ってしまいます。
番号の整合性を無視すれば、どうでもいいことなんですが…。とりあえず、こ
の部分はコメントアウトしてあります（95/6/27)


.S	msend.pl のコマンド一覧 (help fileより)
.k	まとめ送りコマンド一覧

○まとめ送り希望の方へ：（基本的に Ｎ時間“おき”）
なお # digest と # matome は同じコマンド(引数も当然同じ)です。

# matome 数字(0-23)	配送時間は実はmodulus（笑）if(0 == (24 % time))
			だから 17 なんてやっても一日一回と同じです(_o_)
			様式 default は gzip した Unix From つきのファイ
			ルの固まり
# matome 数字(13-36)	上の特別の場合で、一日一回Ｎ時にまとめおくり
			１３〜３６の数字がこのケースに当てはまります
			午前５時に一回だけまとめおくり慕いときは、
			２４＋５＝２９ をおくりこんでください。午後５
			時は１７でいいんですが、午前中はこうしないと判
			別がつかないので…
   例：
	# matome 数字u	plain(unpack)、つまりplain textを
	# matome 数字i 	lha + ish でまとめて送ります
   オプション：
		オプションなしはGZIP(UNIX FROM)
	u	PLAINTEXT(UNIX FROM)
	uf	PLAINTEXT(UNIX FROM)
	i	lha + ish 
	ish	lha + ish 
	mp	MIME/Muptilpart	PLAINTEXT
	d	RFC1153 format 	PLAINTEXT
	b	RFC934 format 	PLAINTEXT(mh-burst)
	rfc934	
	ish	lha + ish 
	lhaish
	i
	li
	lu	lha + uuencode
	lhauu
	unpack	PLAINTEXT(UNIX FROM)


# matome 0		普通の配送へ戻す

   例：
   # matome 1		まとめ送り １時間に一回(gzipd)
   # matome 2		まとめ送り ２時間に一回(gzipd)
   # matome 2u		まとめ送り ２時間に一回(plain text)
   # matome 2mp		まとめ送り ２時間に一回 MIME/Multipart形式で
   # matome 17		まとめ送り 一日一回と同じ(gzipd)
			#この場合は１７時に来る
   # matome 29		まとめ送り 一日一回と同じ(gzipd)
			#この場合は午前５時に来る
			＃matome 5 は５時間“おき” という意味


.S	まとめ送りをしたと msend からメールが出る
.k	$MSEND_NOTIFICATION
.k	$MSEND_NOTIFICATION_SUBJECT

	$MSEND_NOTIFICATION = 1;

の時、 msend は「まとめ送りをした」ことをメールで管理者へ知らせます。

4.3BSD用だとおもえばよいでしょう。あの頃の cron はログをフォワードした
い時は explicit に書かないといけなかったので…

僕は 4.4BSD の cron なので、cron のログを見てますけどね(^^)

また、
	$MSEND_NOTIFICATION_SUBJECT 
	(デフォールトは "Notification $ML_FN")

はその時のメールの Subject: です。


.S	まとめ送りの時には X-ML-Info: は必要ない
.k	$MSEND_NOT_USE_X_ML_INFO
.k	$NO_ML_INFO

	$MSEND_NOT_USE_X_ML_INFO = 1;

で付けないようにします。(注意： $NO_ML_INFO から名称変更)


.S	捕捉：まとめおくりと$ACTIVE_LISTと$MSEND_RCと実際の動き…

activesがこんなかんじだとします。

	-------- actives --------
	katri
	pollyanna	m=6u
	-------- actives --------

	cron で一時間に一度 msend.pl を呼びます。

			↓

	activesをしらべて pollyanna はまとめおくりで６時間に一度で
	gzipかけないで配送（uがついてるから）希望だとわかる。
	この時に各ユーザごとにどういうふうに送るかを読み取っています

			↓

	もし 今の時間 % 6 が0(mod 6) なら、つまり、6、12、
	18、24時なら、配送することにして
	＃もし 29 なら 一日一回午前5時です。

			↓

	var/log/msendrc(旧 MSendrc)という、今までの配送記録とスプールの記事
	のたまり具合を比べ送ってない分がどの記事か？を決定する。
	記事がない場合はそのまま終り

			↓

	送ってない分をスプールから取り出して配送する。

つまり 
	「特定時間になるとあらかじめためてあったメールを送る」
のではなく、
	「特定時間になるとactivesの情報に基づき、その時間に送ることに
	なっている人に、まだ送っていなかった分のメールをスプールから取
	り出して送る」
わけです。

そのため各個人ごとに送り方を完全にカスタマイズすることが可能になるわけです。

また送る時の記事のまとめ方も、 mget コマンドと同じだけの自由度が選べます。
.xref	mget


.S	まとめおくりの いつ送るか？の判定を変える

msend.pl の sub MSendP で行っています。この変更でできます…。

例：今の設定

   if (($ID - $Request{$who}) >= 0) {
	送るべきメールがあるか？

	return 1 if(0 == ($HOUR % $When{$who}));
	$When{$who} おきに送るのだが、いまの時間は？
		
	return 1 if($When{$who} > 12 && ($HOUR + 24 == $When{$who}));
	一日一回送る人には 今がその時か？
	…

.S	まとめおくりをデフォールトにする
.l	msend-anytime

contrib/msend-anytime にテスト版の「リアルタイム配送はしないで全員にま
とめおくりをする場合のパッチ」があります。

設定は、このパッチをあてて -a と -A オプションつきで msend.pl を起動す
るように改造します。まとめ送りのタイミングは cron から起動する時間で調
節して下さい。

まとめ送りの設定をしていないユーザへのまとめ送りのモードは

	$MSEND_MODE_DEFAULT 

で決まります。


.S	捕捉：システムの cron の代わりに bin/cron.pl を使う場合

歴史的な流れを見てる人には見えてるとおもいますけど、bin/cron.pl は
4.3BSD用に開発したものです。crontab の Syntax は 4.4 ですが

Vixie cron をいれてるとか POSIX なOSは個人のcronエントリが設定できます。

cron は 昔からある Unix の Daemon process で １分に一回起きて、やるこ
とがないか調べて、やることがあれば、実行、しなければ、６０秒間ねて待つ 
ということをします。

今時の cron はユーザー権限で走ってくれるとおもうのですが、
詳しくは man cron でマニュアルを読んでください。

『ユーザがUnixマシンの機能を使えるサービス内容で、それにお金を払ってい
る契約の場合』（契約書はよく読んでくださいね、そうでないところもありま
す）は迷うことなく加入している provider に聞いて見るのが確実でしょう
(^^)

どうしてもわからない時は、そのマシンの管理者に尋ねてみるとよいでしょう。
ただ volunteer で管理者をやってるケースも多いですからできるだけ自分で
やることが望ましいです。
＃ネットワーク管理者は激務なのでいたわってあげてください（お願い）

.#########################################################################
.# bin/cron.pl
.include cron.wix

.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.

