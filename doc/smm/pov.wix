.C	fml の基本動作と起動オプション…
.l	fml-process

ＭＬサーバの基本動作を知っておくとカスタマイズの時役にたつでしょう。


.S	ＭＬサーバの動作 (fml と sendmail の役割分担)
.key	ＭＬサーバの動作
.l	ml-process

   メールが SMTP で送られてくる

             ↓

   SMTP で待ち構えているプログラムがうけとる (例： sendmail)

             ↓

   /etc/aliase から何をすれば良いのかを理解して、
   setuid 操作等を行なった後
   fml の STDIN にメールが送り込まれる。
             ↓

   (sendmail -> fml へ引き渡される。ここからが fml の担当)
   config.ph による設定に従い、ヘッダの解析、ＭＬメンバーのリストに従い
   配送 or コマンド要求を処理した結果のメールを
   sendmail 等のSMTPサーバへ引き渡す

             ↓

   (ここから再び sendmail の担当)
   sendmail 等のSMTPサーバがメールの配送を行なう。


フィルタだけなら sed でも十分だし、“配るだけ”なら Sendmail 8.x でも
十分でしょう。しかし、＋αでログをとり、スプールし、必要なら取り寄せら
れるようにちょこっとだけ複雑なことをしようとするならこの サーバ まで必
要となるわけです。

なお、この図でわかるとおり、まとめおくりはこれとは別のプロセスです。
.xref msend


.S	sendmail -> fml 時の動作
.k	sendmail -> fml 時の動作
.l	sendmail2fml

sendmail から fml へメールが渡される時は次のように動作します。

○ まず /etc/aliases にある

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で、sendmail はこのファイルを実行します。

	/usr/local/list/Elenaの中身は

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

のようになっています。

次に fml が上の引数（上例では コマンドラインオプションがないが）は 
/var/spool/ml/elena/ を Elena ML の home directory だと見なし
/var/spool/ml/elena/config.ph に従い fml の設定を行います。

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは 	/usr/local/list/Elena の中で

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

や（デフォールト）

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena --distribute "

のように書きます（コマンドラインオプションをつける場合）。

引数の書き方の順番は任意です。引数の最初の directry をMLのホーム
(config.phのある場所 もしくは spool やメンバーファイルのある場所)と見
なします。


.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)
.k	fml.plと引数
.k	DIR
.k	LIBDIR

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

のように起動されるわけですが、この場合

	/usr/libexec/fml/fml.pl 
の
	/usr/libexec/fml 

部分をとりだします。そして

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた（複数可能）場合、例えば

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 
	3   /usr/lib/uja
	4   /lib/uja

のような順番でファイルを探します。


.S	オプション設定の優先順位
.k	オプション設定の優先順位

オプション設定の強い順番に並べると

	1   コマンドラインオプション (fml.pl -d や --distribute 等)
	2   sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3   各MLごとの config.ph による設定
	4   fml デフォールト設定

大抵の program と同様ですね。ちなみにインストール時に 
samples/sitedef.ph が作られますので参考にしてみて下さい。
とりあえずこれはＭＬごとではなくそのマシン共通の設定になるもの

	tar や gzip はどこにある？

の設定のみを sitedef.ph でしています。



.# ##########################################################
.#	command line options
.include clo.wix


.S	fmlのプロセス

.S	fml process の signal handling
.k	$SIGARLM
.k	$TIMEOUT

現在は次のように設定されています。
これは alarm(3) を使ういつものやり方です。
TIMEOUTを待つ時間は $MAX_TIMEOUT で決まります。

    # signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'}  = $SIG{'QUIT'} = 'SignalLog';

$TIMEOUT 後 $SIG{'ALRM'} で定義された関数(TimeOut)を実行します。

TimeOut は管理者へTIMEOUTを知らせ、ログを残しfmlを終了します。
これがないとずっとロック(flock)がかかったままになるからです。

なお、flock を使わない時はTIMEOUTしたメールを保存し、管理者へTIMEOUTを
知らせます。詳細は liblock.pl を見るとわかるでしょう。


.S	SMTPライブラリについて
.k	SMTP
.k	Simple Mail Transfer Protocol
.k	MTA
.k	Mail Transport Agent

SMTP ライブラリは SMTP(プロセス間通信)で sendmail 等のMTA(Mail
Transport Agent)と通信するライブラリです。

$PORT = 25 (25/tcp) で通信しますが、

	$PORT 

を変えることで別のポートで通信することもできます。また、標準で

	$SMTP_LOG

というファイルに通信のログを残します。このログはデバッグに非常に役立ち
ます。

	$NOT_TRACE_SMTP 
.k	$NOT_TRACE_SMTP 

をセットすると、このログは残りません。


.S	予備のSMTPサーバ
.k	@HOSTS

もしSMTPサーバに何かあった時のために @HOSTS に複数台の sendmail の走っ
ているマシンを定義することが出来ます。

   @HOSTS = (machine-1.domain, machine-2.domain, machine-3.domain, ...);

この場合、もし machine-1 に connect() できない時は machine-2 へ…とい
う風に予備のサーバを使い何とか配送をしようと試みます。


.S	その他の変数（未解説）

	$COMPAT_CF1
	$UMASK
	$GOOD_BYE_PHRASE
	@MEMBER_LIST


.C	fml 内部におけるデータ構造
.l	data-structure
.xref	hack


ここでは fml 内部処理におけるデータ構造について解説します。これらの知
識は改造する上で必須の事柄でしょうが、単に変数を1 or 0 にセットするだ
けしか config をいじらないなら読む必要はないでしょう。


.S	変数名の Naming Convention
.key	変数の名前つけ
.key	変数の Naming Convention
.key	Naming Convention


○ 大文字（[A-Z0-9_]+）だけの塊はユーザーのカスタマイズで使う目的の
   Global 変数です。

	例：	$ML_MEMBER_CHECK

○ ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語はメー
   ル本体やヘッダをSubroutine間で渡しあうための Global 変数です。

	$MailBody	$Reply_to
	%Envelope	*_cf

	例外： *_cf は システム情報をもっている名前空間です。

   %Envelope は最も重要な変数です。
   しかしながら、こういう変数は本来出来るだけ少なくするべきです。

○ 小文字は基本的にlocal Variableで、大抵はsubroutineの先頭でlocal宣言
   されています。


○ 補足
なお、Directory を定義する $*_DIR タイプの変数には

	$*_DIR 		$DIR からの相対パス
	$FP_*_DIR 	絶対パス

の２種類があります。 $FP_*_DIR タイプの変数は自動的に変換され定義され
ます。基本的には絶対パスが使われます。

	$FP_TMP_DIR
	$FP_VARDB_DIR
	$FP_VARLOG_DIR
	$FP_VARRUN_DIR
	$FP_VAR_DIR
    	$FP_SPOOL_DIR
.k	$FP_TMP_DIR
.k	$FP_VARDB_DIR
.k	$FP_VARLOG_DIR
.k	$FP_VARRUN_DIR
.k	$FP_VAR_DIR
.k    	$FP_SPOOL_DIR


.S	subroutine 名の Naming Convention
.k	subroutine 名の Naming Convention

例外を除いて
    ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語
です。

基本的に subroutine の名前はX11風だったりします。最近のはlisp風味も混
ざってます:-) #おおむねX11風ですね

○ fml 1.5 以降では若干例外があります。

ファイル操作をする関数で

	変換インターフェイスとしての 	f_関数 名
	＃いつか、なくなるだろう

		と 

	そのモードのコンストラクタ	Cnstr_関数 名
	そのモードのディストラクタ	Destr_関数 名

が例外です。「将来 replace するべきです」と当時言ったまま replace され
ないままですが:-)


.S	%Envelope
.k	%Envelope
.k	struct envelope e;


sendmail の struct envelople e; に対応するものです。
しかし、perl 4 を本来ターゲットにしているため

	$Envelope->$Header->$From = "uja@domain";

のような使い方はしません（できない）。
これと同様のことを意図したシンタックスが

	$Envelope{"h:From:"}  = "uja@domain";

で表現されています。 h = header で From: はわざとFieldだとわかりやすい
ように : まで含めています。

   %Envelope
	ヘッダの各フィールドデータ

	h:Capital:	補正されたデータ
	h:lower-case:	オリジナルデータ

   例：
	h:From: は配送されるヘッダ中に現れるフィールドです  
	
    $e{'h:Return-Path:'} = "<$MAINTAINER>";        # needed?
    $e{'h:Date:'}        = $MailDate;
    $e{'h:To:'}          = "$MAIL_LIST $ML_FN";    # rewrite To:
    $e{'h:Posted:'}      = $e{'h:date:'} || $MailDate;
    $e{'h:Precedence:'}  = $PRECEDENCE || 'list';
    $e{'h:Lines:'}       = $e{'nlines'};









.C	Security 

.S	Security Check Routine
.l	InSecureP
.k	InSecureP
.k	SecureP

ファイアウォールでも同様ですが、概念的に２種類の考え方が出来ます。

	1 明らかに危ないものを除いていく
	2 安全なものを許可していってそれ以外は拒否する

fml-support: 00950 でも述べていますが

	1.x は外掘から埋める方式 (関数 InSecureP)
	2.y は内掘から埋める方式 (関数 SecureP)

といってます(^^)。1.x と 2.y の関係はそのまま 上の 1 と 2 の違いといっ
て間違いありません。


SecureP は以下のように

   コマンドとしてうけいれる命令(メールの一行全体について実行)の形を限定

します。

    １ 	\w/\w の部分は見逃す。＃ ../ とか .[a.]/ とかはだ〜め
       	/ でOKのところは消去し、

    ２ 	/^[\#\s\w\-\[\]\?\*\.\,\@\:]+$/

    の形はゆるす。
    ＃注意： \w は [A-Za-z0-9_] なので、 "-" を加えた

    ３ 	これ以外を含んでいたらエラー

    ４ 	特殊なケース（admin コマンドの admin addr m=3) は
	事前に例外処理をした後 &SecureP にまわす。
	

例：	許される例

   # summary
   # mget 1-20,30,last:20 mp 1
   # mget 10? mp 1			(default では許さない)
   # mget 1[012]? mp 1			(default では許さない)
   # chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp 


例：	許されない例
   # mget `domainname`


例外処理として：

   # whois 日本語

をどうしよう？という問題があります。今のところ”通さない”設定のままで
すが、これはこれで何とかするべき問題なのですが、良い解決策はありません。
.k	whoisと日本語の問題


.S	DNS Spoofing
.l	DNS Spoofing
.k	$LOG_CONNECTION
.k	$PeerAddr

デフォールトでは何もしていませんが、

	$LOG_CONNECTION = 1;

コネクションを張ってきた相手先のIPアドレスを $PeerAddr に設定します。
Gauntlet(firewall) 越しだったりすると無意味ですが…

$PeerAddr を使って DNS Spoofing Check コードをHOOK掛ければよいでしょう。


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996      fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
