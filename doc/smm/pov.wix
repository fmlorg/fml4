.C	fml のプロセス
.k	fml process
.l	fml-process

ＭＬサーバの基本動作を知っておくとカスタマイズの時役にたちます。


.S	ＭＬサーバの動作 (fml と sendmail の役割分担)
.key	ＭＬサーバの動作
.l	ml-process

   メールが SMTP で送られてくる

             ↓

   SMTP で待ち構えているプログラムがうけとる (例: sendmail)

             ↓

   /etc/aliases から何をすれば良いのかを理解して、
   setuid 操作等を行なった後 fml.pl の STDIN にメールが送り込まれる。

             ↓

   (sendmail -> fml.pl へ引き渡される。ここからが FML の担当)
   config.ph による設定に従い、ヘッダの解析、ＭＬメンバーのリストに従い
   配送 or コマンド要求を処理した結果のメールを配送リストと共に
   sendmail 等のSMTPサーバへ引き渡す

             ↓

   (ここから再び sendmail の担当)
   sendmail 等のSMTPサーバがメールの配送を行なう。


フィルタだけなら sed でも十分だし"配るだけ"なら Sendmail 8.x でも十分
でしょう。しかし、+αでログをとり、スプールし、必要なら取り寄せられる
ようにちょこっとだけ複雑なことをしようとするならこのサーバ まで必要と
なるというわけです。

なおこの図でわかるとおり、まとめおくりはこれとは"全く別の"プロセスです。
まとめおくりは自動的に作動するわけではありません。
.xref msend

まとめおくりとは、一定時間ごとにスプールされたＭＬの記事を送ってあげる
"別のプロセス"です。このプロセスは別の仕掛けで定期的に実行されなければ
なりません。


.S	sendmail -> fml 時の動作
.k	sendmail -> fml 時の動作
.l	sendmail2fml

sendmail から fml.pl へメールが渡される時は次のように動作します。

○ まず /etc/aliases にある

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で sendmail はこのファイルを実行します。

	/usr/local/list/Elena
の中身は
	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

のようになっています。

次に fml が上の引数は /var/spool/ml/elena を Elena ML の HOME だと見な
し /var/spool/ml/elena/config.ph に従い fml の設定を行います。

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは /usr/local/list/Elena の中で

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena --ctladdr "

のように書きます(コマンドラインオプションについては Chapter .ptr{clo})。

引数の書き方の順番は任意です。引数の最初の directory を ML の HOME
(config.phのある場所 もしくは spool やメンバーファイルのある場所) と見
なします。


.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)
.k	fml.plと引数
.k	$DIR
.k	$LIBDIR

	/usr/libexec/fml/fml.pl /var/spool/ml/elena

のように起動されるわけですが、この場合

	/usr/libexec/fml/fml.pl 
の
	/usr/libexec/fml 

部分をとりだします。そして

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた(複数可能)場合、例えば

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 
	3   /usr/lib/uja
	4   /lib/uja

のような順番でファイルを探します。


.S	オプション設定の優先順位
.l	order-of-option-effeciency
.k	オプション設定の優先順位

オプション設定の強い順番に並べると

	1   コマンドラインオプション (fml.pl -d や fml.pl --ctladdr 等)
	    なおコマンドラインオプションについては Chapter .ptr{clo}。
	2   sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3   各MLごとの config.ph による設定
	4   site_init.ph によるデフォールト設定	
	5   fml デフォールト設定
.l	site_init.ph
.l	sitedef.ph
.k	site_init.ph
.k	sitedef.ph

普通の program と同様ですね。ＭＬごとではなくそのマシン共通の設定にな
るもの

	tar や gzip はどこにある？

等を sitedef.ph に書くと便利でしょう。

site_init.ph は各MLの config.ph の前に評価されデフォールトを決めます。
sitedef.ph は各MLの config.ph の評価後に適用され、各ＭＬの設定を強制的
に書き換えることもできます。それぞれ使いわけると良いでしょう。いずれに
しろ config.ph にない変数であればどちらを使っても同じことです。



.S	fmlのプロセス(STDINからの読み込みの第一段階)
.l	STDIN->fml

STDIN からの読み込みは第壱段階でハッシュテーブル %Envelope
.xref	%Envelope
.k	$Envelope{'Header'}
.k	$Envelope{'Body'}
.k	メールのヘッダ
.k	メールのボディ

	ヘッダ	$Envelope{'Header'}
	ボディ	$Envelope{'Body'}

に保存されます。この時ボディ(メールの本文)に対しては次のようなチェック
がなされます。

○ 最初の $GUIDE_CHECK_LIMIT 行に対して $GUIDE_KEYWORD のキーワードが
現れるか否か？
メンバー以外からのメールでこのキーワードをキャッチした場合は、ガイドを
送り返してそれ以外のことはしない。
.k	$GUIDE_CHECK_LIMIT
.k	$GUIDE_KEYWORD

○ 最初の $COMMAND_CHECK_LIMIT 行に対して
.k	$COMMAND_CHECK_LIMIT
.k	$CHADDR_KEYWORD

	# で始まり、英文字が続く行 (\s*\w+\s|^\#\s*\w+)

	# で始まり、$CHADDR_KEYWORD のキーワード
	が現れる行があるか否か？あった場合はコマンドモードへ移行。

の2つのチェックをしています。それぞれの LIMIT を調節すると、つまり 
LIMIT を 0にすればチェックをしないということになるし、全文すべてをコマ
ンドの対象にすることもできます。デフォールトではそれぞれ最初の3行のみ
を対象にしています。

なお、それぞれのキーワードデフォールトは次のように設定されています。

	$GUIDE_KEYWORD  = "guide";
	$CHADDR_KEYWORD = "chaddr|change-address|change";


.S	fmlのプロセス(第２段階, %Envelopeの処理)

%Envelope にヘッダとボディを読み込んだ後はヘッダの解析プロセスが続きま
す。詳細については次の章を見て下さい。
.xref	%Envelope
.xref	header-custom

この後ロックして、メインのプロセスが続くことになります。


.S	fml process の lock と signal handling 
.k	$Sigarlm
.k	$TimeOut{'flock'}
.k	$FLOCK_TIMEOUT(Obsolete)
.k	$MAX_TIMEOUT

現在の flock を使うロックアルゴリズムは次のように設定されています。
flock(2) と alarm(3) によるTIMEOUT処理による一般的な方法です。 

sub Flock {

    &SetEvent($TimeOut{'flock'} || 3600, 'TimeOut') if $HAS_ALARM;
	...

TIMEOUTを待つ時間は $TimeOut{'flock'} で決まります。(flock でない場合
は 3秒+α 程度の sleep を $MAX_TIMEOUT 回して待ってみる)

    # signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'}  = $SIG{'QUIT'} = 'SignalLog';

$TimeOut{'flock'} (デフォールトは3600秒)後 $SIG{'ALRM'} で定義された関
数(TimeOut)を実行します。

関数 TimeOut は管理者へ TIMEOUT を知らせ、ログを残しfmlを終了します。
これがないとずっとロック(flock)がかかったままになるからです。

なお flock を使わない時はTIMEOUTしたメールを保存し管理者へ TIMEOUT を
知らせます。詳細は liblock.pl を見るとわかるでしょう。
.xref	books


.S	イベント・スケジューラ
.k	SetEvent
.k	ClearEvent
.k	Tick

TIMEOUT 等は現在実行している処理内容によらず特定の時間が来たら (割り込
んで) 実行する必要がありますがそれは伝統の味 alarm(3) を使って実装しま
す。なお Windows NT 4.0 Version では alarm(3) が使えないのこの処理は実
行されません。


.S	ロックの仕方(flock でない場合)
.l	how-to-lock
.k	ロックアルゴリズム
.xref	fml-mechanism, seq-file

ロックアルゴリズムは二通り用意されてます。flockがお奨めです。flock(2) 
参照

.key	$USE_FLOCK
	$USE_FLOCK    = 1;

で flock system call

	$USE_FLOCK    = 0;

で Unix V7 時代からある link(2) を使う方式を使います。この方式はロック
するファイルへの link() ができるか否か?を排他制御に使います。このロッ
クするファイルは $LockFile で、

	$LOCK_FILE

という変数で変更できます。デフォールトは

	"$FP_VARRUN_DIR/lockfile.v7"

つまり ML の home の下の var/run/lockfile.v7 です。この方式の問題は OS 
がいきなり落ちた時にこのファイルが残ってしまうので手動でこのファイル群
を消さなければならないという点が最大の問題点です。そのため flock() が
望ましいということになります。

そういう場合は reboot 直後に

	"$FP_VARRUN_DIR/lockfile.v7"
	"$FP_VARRUN_DIR/lockfile.数字"
.k	$FP_VARRUN_DIR/lockfile.v7

すべてを消して下さい。数字はプロセス番号ですから、プロセステーブルを見
て(ps(1))、該当する数字(fml の process)がなければ、そのファイルは消し
て良いです。

なお通常は $MAX_TIMEOUT 秒後、var/log/ の下にTIMEOUTしたメールは保存さ
れ、管理者へTIMEOUTが通知されます。

[捕捉]	flock(2) を見れば分かりますが 
.k	flock(2)
.k	$LOCK_SH
.k	$LOCK_EX
.k	$LOCK_NB
.k	$LOCK_UN

	$LOCK_SH                       = 1;
	$LOCK_EX                       = 2;
	$LOCK_NB                       = 4;
	$LOCK_UN                       = 8;
.q
     #include <sys/file.h>
     #define   LOCK_SH   1    /* shared lock */
     #define   LOCK_EX   2    /* exclusive lock */
     #define   LOCK_NB   4    /* don't block when locking */
     #define   LOCK_UN   8    /* unlock */

     int
     flock(int fd, int operation)
.~q

排他制御については例えば A. S. Tanenbaum, "Modern Operating Systems"



.include clo.wix

 
.C	fml 内部におけるデータ構造
.l	data-structure
.xref	hack


ここでは fml 内部処理におけるデータ構造について解説します。これらの知
識は改造する上で必須の事柄でしょうが、単に変数を 1 or 0 にセットするだ
けしか設定 (config.ph) をいじらないなら読む必要はないでしょう。


.S	変数名の Naming Convention
.key	変数の Naming Convention


○ 大文字（[A-Z0-9_]+）だけの塊はユーザーのカスタマイズで使う目的の
   Global 変数です。

	例：	$ML_MEMBER_CHECK

○ "1単語の先頭一文字が大文字、残りは小文字"の塊からなる単語はメー
   ル本体やヘッダをSubroutine間で渡しあうための Global 変数です。

	$MailBody	$Reply_to
	%Envelope	*_cf

	例外： *_cf は システム情報をもっている名前空間です。

   %Envelope は最も重要な変数です。
   しかしながら、こういう変数は本来出来るだけ少なくするべきです。
   また、@Fld にように現在そうは使われていないのに名残として残ってしまっ
   ているものもあります。

   注意：
	全部小文字でグローバル変数という例外が歴史的に２つあります。
	$debug と $rcsid です。歴史的にそうなっているというだけなので
	今後そういう変数名は作られることはありません。
	また、昔ユーザ定義で今は内部変数扱いになった $ML_MEMBER_CHECK も
	例外です。

○ 小文字は基本的にlocal variableで、大抵はsubroutineの先頭でlocal宣言
   されています。

○ 補足
なお、Directory を定義する $*_DIR タイプの変数には

	$*_DIR 		$DIR からの相対パス
	$FP_*_DIR 	絶対パス

の２種類があります。 $FP_*_DIR タイプの変数は自動的に変換され定義され
ます。基本的には絶対パスが使われます。$FP_ の変数は fml.pl の初期化で
自動的に補正されつつ設定されます。

	$FP_TMP_DIR
	$FP_VARDB_DIR
	$FP_VARLOG_DIR
	$FP_VARRUN_DIR
	$FP_VAR_DIR
    	$FP_SPOOL_DIR
.k	$FP_TMP_DIR
.k	$FP_VARDB_DIR
.k	$FP_VARLOG_DIR
.k	$FP_VARRUN_DIR
.k	$FP_VAR_DIR
.k    	$FP_SPOOL_DIR


.S	関数名の Naming Convention
.k	関数名の Naming Convention

例外を除いて
    ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語
です。

基本的に subroutine の名前はX11風だったりします。最近のはlisp風味も混
ざってます:-) #おおむねX11風ですね

○ fml 1.5 以降では若干例外があります。

ファイル操作をする関数で

	変換インターフェイスとしての 	f_関数 名
	＃いつか、なくなるだろう

		と 

	そのモードのコンストラクタ	Cnstr_関数 名
	そのモードのディストラクタ	Destr_関数 名

が例外です。「将来 replace するべきです」と当時言ったまま replace され
ないままですが:-)


.S	%Envelope (ハッシュテーブル)
.l	%Envelope
.k	%Envelope
.k	struct envelope e;


%Envelope には今 fml を起動したメールの内容(ヘッダ、ヘッダの各フィール
ド、本文等)が格納されます。また、そのメールに対しどういうMETHODでREPLY
を返すべきか？や、sendmail との通信等の設定に関しての付加情報も 
%Envelope を通じて渡されます。それはこのメールに対する METHOD の定義と
みなしているからです。

sendmail の struct envelope e; に対応するものです。
しかし、perl 4 を本来ターゲットにしているため

	$Envelope->$Header->$From = "uja@domain";

のような使い方はしません(できない)。これと同様のことを意図したシンタッ
クスが

	$Envelope{"h:From:"}  = "uja@domain";

で表現されています。 h = header で From: はわざと Field だとわかりやす
いように : まで含めています。

以下 %EnvelopeのKEYについて説明します。
＃ハッシュなので、KEY => VALUE が $Envelope{KEY} の値が VALUE です

	h: ではじまるものKEYは「ヘッダの各フィールドのデータ」です。

	h:Capital:	補正されたデータ
	h:lower-case:	オリジナルデータ

	それ以外に その Envelope のメールをどういうモードで処理するか？
	や、そのメールへのREPLY、エラーレポート処理をどうするか？
	というMETHODの指定等の付加情報も付け加えることもあります。

	[ヘッダ関係]

	h:field:	上述のヘッダ：フィールド：設定値

	fh:field:	field(小文字) は fml.pl がある値を強制する

			例： fh:to: は To: を $Envelope{'fh:to:'} の値にする

	oh:field:	field は original のヘッダフィールドを使う

	GH:field:	コマンドの結果を返すメールは GenerateHeader() という
			ルーチンでメールヘッダを生成する。
			そこでの値を変更したいならこのKEYを使う。

	Addr2Reply:	コマンドの結果の返事を返すアドレス
			reply-to: > From:

	[メールが呼び出すべきモードやメソッドのConfig]

	macro:x		x は sendmail の $x に対応する内容を保存

	mode:x		モード設定値 

	mci:mailer	mci は Mail Connection Information (MCI)
			mci:mailer は ipc(SMTP) か prog(exec sendmail)
			のどちらかである

	[内部表現]

	Header		オリジナルのヘッダ
	Body		オリジナルのメール本文
	Hdr		送り出すメールのヘッダ（&Smtpの直前に生成される）

	message		メールをサーバへ送ったユーザへのメッセージ
	error		管理者への(エラー)メッセージ

	MIME		ISO-2022-JP is detected (toggle Flag)
	UnixFrom	Unix From
	Hdr2add		$SUPERFLUOUS_HEADER の時につかうバッファ
	nclines		# command の行数
	nlines		メール本文の行数
	preamble	メール本文の前につける文章
	trailer		メール本文の後につける文章


   例: Subject:

    $Envelope{'h:subject:'}	
	は来たメールそのもの

    $Envelope{'h:Subject:'}	
	は来たメールの Re: をとり
	必要なら [Elena 100] のようなものを処理したもの

   のような違いがある。	配送されるヘッダと大文字ではじまる単語
   は次のように対応する

   配送メールのヘッダ	%Envelope
	Date: 		h:Date:
	From:		h:From:
	To: 		h:To:
	Subject: 	h:Subject:


.S	データ構造の初期化
.l	init-data-structure
.k	データ構造の初期化

各データの初期化は次の順序で行なわれる。

	$DIR $LIBDIR @INC の初期化

	&InitConfig
	   &SetDefaults
		%Envelope
		DNS 設定
		各種設定
		@HdrFieldsOrder

	   &LoadConfig
		$DIR/config.ph
		sitedef.ph

   	   &SetOpts
		コマンドリンオプションの評価

	   COMPATIBILITY CODE
   
	&Parse
		%Envelope へ Header Body 等のオリジナルデータをセット
		
	&GetFieldsFromHeader
		%Envelope へ h:field: および h:Field: をセット

	&FixHeaderFields
		h:Field: への各種補正を行なう

	&CheckCurrentProc
		%Envelope による設定、動作モードチェック

	この後各種フックがそれぞれの場所で評価される。
	例：
		$START_HOOK
		$SMTP_OPEN_HOOK
		$FML_EXIT_HOOK


.S	ディレクトリ変数
=E.S	Directory variables
.xref	fml-process

起動時の一番最初の段階では $DIR $LIBDIR @INC という変数の設定を筆頭に
各種変数の初期化が行なわれます（上述）。

$DIR $LIBDIR @INC が起動時にどう評価され使われているかは
「fml の基本動作と起動オプション…」の章を見ると分かるでしょう。
.xref	fml-process

以下では DIRECTORY 一覧を示します。
		
	@INC	(参考)
		これは Perl の include file の search path
		$DIR @INC(original) $LIBDIR ...
		の順番に探される。

	$DIR
		config.phのある場所、いわゆるMLのHOME	
		@INC の先頭に設定される

	$LIBDIR	

		fml.pl や libsmtp.pl 等の置き場所。
		$DIR と同じでも良いし、別の場所で保守されていてもよい。
		もともと複数のＭＬを扱うためにスプールと *.pl ファイル
		群の置き場所をわけるために導入された。@INC の最後に入る。

		なおコマンドラインに出てくるdirectoryはすべて @INC に
		設定されるが、$DIR の直後の directory が $LIBDIR に設
		定される。

    	$SPOOL_DIR		$DIR/spool
		ＭＬの記事を格納する場所


	[$DIRからの相対パスで設定されるもの]
	$TMP_DIR		tmp (temporary)	4.4BSD の /tmp
	$VARDB_DIR		4.4BSD の /var/db (データベース)
	$VARLOG_DIR		4.4BSD の /var/log に対応 ログが置かれる
				backward compat のため
				log 等のデフォールトは $DIR/log のままである
				本来は $VARLOG_DIR/log が望ましい

	$VARRUN_DIR		4.4BSD の /var/run pid-file 等はここ
				なお cache もここにおいている。
	$VAR_DIR		4.4BSD の /var

	[FULL PATH 化された変数]
	$FP_TMP_DIR		$DIR/$TMP_DIR
	$FP_VARDB_DIR		$DIR/$VARDB_DIR
	$FP_VARLOG_DIR		$DIR/$VARLOG_DIR
	$FP_VARRUN_DIR		$DIR/$VARRUN_DIR
	$FP_VAR_DIR		$DIR/$VAR_DIR
    	$FP_SPOOL_DIR		$DIR/$SPOOL_DIR


.S	$TMP_DIR について
.key	$TMP_DIR

ＭＬサーバの作業エリアにはデフォールトでは $DIR/tmp (つまり $TMP_DIR =
'./tmp';) を使います。変更したい場合は $TMP_DIR を変更して下さい。

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。
private communication のファイルを public な場所にファイルを残すことは
しないためです。

その他にも 4.4BSD 風の directory 構造の中に各種のログやキャッシュが保
存されます。


.S	設定ファイル群
.xref	fml-file-structure

[メンバーのリスト関係]

	$MEMBER_LIST 	 	$DIR/members
.l	$MEMBER_LIST
.k	$MEMBER_LIST
		メンバーリスト(認証のみに使う)
.xref	fml-file-structure

	$ACTIVE_LIST 		$DIR/actives
.l	$ACTIVE_LIST
.k	$ACTIVE_LIST
		ＭＬの配送リスト
.xref	fml-file-structure


	$REJECT_ADDR_LIST	$DIR/spamlist
.k	$REJECT_ADDR_LIST
.xref	$REJECT_ADDR_LIST

投稿・コマンド・自動登録を始め弾きたいアドレスのリストを入れる。


[各種の説明、ご案内関係のファイル]

	$OBJECTIVE_FILE	 	$DIR/objective
.l	$OBJECTIVE_FILE
.k	$OBJECTIVE_FILE
		ＭＬの目的を書いたファイル

	$GUIDE_FILE		$DIR/guide
.l	$GUIDE_FILE
.k	$GUIDE_FILE
		ＭＬの一般向けご案内（ガイド）

	$HELP_FILE	 	$DIR/help
.l	$HELP_FILE
.k	$HELP_FILE
		ＭＬのHELP、コマンドの解説等

	$DENY_FILE	 	$DIR/deny
.l	$DENY_FILE
.k	$DENY_FILE
		ＭＬがメンバーチェックをしている時
		メンバー以外からメールが来た時に返す断りの文章
		
	$WELCOME_FILE	 	$DIR/guide
.l	$WELCOME_FILE
.k	$WELCOME_FILE
.xref	auto-regist
		ＭＬが自動登録の時、登録時に送ってあげる文章
		デフォールトではとりあえずガイドと同じになっている。

	$CONFIRMATION_FILE       $DIR/confirm
.l	$CONFIRMATION_FILE
.k	$CONFIRMATION_FILE
.xref	confirmation
		自動登録で confirmation モードの際
		reply を返す confirmation の説明のファイル


[ログファイル関係]

	$LOGFILE	 	$DIR/log
.l	$LOGFILE
.k	$LOGFILE
		ログ

	$MGET_LOGFILE    	$DIR/log
.l	$MGET_LOGFILE
.k	$MGET_LOGFILE
		mgetのログ。デフォールトでは↑ログファイルと同じ
.xref	mget
	
	$SMTPLOG		$VARLOG_DIR/_smtplog
.l	$SMTPLOG
.k	$SMTPLOG
.l	$VARLOG_DIR/_smtplog
.k	$VARLOG_DIR/_smtplog
		プロセス間通信(SMTP)のログ(デバッグの役に立つ)

	$SUMMARY_FILE 	 	$DIR/summary	
.l	$SUMMARY_FILE
.k	$SUMMARY_FILE
		MLの記事のサマリ

	$SEQUENCE_FILE 	 	$DIR/seq
.l	$SEQUENCE_FILE
.k	$SEQUENCE_FILE
		MLの記事番号

	$MSEND_RC		$VARLOG_DIR/msendrc
.l	$MSEND_RC
.k	$MSEND_RC
		まとめおくりの制御ファイル
.xref	msend

	$LOCK_FILE	 	$VARRUN_DIR/lockfile.v7
.l	$LOCK_FILE
.k	$LOCK_FILE
		flock() を使わない時のロックで使うファイル

	$LOG_MESSAGE_ID		$VARRUN_DIR/msgidcache
.l	$LOG_MESSAGE_ID
.k	$LOG_MESSAGE_ID
		message-id cache ファイル
		(ML自身での無限ループを防ぐためのキャッシュ)

	$INDEX_FILE		$DIR/index (なくても構わない)
.l	$INDEX_FILE
.k	$INDEX_FILE
		indexコマンドで表示したい内容を書く
		このファイルがない場合はその場でMLのHOME内容を調べて
		返す


.S	単に便利なためにある変数

	$DO_NOTHING
.l	$DO_NOTHING
.k	$DO_NOTHING

	何もしないという分岐をするための変数。特殊なサーバを作る時や
	特別なHOOKをかけたりする場合に有用である。

	$NULL
.l	$NULL
.k	$NULL
		ダミー:-) ＃ 別にこんな変数いらない 
		#define null (char *)0 みたいなものだと思ってもらえば良い

	$FML	
.l	$FML	
.k	$FML	
		カーネル内のプロセステーブルを書き変える際に使う変数

	$FACE_MARK	（単なる愛敬:-）
.l	$FACE_MARK
.k	$FACE_MARK
		各種リクエストの結果を返す時にお別れの文章の腋につける
		e.g. P(^^)
			Be seeing you P(^^)

		のようになる。		 

	$INCLUDE_SIM_PATH
.l	$INCLUDE_SIM_PATH
.k	$INCLUDE_SIM_PATH

	Simulation で使う。気にしないで下さい:)


○ 古い変数として他の名前に置き換えられたもの
.k	$GUIDE_REQUEST
.k	$RPG_ML_FORM_FLAG

   $GUIDE_REQUEST	-> $GuideRequest
   $RPG_ML_FORM_FLAG	-> $COMMAND_SYNTAX_EXTENSION

○ obsolete なもの
   $NON_PORTABILITY


.S	内部で使われている変数を調べるには？
.k	$DUMPVAR
.k	dumpvar.pl

config.ph で 

	$DUMPVAR = 1;

やコマンドラインで

	fml.pl --DUMPVAR 引数

として fml を呼び出すと全ての変数を dump します。この場合はPerlについ
てくる dumpvar.pl ライブラリを利用し、名前空間から変数リストを引っ張り
出しています。

ちなみに fmlserv.pl は同様のやり方で名前空間の switch を利用して複数の
ＭＬを疑似的に実行しています。



.C	fml 設定ファイルのフォーマットと構造
.l	fml-file-structure
.k	fml 設定ファイルのフォーマットと構造

fml の設定ファイル、メンバーリストは基本的に shell like な構造で記述さ
れていると期待されています。つまり基本的に # ではじまる行はコメント、
空行は飛ばす等の挙動を各ルーチンはしています。

以下では各設定ファイルのフォーマットについて言及します。


.S	members ファイルのフォーマットと構造
.k	members ファイルのフォーマットと構造

$MEMBER_LIST (default members) で定義されるファイルは

	#.FML
		…fml がつけるコメント…
	#.endFML
	アドレス1
	アドレス2
	# アドレス3
	##BYE アドレス4
	アドレス5

のような形をしています。歴史的理由により現在では

   # の後空白 でコメントアウトされているものもメンバーチェックの対象
   ## ではじまるところはコメント

となっています。よって上の例では ##BYE の行は無視されますが、それ以外
の アドレス1 〜 アドレス5 (4を除いて) すべてがメンバーチェックの際には
対象となります。


［歴史］
この動作は 1.2 release version の直後、自動登録を拡張する際に導入され
ました。またこの導入のため # off と # skip はどう違う？という疑問がそ
の後生まれることになりました。

なおメンバーファイルとしては各行のアドレスより後ろの部分は
何にも使われていませんので、勝手に使って構いません。

しかしながら、自動登録の場合は $MEMBER_LIST と $ACTIVE_LIST は同じもの
（$MEMBER_LIST）が使われます。よってそのフォーマットは $ACTIVE_LIST 形
式であると仮定する必要があります。


.S	actives ファイルのフォーマットと構造
.k	actives ファイルのフォーマットと構造

$ACTIVE_LIST (default members) で定義されるファイルは ＄MEMBER_LIST と
同様の構造を持ちます。

しかし actives ファイルは拡張された表現として各アドレスのオプションを
行の残りの部分に持つことができます。

	アドレス	オプション	# コメント

	注意：なお、それぞれの↑ブロックの間には必ず一つ以上の SPACE
	か TAB があると仮定しています。

よって勝手に何かを書いた場合オプションとみなされます。付加情報は # コ
メント として行の最後にでも書いて下さい。この辺は shell と同じです。

オプションは V1 と V2 フォーマットがあります。

   V1 フォーマットは

	数字(フォーマット)	まとめおくりの指定
	数字以外		リレーサーバ

   V2 フォーマットでは将来の拡張のため

	m=まとめ送り指定
	r=リレーサーバ
	s=1(skip を意味する)

のように alphabet=option-value の形で定義されています。現在のところこ
れ以外のキーワードは将来のために予約されています。

現在のルーチンは V2 のみを理解します。よって V1 -> V2 に変換する必要が
あります。この変換は

	libfml.pl で ChangeMemberList が呼ばれた時

つまりメンバーリスト等へのなんらかの変更を行なう時に自動的に行なわれま
す。


.S	actives と members の違い
.k	actives と members の違い

フォーマット的には上述の通りです。後は自動登録の章で述べられている通り
members はメンバーであるか否か？の認証、 actives は配送リストです。

自動登録では members 一つを認証と配送リスト両方に使っています。
そのため表現の拡張が必要だったわけです。


.S	複数のメンバーリスト、複数の配送リスト
.l	@ACTIVE_LIST
.l	@MEMBER_LIST
.k	@ACTIVE_LIST
.k	@MEMBER_LIST

	@ACTIVE_LIST	複数の配送リスト

	@MEMBER_LIST	複数のメンバーリスト

を定義できます。地方ごととか組織ごとにリストを管理するのに便利かも知れ
ません。

デフォールトでは @ACTIVE_LIST は使われていません。@MEMBER_LIST は 
members と members-admin です。

歴史: 最初に管理者を設定して後はリモートですべてをおこなうという目的の
ために拡張されました。


.S	msendrc ファイルのフォーマットと構造
.k	msednrc ファイルのフォーマットと構造

msendrc は $MSEND_RC で定められる場所におかれます。そのフォーマットは

	アドレス	次回に送る最初の記事番号

です。msednrc は msend.pl が制御するログファイルです。
msend.pl は $ACTIVE_LIST を見て、

	・あるアドレスがまとめ送りになった
		そのアドレスのエントリを msendrc 内に新しく作る

	・あるアドレスがまとめ送りで”なくなった”
		そのアドレスのエントリを消去

	・まとめおくりを配送した
		次回に送る最初の記事番号を msendrc に記録する		

ということを msendrc に対して行ないます。
また、msend.pl 以外のプログラムが msendrc をいじることはありません。


.S	パスワードファイルのフォーマットと構造
.k	パスワードファイルのフォーマットと構造
.l	etc/passwd
.xref	bin/passwd.pl remote
.k	$PASSWD_FILE
.k	$DIR/etc/passwd

パスワードを保存しているファイルは通常 etc/passwd に置かれています。

	$PASSWD_FILE (default "$DIR/etc/passwd") 

で定められます。フォーマットは

	アドレス	cryptされたパスワード

です。つまり UNIX 伝統のパスワードファイル形式の先頭の部分です。
＃crypt(3) についてはマニュアル参照

.xref	$REMOTE_ADMINISTRATION_AUTH_TYPE

	$REMOTE_ADMINISTRATION_AUTH_TYPE = "md5";

と設定されている時は fml.pl の crypt 関数は crypt(3) ではなく MD5 の値
を返すようになります。これは MD5.pm を用いた実装なので perl 5 であるこ
とと MD5-1.7.tar.gz のインストールが必要です。MD5-1.7 は fml の 
directory に一緒に置いてあります。

これらの cryptography はＭＬサーバのリモート管理で使われます。
.xref	remote

あるアドレスをこのファイルへ登録する時などは bin/passwd.pl を使うと良
いでしょう。
＃また、admin コマンドには initpass という初期化コマンドもあります。


.S	fml インストール後の maintenance と version up に関して
.l	fml-maintenance
.k	How to maintain the installed fml source
.k	インストール後のメインテナンスとversion up
.k	version up
.k	maintenance

上述のデータ構造とファイルの扱いを考慮した場合、インストール後の
version up や maintenance に便利な形は次のようなものだと思っています。
＃僕はこんな感じにやってます。

version up は基本的に 
	cp -p fml-source/src/*.pl your-directory 
です。
＃以下 $HOME は適当に各自の環境に合わせて展開して考えて下さいね

	$HOME/libexec/fml/ に *.pl を全部いれておく

また、ＭＬのスプールを

	$HOME/w/spool/fml-support
	$HOME/w/spool/foreign-tv-ml

のように作っておく。config.ph や spool としてＭＬの記事の保存場所はこ
こです。よって、include は

	"|$HOME/libexec/fml/fml.pl $HOME/w/spool/fml-support"

のようなファイルを /etc/aliases から呼び出します。僕はＭＬ用には
$HOME/etc/aliases を使ってたりしますが:-)
＃ sendmail.cf は O AliasFile=/etc/aliases, それ以外のaliasファイル
.k	sendmail.cf
.k	O AliasFile=...

version up の仕方は、例えば次のようになるでしょう。

	% cd /var/tmp
	% tar zxvf fml-current.tar.gz
	% cd fml-version番号他の名前
	% make install

ML のHOME はいじらないので、config.ph 等は問題ありません。fml.pl を筆
頭に lib*pl 群は overwrite されますから自分でいじってしまっている場合
は一旦バックアップを取っておくことが必要です。

maintenance は コマンドのパスやＭＬ全体共通の設定は

	$HOME/libexec/fml/sitedef.ph 
.k	sitedef.ph 

で行ない各ＭＬごとの設定は

	$HOME/w/spool/fml-support/config.ph 
.k	config.ph 

で制御する。



.C	Security 
.l	security


.S	Security 関係の基本思想

基本的に

   1	デフォールトではすべてを認めない
   2	大丈夫と思われるものを通すようにする
   3	疑わしきものははじいて判断をＭＬの管理者へあおぐ

という風に構成されています。


.S	Security Check Routine
.l	SecureP
.l	InSecureP
.k	InSecureP
.k	SecureP

ファイアウォールでも同様ですが、概念的に２種類の考え方が出来ます。

	1 明らかに危ないものを除いていく
	2 安全なものを許可していってそれ以外は拒否する

fml-support: 00950 でも述べていますが

	1.x は外掘から埋める方式 (関数 InSecureP)
	2.y は内掘から埋める方式 (関数 SecureP)

といってます(^^)。1.x と 2.y の関係はそのまま 上の 1 と 2 の違いといっ
て間違いありません。

SecureP は以下のように

   コマンドとしてうけいれる命令(メールの一行全体について実行)の形を限定

します。

    １ 	\w/\w の部分は見逃す。＃ ../ とか .[a.]/ とかはだ〜め
       	/ でOKのところは消去する
	また、まとめ送り等の m=数字 等の特別なシンタックスは消去する。

    ２ 	/^[\#\s\w\-\[\]\?\*\.\,\@\:]+$/

    の形はゆるす。
    ＃注意： \w は [A-Za-z0-9_] なので、 "-" を加えた

    [Extension]
	ユーザの拡張用に %SECURE_REGEXP というハッシュが用意されています。
	このハッシュ(KEYは適当でよい)のいずれかの正規表現
	にマッチしたら、ＯＫになるように動きます。
	これは YOUR OWN RISK で定義して下さい。
.l	%SECURE_REGEXP
.k	%SECURE_REGEXP
.k	SecurePの拡張: %SECURE_REGEXP

    ３ 	これ以外を含んでいたらエラー

    ４ 	特殊なケース（admin コマンドの admin addr m=3) は
	事前に例外処理をした後 &SecureP にまわす。


例：	許される例

   # summary
   # mget 1-20,30,last:20 mp 1
   # mget 10? mp 1			(default では許さない)
   # mget 1[012]? mp 1			(default では許さない)
   # chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp 


例：	許されない例
   # mget `domainname`


例外処理として：

   # whois 日本語

をどうしよう？という問題があります。今のところ”通さない”設定のままで
すが、これはこれで何とかするべき問題なのですが、良い解決策はありません。
.l	whois-security
.k	whoisと日本語の問題


例：	許されるパターンを拡張する例(%SECURE_REGEXPを使う)

   $SECURE_REGEXP{'whois'} = '\s*whois\s+\033\$[\@B][\041-\176]+\033\([BJ]\s*';

   ＃注意:
   ＃このパターンを調べるべき対象の文字列全体にマッチさせるので
   ＃最後のスペース等がありうるのなら、それらも考慮する必要がある


.S	投稿メールのサイズの制限

あまり大きいメールを送られてもサーバもメンバーの端末でも負荷が高くなる
だけです。ＭＬサーバーが受けとる時に切り捨てます。コマンド、投稿を問わ
ずチェックされます。デフォールトは制限なしで、サイズは byte 単位で

		$INCOMING_MAIL_SIZE_LIMIT
.k		$INCOMING_MAIL_SIZE_LIMIT

で指定します。なお0は無限大を意味します(デフォールト)。


.S	ＭＬのメンバー数制限(自動登録の時)

	$MAX_MEMBER_LIMIT
.k	$MAX_MEMBER_LIMIT

でメンバーの最大数を制限する。認証するメンバーのリストではなく、配送の
リストをチェックしています。もっとも自動登録の時はほとんど同じことですが


.S	許されるコマンドのシンタックス

Quoted from 4.4BSD:/usr/share/man/cat1/sh.0 
.q
       Shell Patterns

       A pattern consists of normal characters, which match them-
       selves, and meta-characters.   The meta-characters are
       ``!'', ``*'', ``?'', and ``[''.  These  characters lose
       there special meanings if they are quoted.  When command
       or variable substitution is performed and the dollar sign
       or back quotes are not double quoted, the value of the
       variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (``*'') matches any string of characters.   A
       question mark matches any single character. A left bracket
       (``['') introduces a character class.  The end of the
       character class is indicated by a ``]''; if the ``]'' is
       missing then the ``['' matches a ``['' rather than intro-
       ducing a character class.  A character class matches any
       of the characters between the square brackets.   A range
       of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclama-
       tion point the first character of the character class.

       To include a ``]'' in a character class, make it the first
       character listed (after the ``!'', if any).  To include a
       minus sign, make it the first or last character listed
.~q



.S	DNS Spoofing
.l	DNS Spoofing
.k	DNS Spoofing
.k	$LOG_CONNECTION
.l	$PeerAddr
.k	$PeerAddr

デフォールトでは何もしていませんが、

	$LOG_CONNECTION = 1;

コネクションを張ってきた相手先のIPアドレスを $PeerAddr に設定します。
Gauntlet(firewall) 越しだったりすると無意味ですが…

$PeerAddr を使って DNS Spoofing Check コードをHOOK掛ければよいでしょう。


.S	Address Spoofing
.l	Address Spoofing
.k	Address Spoofing

これは無理っす。もっと下のlayerで何とかしてね。


.S	SYN Flooding
.l	SYN Flooding
.k	SYN Flooding

これもカーネルレベルの話。根本的な対策は難しい。


.S	Email アドレスの表現とRFC822
.k	Email アドレスの表現
.k	RFC822

	From: なんか / なんか (なんか)

とかいう怪しげなフィールドを作ると経路の途中でエラーになって、その先に
配送されないことがあります。 securiity 関係の話なので詳しいことは説明
しませんが…

それは(設計思想として)「疑わしきものははじく」ということから来ています。
sendmail のソースを読めばなぜ弾くのか理解できます。

RFC822 はBNF表現でできる理論限界を表現している文書です。確かに使っても
構わないのですが、表現のクラスをかなり制限したアドレスを使っていないと
通信できない可能性はあります。

では、どういうものならよいのか？というとすべてを網羅した表現はうまくで
きませんが…


.S	Gauntlet Firewall
.l	Gauntlet
.l	Firewall

.url	http://www.tis.com/
.url	http://www.iij.ad.jp/service/FIREWALL.html


.S	smrsh.c
.k	smrsh.c

smrsh.c は、
	"|program ..."

の program が何を実行するか？ではなく program の名前が /usr/adm/sm.bin 
の中にあるかどうか？を見ています。＃ access(2) で、

よって、/usr/adm/sm.bin/fml.pl ですね:-)


.S	access(2) 
.k	access(2) 

smrsh.c は access(2) を使っています。

=E
smrsh.c uses acceess();

--- NetBSD 1.2REL /usr/share/man/cat2/access.0

CAVEAT
     Access() is a potential security hole and should never be used.

4th Berkeley Distribution     September 15, 1996                             2

--- perl5.003/perl.c

	/* On this access check to make sure the directories are readable,
	 * there is actually a small window that the user could use to make
	 * filename point to an accessible directory.  So there is a faint
	 * chance that someone could execute a setuid script down in a
	 * non-accessible directory.  I don't know what to do about that.
	 * But I don't think it's too important.  The manual lies when
	 * it says access() is useful in setuid programs.
	 */


.S	Precedence Priority
.k	Precedence

sendmail 8.8.5 operations manual tells:

             5.7.  P -- Precedence Definitions

                     Values for the "Precedence:" field may be defined
                using  the  P  control line.  The syntax of this field
                is:

                    Pname==num

                When the name is found in a "Precedence:"  field,  the
                message  class  is  set  to  num.  Higher numbers mean
                higher precedence.  Numbers less than  zero  have  the
                special  property  that if an error occurs during pro-
                cessing the body of the message will not be  returned;
                this  is  expected  to be used for "bulk" mail such as
                through mailing  lists.   The  default  precedence  is
                zero.  For example, our list of precedences is:

                    Pfirst-class=0
                    Pspecial-delivery=100
                    Plist=-30
                    Pbulk=-60
                    Pjunk=-100

                People  writing  mailing list exploders are encouraged
                to use "Precedence: list".  Older versions of sendmail
                (which discarded all error returns for negative prece-
                dences)  didn't  recognize  this  name,  giving  it  a
                default  precedence  of  zero.  This allows list main-
                tainers to see error returns on both old and new  ver-
                sions of sendmail.


.S	4.4BSD vacation
.k	vacation

     No message will be sent unless login (or an alias supplied using the -a
     option) is part of either the ``To:'' or ``Cc:'' headers of the mail.  No
     messages from ``???-REQUEST'', ``Postmaster'', ``UUCP'', ``MAILER'', or
     ``MAILER-DAEMON'' will be replied to (where these strings are case insen-
     sitive) nor is a notification sent if a ``Precedence: bulk'' or
     ``Precedence: junk'' line is included in the mail headers.  The people
     who have sent you messages are maintained as a db(3) database in the file
     .vacation.db in your home directory.


.S	Directory Permissions

複数の人が fmlserv と一緒に使う場合 fmlserv はメンバーリストを書き変え
る等のために group permission が必要です。
＃ そのために root process を作れば、そうでなくてもできなくはないはず
＃ ですが、root process を増やすことはやりたくないので

	$USE_FML_WITH_FMLSERV
.l	$USE_FML_WITH_FMLSERV
.k	$USE_FML_WITH_FMLSERV

変数はそれを意味するための内部変数ですが、普通は fml.pl が $DIR の隣に 
fmlserv という directory があるなら自動的に設定します。うまくいかない
ときは explicit に設定して下さい。それから

	$GID
.l	$GID
.k	$GID

も fmlserv のために導入された変数ですね。


.S	配送メールへのフィルタリング

	$USE_DISTRIBUTE_FILTER
.k	$USE_DISTRIBUTE_FILTER

をセットすると、配送処理に入る直前( &Distribute ルーチンの先頭)で 
%Envelope のデータ群(ヘッダやメール本文)に対してフィルタリング操作をか
けます。そして問題のある内容のメールの配送をしないなどができるようにな
ります。

	$USE_DISTRIBUTE_FILTER

をセットしただけのデフォールトでは(現在(97/12/14))次のようなメールは 
reject します。

	○ 本文が何もないメール
	○ help や unsubscribe などの英語一行メール
	○ %echo ふがほげ の文
	○ Message-Id: が朗かに addr-spec でないのは SPAM メール

これ以外の高度なチェックは

	$REJECT_DISTRIBUTE_FILTER_HOOK
.k	$REJECT_DISTRIBUTE_FILTER_HOOK

で直接 perl の構文で %e (%Envelope) ハッシュの変数を使って記述して下さ
い。HOOK 内部では $e{'h:from:'} などでハッシュにアクセスして下さい。
＃このために独自の言語とかをまた新たに導入するのは面倒だとおもうので
＃perl で生書きです。

この HOOK では次のようなことを期待しています。

	reject する場合は reject の理由を含む文を return する
	そうでないなら 何も返さない (return ''; など)

この reject の理由はログに残されます。また、

	$FILTER_NOTIFY_REJECTION
.k	$FILTER_NOTIFY_REJECTION

という変数が設定されていれば、その理由をそのメールの送り主に送り返しま
す。

例: (not tested ;-)

○ received: 行のどこかに spam ブラックリストを見つけたら reject する。
○ 本文に http-equiv=3DContent-Type なHTMLをつけてくる迷惑なメール
   は reject する
○ From: のドメインが Message-ID にも含まれているかどうか？
   含まれていないならメールの偽造とみなして reject

$REJECT_DISTRIBUTE_FILTER_HOOK = q#
    if ($e{'h:received:'} =~ /from spam.co.jp/) {
	return 'from a host in spam blacklist';
    }

    if ($e{'Body'} =~ /http-equiv=3DContent-Type/) {
	return 'mail with appended HTML documents';
    }

   local($domain) = (split(/@/, $From_address))[1];
   if ($e{'h:message-id:'} !~ /$domain/i) {
	return 'Message-Id conflicts your From: address';
   }

#;


例2:	sendmail の option で PICKY_HELO_CHECK をかけている場合

    # PICKY_HELO_CHECK
    if ($e{'h:x-authentication-warning:'} !~ /Host \S+ claimed to be \S+/) {
	$r = "Your SMTP session or your host config is invalid";
    }

でもメールを出す人が virutal domain とかだとバソバソ reject されて困っ
ちゃうだろう ＃それでも構わないという人は使ってみよう(強引)


.S	sendmail 8.8 における check_* ルールセットについて

詳しくは CF を読んでね。sendmail 8.8 では様々なアクセス制御を容易にカ
スタマイズできるように以下のようなルールセットが用意されています。CFで
物足りない場合（そうはないとおもうぞ）はこれらを使ってごりごり 
sendmail.cf を書きます。

.q
check_mail          発信者のチェック
check_rcpt          受信者のチェック
check_relay         SMTP接続のチェック
check_compat        発信者および受信者のペアについてのチェック
.~q

またSMTPコネクションの接続要求に対して tcp_wrapper のライブラリである
libwrap.a を使うように sendmail を compile しておけば、
/etc/hosts.allow などで制御できるようになります。NetBSD 1.3 などの最新
のOSではこれが配布されるソースでのデフォールトです。
ちなみに tcp_wrapper におけるデーモン名は sendmail です。

.q
Example:

[/etc/hosts.allow]

sendmail: mikoto.fml.org


[/etc/hosts.deny]

ALL: ALL

.~q


check_mail と check_rcpt はSMTP処理ルーチン srvrsmtp() 内でそれぞれ 
MAIL FROM: と RCPT TO: の命令の引数に対して適用されます。つまりそれぞ
れ SMTP で渡される MAIL FROM:のアドレス(発信者)と RCPT TO:のアドレス
(配送先)のチェックに使われます

check_relay はSMTPコネクションが張られた時に適用されます。check_relay 
は validate_connection() で呼ばれ接続が成立した SMTPコネクションが接続
を許可されているホストからのものか？などについてチェックをします。
validate_connection() では tcp_wrapper 形式の制御も可能です(前述)。

check_compat は単純なチェックではなく送信者と受取人の組で判定をしなけ
ればならないような複雑な判定に使います。
check_compat は配送ルーチン deliver() で適用されメールの送り主と配送
先のペアについてSMTP transcation だけでなく配送するメールの全てについ
て適用されます。



.C	Emailアドレスの判定方法とSecurity

.S	アドレスのチェックを緩めたい or きつくしたい
.l	$ADDR_CHECK_MAX

メンバーチェックは送られてきたメールの発信者のアドレスと members に書
かれたアドレスとが一致するか否かで判断しています。今の設定は
＃1.3.2からは…緩くした

	fukachan@titech.ac.jp
	fukachan@phys.titech.ac.jp
	fukachan@beth.phys.titech.ac.jp
	fukachan@exelion.phys.titech.ac.jp

はすべて同じにみなしてます。つまり phys.titech.ac.jp のjp側から数えて
３つの部分の判定チェックですね。(木構造のルートから数える)
＃経験的にここまでやれば十分でしょう

4つ(jp ac phys titech の4つ)までチェックしたいなら、

	$ADDR_CHECK_MAX = 4;
.k	$ADDR_CHECK_MAX

と config.ph のどっかに書いておいて下さい。$ADDR_CHECK_MAX という変数
が設定されてない場合は３として動きます。


.S	複数アドレスから投稿したいがうけとりは一つ( "# skip" )
.key	skip
.key	noskip
.label	skip

複数アドレスから投稿可能だがうけとりはあるアドレスに送って欲しい。
＃この１週間だけこのアドレスも使いたいしぃ〜とかの場合にも効果的です

という場合を考えて、actives(自動登録では members = actives) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証(新人さんチェック)には使うけど配送はしないという動作
をします。つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

ユーザーがこれを自分でコントロールしたいなら、コマンドは
＃ Admin command でのみ引数が有効です。
 
# skip	 [引数]		From:のアドレス もしあれば 引数のアドレスを
			そこから投稿はできるが、配送はされないものと設定する
# noskip [引数]		上の逆。配送するようにする。

です。例：
# skip 
	From: のアドレスを skip に

# skip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp を skip に

# noskip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp へも配送を


.S	特定のアドレスを拒否する (spam mails)
.k	spam mails
.l	$REJECT_ADDR_LIST
.k	$REJECT_ADDR_LIST
.k	$REJECT_ADDR
.l	$DIR/spamlist

メインのルーチンに飛ぶ前に reject するコードなら入っています(2.1 gamma
206)。$REJECT_ADDR_LIST (デフォールトは $DIR/spamlist) に perl の正規
表現で書いたアドレスから来たメールには何もしないで reject するようにな
ります。この場合配送、コマンド、自動登録すべての場合にそこへいく前に 
reject します。

   \S+@spam.org (spam.org のアドレスは全部許否)
   manager@\S+  (あらゆるサイトの個人を代表しないアドレスは拒否)

みたいな形式です。なおデフォールトの $REJECT_ADDR はこれとは別に適用さ
れます。


.include mti.wix


.C	Portings

.S	Micro$oft NT 4.0
.k	Micro$oft NT 4.0
.k	$HAS_GETPWUID
.k	$HAS_GETPWGID
.k	$HAS_ALARM

	$HAS_GETPWUID
	$HAS_GETPWGID
	$HAS_ALARM

の変数はOFFになります。U*ix ではデフォールトでONです。 

.S	arch/ Directory
.k	$COMPAT_ARCH

fml.pl の次の行は

    if ($COMPAT_ARCH)  { require "arch/${COMPAT_ARCH}/depend.pl";}

Architecture 依存コードをロードするためのものです。
Architecture 依存は

	sys/arch/アーキテクチュア or OS/perlスクリプト

のように並び適宜ローディングされます。



.C	配送効率についての考察

.S	配送プロセスの律速段階とは
.k	配送プロセスの律速段階

律速段階はやっぱり sendmailの配送プロセスそのものでしょう。
この部分の overhead は R5 にくらべ R8 では非常に改善されましたが
それでもかなりのものです。

逆にいえば fml 自体を tuning して速度を例えば 0.1 sec 上げても ML の配
送プロセスには何のメリットも生じないということでもあります。

余計なプロセスがついても、配送速度には効きません。それよりはいろいろな
ことができたほうがおもしろいでしょう？という思想的背景はここに起因しま
す。

これを改善する方法は基本的に複数の sendmail で作業を分割することです。

１	十分なパワーのマシンで十分な file descriptor や 
	多くの process が走っても大丈夫であれば、
	複数の sendmail を起動して配送を試みる。
	この場合ちゃんと Load Average と sendmail.cf を tune する
	必要がある。 
	
２	非力でも複数のマシンが用意できるなら複数のマシンでパラレルに実行

３	リレーサーバを用意する。例えば東京方面、関西方面のように分けて
	一回そのリレーサーバに投げて、そこから再配送をする。

１、２は”MCI_… ” という変数群がそれを可能にします。

リレーサーバは各ユーザごとに”管理者”が設定できます。
リレーサーバは相手のマシンに負荷をかけるり、ネットワークトポロジーを
考慮の上決めるべきです。
また、fml のリレーハックは RFCにはない % hack を前提にしています。
そのため、管理者が注意深く設定すべきです。


なお $DEFAULT_RELAY_SERVER が定義されている場合は強制的に全てのメールを

	$DEFAULT_RELAY_SERVER
.k	$DEFAULT_RELAY_SERVER

で定義されたリレーサーバへ投げそのサーバに配送してもらうということもで
きます。
.xref	$DEFAULT_RELAY_SERVER


qmail というひたすら配送プロセスを fork() しまくって、何も考えずにばん
ばん投げるMTAがあります。そういう配送の仕方でバックボーンならいいと思
いますが、細い線のサイトにばんばん投げ付けられてしまうようになったら最
低ですよね？世の中どこも線が太いなんていう仮定は誤りですから。
.url	http://www.qmail.org/


.S	複数のマシンの sendmail を使ってパラレルに送信
.k	$HOSTS
.k	@HOSTS
.k	@HOST(@HOSTSの旧変数名)

複数の(sendmailの走っている)マシン(非常時のセカンダリも含む)

	$MCI_SMTP_HOSTS = N;

で指定されたＮ台のマシンを配列 @HOSTS で指定する

   @HOSTS = (machine-1.domain, machine-2.domain, machine-3.domain, ...);

$HOST と @HOSTS で与えられる Ｎ個 のマシンの sendmail をパラレルに使っ
て（理論上での限界は）Ｎ倍配送を高速化する。
＃ $HOST も使われてしまうのは、もともと @HOSTS はセカンダリだったから
＃ です（歴史的に）。

もし、指定したサーバ数が N 個に足りない場合は、$HOST が何度も使われま
す。


Ｎは理論上 int と同じだろうが、普通は netmask できまるわな（笑）
でも、他のドメインでも使えるから、int までいく（理屈、理屈）
＃とくに actives の最後の方の人はうれしい

actives の中をちゃんと考えてならべないと sendmail R8 のHOST_CACHE がう
まくいかせない可能性はあります。


.S	配送するメールのMIME部分はDecodeしてから配送したい
.label	MIME-hack
.xref 	MIME-header

＃注意：以下試していない。

sub Distribute で

    for (@HdrFieldsOrder) {
	$lcf = $_; $lcf =~ tr/A-Z/a-z/; # lower case field name

という部分を

    for (@HdrFieldsOrder) {
	if (/ISO\-2022\-JP/o) { $_ = &DecodeMimeStrings($_);}

とすれば ISO-2022-JP で始まる部分だけをMIME decodeします。
実はこうすると、本文の中のMIMEもDecodeしてしまいますね(^^)


.# $Id$
.# Copyright (C) 1993-1998 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1998 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
