.C	fml の基本動作と起動オプション…
.l	fml-process

ＭＬサーバの基本動作を知っておくとカスタマイズの時役にたちます。


.S	ＭＬサーバの動作 (fml と sendmail の役割分担)
.key	ＭＬサーバの動作
.l	ml-process

   メールが SMTP で送られてくる

             ↓

   SMTP で待ち構えているプログラムがうけとる (例: sendmail)

             ↓

   /etc/aliases から何をすれば良いのかを理解して、
   setuid 操作等を行なった後 fml の STDIN にメールが送り込まれる。

             ↓

   (sendmail -> fml へ引き渡される。ここからが fml の担当)
   config.ph による設定に従い、ヘッダの解析、ＭＬメンバーのリストに従い
   配送 or コマンド要求を処理した結果のメールを配送リストと共に
   sendmail 等のSMTPサーバへ引き渡す

             ↓

   (ここから再び sendmail の担当)
   sendmail 等のSMTPサーバがメールの配送を行なう。


フィルタだけなら sed でも十分だし、“配るだけ"なら Sendmail 8.x でも十
分でしょう。しかし、+αでログをとり、スプールし、必要なら取り寄せられ
るようにちょこっとだけ複雑なことをしようとするならこの サーバ まで必要
となるというわけです。

なお、この図でわかるとおり、まとめおくりはこれとは”全く別の”プロセス
です。まとめおくりは自動的に作動するわけではありません。
.xref msend

まとめおくりとは、一定時間ごとにスプールされたＭＬの記事を送ってあげる”
別のプロセス”のことです。このプロセスは別の仕方で定期的に実行されなけ
ればなりません。



.S	sendmail -> fml 時の動作
.k	sendmail -> fml 時の動作
.l	sendmail2fml

sendmail から fml へメールが渡される時は次のように動作します。

○ まず /etc/aliases にある

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で、sendmail はこのファイルを実行します。

	/usr/local/list/Elenaの中身は

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

のようになっています。

次に fml が上の引数（上例では コマンドラインオプションがないが）は 
/var/spool/ml/elena を Elena ML の home directory だと見なし
/var/spool/ml/elena/config.ph に従い fml の設定を行います。

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは 	/usr/local/list/Elena の中で

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

や(デフォールト↑)

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena --distribute "

のように書きます(コマンドラインオプションをつける場合)。

引数の書き方の順番は任意です。引数の最初の directry を MLのホーム
(config.phのある場所 もしくは spool やメンバーファイルのある場所) と見
なします。


.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)
.k	fml.plと引数
.k	DIR
.k	LIBDIR

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

のように起動されるわけですが、この場合

	/usr/libexec/fml/fml.pl 
の
	/usr/libexec/fml 

部分をとりだします。そして

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた（複数可能）場合、例えば

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 
	3   /usr/lib/uja
	4   /lib/uja

のような順番でファイルを探します。


.S	オプション設定の優先順位
.l	order-of-option-effeciency
.k	オプション設定の優先順位

オプション設定の強い順番に並べると

	1   コマンドラインオプション (fml.pl -d や --distribute 等)
	2   sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3   各MLごとの config.ph による設定
	4   fml デフォールト設定

大抵の program と同様ですね。ちなみにインストール時に 
samples/sitedef.ph が作られますので参考にしてみて下さい。
とりあえずこれ↑はＭＬごとではなくそのマシン共通の設定になるもの

	tar や gzip はどこにある？

の設定のみを sitedef.ph でしています。



.# ##########################################################
.#	command line options
.include clo.wix


.S	fmlのプロセス(STDINからの読み込みの第一段階)
.l	STDIN->fml

STDIN からの読み込みは第壱段階でハッシュテーブル %Envelope
.xref	%Envelope
.k	$Envelope{'Header'}
.k	$Envelope{'Body'}
.k	ヘッダ	$Envelope{'Header'}
.k	ボディ	$Envelope{'Body'}

	ヘッダ	$Envelope{'Header'}
	ボディ	$Envelope{'Body'}

に保存されます。この時ボディ（メールの本文）に対しては次のようなチェッ
クがなされます。

○ 最初の $GUIDE_CHECK_LIMIT 行に対して $GUIDE_KEYWORD のキーワードが
現れるか否か？
メンバー以外からのメールでこのキーワードをキャッチした場合は、ガイドを
送り返してそれ以外のことはしない。
.k	$GUIDE_CHECK_LIMIT
.k	$GUIDE_KEYWORD

○ 最初の $COMMAND_CHECK_LIMIT 行に対して
.k	$COMMAND_CHECK_LIMIT
.k	$CHADDR_KEYWORD

	# で始まり、英文字が続く行 (\s*\w+\s|^\#\s*\w+)

	# で始まり、$CHADDR_KEYWORD のキーワード
	が現れる行があるか否か？あった場合はコマンドモードへ移行。

の2つのチェックをしています。それぞれの LIMIT を調節すると、つまり 
LIMIT を 0にすればチェックをしないということになるし、全文すべてをコマ
ンドの対象にすることもできます。デフォールトではそれぞれ最初の3行のみ
を対象にしています。

なお、それぞれのキーワードデフォールトは次のように設定されています。

	$GUIDE_KEYWORD  = "guide";
	$CHADDR_KEYWORD = "chaddr|change-address|change";


.S	fmlのプロセス(第２段階, %Envelopeの処理)
.xref	%Envelope
.xref	header-custom

%Envelope にヘッダとボディを読み込んだ後はヘッダの解析プロセスが続きま
す。詳細については次の章を見て下さい。
.xref	%Envelope
.xref	header-custom

この後ロックして、メインのプロセスが続くことになります。


.S	fml process の lock と signal handling 
.k	$Sigarlm
.k	$TimeOut{'flock'}
.k	$FLOCK_TIMEOUT(Obsolete)
.k	$MAX_TIMEOUT

現在の flock を使うロックアルゴリズムは次のように設定されています。
alarm(3) を使う普通のやり方です。 

sub Flock {

    &SetEvent($TimeOut{'flock'} || 3600, 'TimeOut') if $HAS_ALARM;
	...

TIMEOUTを待つ時間は $TimeOut{'flock'} で決まります。
(flock でない場合は 三秒＋α 程度の sleep を $MAX_TIMEOUT 回して待ってみる）

    # signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'}  = $SIG{'QUIT'} = 'SignalLog';

$TimeOut{'flock'} (デフォールトは3600秒) 後 $SIG{'ALRM'} で定義された
関数(TimeOut)を実行します。

関数 TimeOut は管理者へTIMEOUTを知らせ、ログを残しfmlを終了します。
これがないとずっとロック(flock)がかかったままになるからです。

なお、flock を使わない時はTIMEOUTしたメールを保存し、管理者へTIMEOUTを
知らせます。詳細は liblock.pl を見るとわかるでしょう。
.#	UNIX Nework Programming


.S	イベント・スケジューラ
.k	SetEvent
.k	ClearEvent
.k	Tick

TIMEOUT等は、現在実行している処理内容によらず特定の時間が来たら(割り込
んで)実行する必要がありますが、それは伝統の味 alarm(3) を使って実装し
ます。

なお、Windows NT 4.0 Version では alarm(3) が使えないのこの処理は実行
されません。


.S	ロックの仕方(flock でない場合)
.l	how-to-lock
.k	ロックの仕方について
.k	ロックアルゴリズムの選択と変数の設定
.seealso fml-mechanism, seq-file

ロックアルゴリズムは二通り用意されてます。flockがお奨めです。flock(2) 
参照

.key	$USE_FLOCK
	$USE_FLOCK    = 1;

で flock system call

	$USE_FLOCK    = 0;

で Unix V7 時代からある link() を使う方式を使います。

この方式はロックするファイルへの link() ができるか否か？を排他制御に使
います。このロックするファイルは $LockFile で、

	$LOCK_FILE

という変数で変更できます。デフォールトは

	"$FP_VARRUN_DIR/lockfile.v7"

つまり、ML の home の下の var/run/lockfile.v7 です。この方式の問題は 
OS がいきなり落ちた時にこのファイルが残ってしまうので手動でこのファイ
ル群を消さなければならないという点が最大の問題点です。そのため flock() 
が望ましいということになります。

そういう場合は reboot 直後に

	"$FP_VARRUN_DIR/lockfile.v7"
	"$FP_VARRUN_DIR/lockfile.数字"

すべてを消して下さい。数字はプロセス番号ですから、プロセステーブルを見
て(ps(1))、該当する数字(fml の process)がなければ、そのファイルは消し
て良いです。

なお通常は $MAX_TIMEOUT 秒後、var/log/ の下にTIMEOUTしたメールは保存さ
れ、管理者へTIMEOUTが通知されます。

[捕捉]	flock(2) を見れば分かりますが 
.k	flock(2)
.k	$LOCK_SH
.k	$LOCK_EX
.k	$LOCK_NB
.k	$LOCK_UN

	$LOCK_SH                       = 1;
	$LOCK_EX                       = 2;
	$LOCK_NB                       = 4;
	$LOCK_UN                       = 8;
.q
     #include <sys/file.h>
     #define   LOCK_SH   1    /* shared lock */
     #define   LOCK_EX   2    /* exclusive lock */
     #define   LOCK_NB   4    /* don't block when locking */
     #define   LOCK_UN   8    /* unlock */

     int
     flock(int fd, int operation)
.~q

排他制御については例えば、A. S. Tanenbaum, "Modern Operating Systems"


.S	SMTPライブラリについて
.k	SMTP
.k	Simple Mail Transfer Protocol
.k	MTA
.k	Mail Transport Agent

SMTP ライブラリは SMTP(プロセス間通信)で sendmail 等のMTA(Mail
Transport Agent)と通信するライブラリです。

$PORT = 25 (25/tcp) で通信しますが、

	$PORT 

を変えることで別のポートで通信することもできます。また、標準で


	$SMTP_LOG (default は "var/log/_smtplog")

というファイルに通信のログを残します。このログはデバッグに非常に役立ち
ます。

	$NOT_TRACE_SMTP 
.k	$NOT_TRACE_SMTP 

をセットすると、このログは残りません。

また、どのマシンの sendmail を使うかも自由に設定できます。
デフォールトはそのマシンです。もしＭＬサーバのマシン（受けるマシン）が
貧弱ならそのマシンが何十通もメールを送り出すのは酷です。

.key	$HOST
	$HOST         = 'localhost';

そういう場合変数 $HOST を書き換えて、別のマシンに配送を任すこともでき
ます。その時は

	$HOST         = 'beth.foo.bar.ac.jp';

のようにそのマシン名を書いて下さい。

もちろんアクセスできないマシンとかではできません(あったりする)し勝手に
そのマシンのパワーを使うことになるのでそのマシンを使う許可を得るべきで
す。


.S	予備のSMTPサーバ
.k	予備のSMTPサーバ
.k	@HOSTS

もしSMTPサーバに何かあった時のために @HOSTS に複数台の予備の sendmail 
の走っているマシンを定義することが出来ます。

   @HOSTS = (machine-1.domain, machine-2.domain, machine-3.domain, ...);

この場合、もし $HOST に connect() できない時は、machine-1 に、
もし machine-1 に connect() できない時は machine-2 へ…とい
う風に予備のサーバを使い何とか配送をしようと試みます。



.C	fml 内部におけるデータ構造
.l	data-structure
.xref	hack


ここでは fml 内部処理におけるデータ構造について解説します。これらの知
識は改造する上で必須の事柄でしょうが、単に変数を 1 or 0 にセットするだ
けしか設定 (config.ph) をいじらないなら読む必要はないでしょう。


.S	変数名の Naming Convention
.key	変数の名前つけ
.key	変数の Naming Convention
.key	Naming Convention


○ 大文字（[A-Z0-9_]+）だけの塊はユーザーのカスタマイズで使う目的の
   Global 変数です。

	例：	$ML_MEMBER_CHECK

○ ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語はメー
   ル本体やヘッダをSubroutine間で渡しあうための Global 変数です。

	$MailBody	$Reply_to
	%Envelope	*_cf

	例外： *_cf は システム情報をもっている名前空間です。

   %Envelope は最も重要な変数です。
   しかしながら、こういう変数は本来出来るだけ少なくするべきです。
   また、@Fld にように現在そうは使われていないのに名残として残ってしまっ
   ているものもあります。

   注意：
	全部小文字でグローバル変数という例外が歴史的に２つあります。
	$debug と $rcsid です。歴史的にそうなっているというだけなので
	今後そういう変数名は作られることはありません。

○ 小文字は基本的にlocal variableで、大抵はsubroutineの先頭でlocal宣言
   されています。

○ 補足
なお、Directory を定義する $*_DIR タイプの変数には

	$*_DIR 		$DIR からの相対パス
	$FP_*_DIR 	絶対パス

の２種類があります。 $FP_*_DIR タイプの変数は自動的に変換され定義され
ます。基本的には絶対パスが使われます。$FP_ の変数は fml.pl の初期化で
自動的に補正されつつ設定されます。

	$FP_TMP_DIR
	$FP_VARDB_DIR
	$FP_VARLOG_DIR
	$FP_VARRUN_DIR
	$FP_VAR_DIR
    	$FP_SPOOL_DIR
.k	$FP_TMP_DIR
.k	$FP_VARDB_DIR
.k	$FP_VARLOG_DIR
.k	$FP_VARRUN_DIR
.k	$FP_VAR_DIR
.k    	$FP_SPOOL_DIR


.S	subroutine 名の Naming Convention
.k	subroutine 名の Naming Convention

例外を除いて
    ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語
です。

基本的に subroutine の名前はX11風だったりします。最近のはlisp風味も混
ざってます:-) #おおむねX11風ですね

○ fml 1.5 以降では若干例外があります。

ファイル操作をする関数で

	変換インターフェイスとしての 	f_関数 名
	＃いつか、なくなるだろう

		と 

	そのモードのコンストラクタ	Cnstr_関数 名
	そのモードのディストラクタ	Destr_関数 名

が例外です。「将来 replace するべきです」と当時言ったまま replace され
ないままですが:-)


.S	%Envelope (ハッシュテーブル)
.l	%Envelope
.k	%Envelope
.k	struct envelope e;


%Envelope には今 fml を起動したメールの内容(ヘッダ、ヘッダの各フィール
ド、本文等)が格納されます。また、そのメールに対しどういうMETHODでREPLY
を返すべきか？や、sendmail との通信等の設定に関しての付加情報も 
%Envelope を通じて渡されます。
それはこのメールに対する METHOD の定義とみなしているからです。


sendmail の struct envelople e; に対応するものです。
しかし、perl 4 を本来ターゲットにしているため

	$Envelope->$Header->$From = "uja@domain";

のような使い方はしません(できない)。
これと同様のことを意図したシンタックスが

	$Envelope{"h:From:"}  = "uja@domain";

で表現されています。 h = header で From: はわざと Field だとわかりやす
いように : まで含めています。

   以下、%EnvelopeのKEYについて説明します。
   ＃ハッシュなので、KEY => VALUE が $Envelope{KEY} の値が VALUE ですね

	h: ではじまるものKEYは「ヘッダの各フィールドのデータ」です。

	h:Capital:	補正されたデータ
	h:lower-case:	オリジナルデータ

	それ以外に その Envelope のメールをどういうモードで処理するか？
	や、そのメールへのREPLY、エラーレポート処理をどうするか？
	というMETHODの指定等の付加情報も付け加えることもあります。
.#	hack:

	[ヘッダ関係]

	h:field:	上述のヘッダ：フィールド：設定値

	fh:field:	field(小文字) はfmlがある値を強制する

			例： fh:to: は To: を $Envelope{'fh:to:'} の値にする

	oh:field:	field はOriginalのヘッダフィールドを使う

	GH:field:	コマンドの結果を返すメールは GenerateHeader() という
			ルーチンでメールヘッダを生成する。
			そこでの値を変更したいならこのKEYを使う。

	Addr2Reply:	コマンドの結果の返事を返すアドレス
			reply-to: > From:

	[メールが呼び出すべきモードやメソッドのConfig]

	macro:x		x は sendmail の $x に対応する内容を保存

	mode:x		モード設定値 

	mci:mailer	mci は Mail Connection Information (MCI)
			mci:mailer は ipc(SMTP) か prog(exec sendmail)
			のどちらかである

	[内部表現]

	Header		オリジナルのヘッダ
	Body		オリジナルのメール本文
	Hdr		送り出すメールのヘッダ（&Smtpの直前に生成される）

	message		メールをサーバへ送ったユーザへのメッセージ
	error		管理者への(エラー)メッセージ

	MIME		ISO-2022-JP is detected (toggle Flag)
	UnixFrom	Unix From
	Hdr2add		$SUPERFLUOUS_HEADER の時につかうバッファ
	nclines		# command の行数
	nlines		メール本文の行数
	preamble	メール本文の前につける文章
	trailer		メール本文の後につける文章


   例： Subject:

    $Envelope{'h:subject:'}	
	は来たメールそのもの

    $Envelope{'h:Subject:'}	
	は来たメールの Re: をとり
	必要なら [Elena 100] のようなものを処理したもの

   のような違いがある。	配送されるヘッダと大文字ではじまる単語
   は次のように対応する

   配送メールのヘッダ	%Envelope
	Date: 		h:Date:
	From:		h:From:
	To: 		h:To:
	Sujbect: 	h:Subject:



.S	データ構造の初期化
.l	init-data-structure
.k	データ構造の初期化

各データの初期化は次の順序で行なわれる。

	$DIR $LIBDIR @INC の初期化

	&InitConfig
	   &SetDefaults
		%Envelope
		DNS 設定
		各種設定
		@HdrFieldsOrder

	   &LoadConfig
		$DIR/config.ph
		sitedef.ph

   	   &SetOpts
		コマンドリンオプションの評価

	   COMPATIBILITY CODE
   
	&Parse
		%Envelope へ Header Body 等のオリジナルデータをセット
		
	&GetFieldsFromHeader
		%Envelope へ h:field: および h:Field: をセット

	&FixHeaders
		h:Field: への各種補正を行なう

	&CheckEnv
		%Envelope による設定、動作モードチェック

	この後各種フックがそれぞれの場所で評価される。
	例：
		$START_HOOK
		$SMTP_OPEN_HOOK
		$FML_EXIT_HOOK


.S	DIRECTORY変数
.xref	fml-process

起動時の一番最初の段階では $DIR $LIBDIR @INC という変数の設定を筆頭に
各種変数の初期化が行なわれます（上述）。

$DIR $LIBDIR @INC が起動時にどう評価され使われているかは
「fml の基本動作と起動オプション…」の章を見ると分かるでしょう。
.xref	fml-process

以下では DIRECTORY 一覧を示します。
		
	@INC	（参考）
		これは Perl の include file の search path
		$DIR @INC(original) $LIBDIR ...
		の順番に探される。

	$DIR
		config.phのある場所、いわゆるMLのHOME	
		@INC の先頭に設定される

	$LIBDIR	

		fml.pl や libsmtp.pl 等の置き場所。
		$DIR と同じでも良いし、別の場所で保守されていてもよい。
		もともと複数のＭＬを扱うためにスプールと *.pl ファイル
		群の置き場所をわけるために導入された
		@INC の最後に入る。

		なおコマンドラインに出てくるdirectoryはすべて @INC に
		設定されるが、$DIR の直後の directory が $LIBDIR に設
		定される。

    	$SPOOL_DIR		$DIR/spool
		ＭＬの記事を格納する場所


	[$DIRからの相対パスで設定されるもの]
	$TMP_DIR		tmp (temporary)	4.4BSD の /tmp
	$VARDB_DIR		4.4BSD の /var/db (データベース)
	$VARLOG_DIR		4.4BSD の /var/log に対応 ログが置かれる
				backward compat のため
				log 等のデフォールトは $DIR/log のままである
				本来は $VARLOG_DIR/log が望ましい

	$VARRUN_DIR		4.4BSD の /var/run pid-file 等はここ
				なお cache もここにおいている。
	$VAR_DIR		4.4BSD の /var

	[FULL PATH 化された変数]
	$FP_TMP_DIR		$DIR/$TMP_DIR
	$FP_VARDB_DIR		$DIR/$VARDB_DIR
	$FP_VARLOG_DIR		$DIR/$VARLOG_DIR
	$FP_VARRUN_DIR		$DIR/$VARRUN_DIR
	$FP_VAR_DIR		$DIR/$VAR_DIR
    	$FP_SPOOL_DIR		$DIR/$SPOOL_DIR


.S	設定ファイル群
.xref	fml-file-structure

[メンバーのリスト関係]

	$MEMBER_LIST 	 	$DIR/members
.l	$MEMBER_LIST
		メンバーリスト(認証のみに使う)
.xref	fml-file-structure

	$ACTIVE_LIST 		$DIR/actives
.l	$ACTIVE_LIST
		ＭＬの配送リスト
.xref	fml-file-structure


[各種の説明、ご案内関係のファイル]

	$OBJECTIVE_FILE	 	$DIR/objective
.l	$OBJECTIVE_FILE
		ＭＬの目的を書いたファイル

	$GUIDE_FILE		$DIR/guide
.l	$GUIDE_FILE
		ＭＬの一般向けご案内（ガイド）

	$HELP_FILE	 	$DIR/help
.l	$HELP_FILE
		ＭＬのHELP、コマンドの解説等

	$DENY_FILE	 	$DIR/deny
.l	$DENY_FILE
		ＭＬがメンバーチェックをしている時
		メンバー以外からメールが来た時に返す断りの文章
		
	$WELCOME_FILE	 	$DIR/guide
.l	$WELCOME_FILE
.xref	auto-regist
		ＭＬが自動登録の時、登録時に送ってあげる文章
		デフォールトではとりあえずガイドと同じになっている。



[ログファイル関係]

	$LOGFILE	 	$DIR/log
.l	$LOGFILE
		ログ

	$MGET_LOGFILE    	$DIR/log
.l	$MGET_LOGFILE
		mgetのログ。デフォールトでは↑ログファイルと同じ
.xref	mget
	
	$SMTPLOG		$VARLOG_DIR/_smtplog
.l	$SMTPLOG
		プロセス間通信(SMTP)のログ(デバッグの役に立つ)

	$SUMMARY_FILE 	 	$DIR/summary	
.l	$SUMMARY_FILE
		MLの記事のサマリ

	$SEQUENCE_FILE 	 	$DIR/seq
.l	$SEQUENCE_FILE
		MLの記事番号

	$MSEND_RC		$VARLOG_DIR/msendrc
.l	$MSEND_RC
		まとめおくりの制御ファイル
.xref	msend

	$LOCK_FILE	 	$VARRUN_DIR/lockfile.v7
.l	$LOCK_FILE
		flock() を使わない時のロックで使うファイル

	$LOG_MESSAGE_ID		$VARRUN_DIR/msgidcache
.l	$LOG_MESSAGE_ID
		message-id cache ファイル
		(ML自身での無限ループを防ぐためのキャッシュ)

	$INDEX_FILE		$DIR/index (なくてもいっこうに構わない)
.l	$INDEX_FILE
		indexコマンドで表示したい内容を書く
		このファイルがない場合はその場でMLのHOME内容を調べて
		返す

.S	単に便利なためにある変数

	$NULL
.l	$NULL
		ダミー:-) ＃ 別にこんな変数いらない 
		#define null (char *)0 みたいなものだと思ってもらえば良い

	$FML	
.l	$FML	
		カーネル内のプロセステーブルを書き変える際に使う変数

	$FACE_MARK	（単なる愛敬:-）
.l	$FACE_MARK
		各種リクエストの結果を返す時にお別れの文章の腋につける
		e.g. P(^^)
			Be seeing you P(^^)

		のようになる。		 



.C	fml 設定ファイルのフォーマットと構造
.l	fml-file-structure
.k	fml 設定ファイルのフォーマットと構造

fml の設定ファイル、メンバーリストは基本的に shell like な構造で記述さ
れていると期待されています。つまり基本的に # ではじまる行はコメント、
空行は飛ばす等の挙動を各ルーチンはしています。

以下では各設定ファイルのフォーマットについて言及します。


.S	members ファイルのフォーマットと構造
.k	members ファイルのフォーマットと構造

$MEMBER_LIST (default members) で定義されるファイルは

	#.FML
		…fml がつけるコメント…
	#.endFML
	アドレス1
	アドレス2
	# アドレス3
	##BYE アドレス4
	アドレス5

のような形をしています。歴史的理由により現在では

   # の後空白 でコメントアウトされているものもメンバーチェックの対象
   ## ではじまるところはコメント

となっています。よって上の例では ##BYE の行は無視されますが、それ以外
のアドレス１〜アドレス５（４を除いて）すべてがメンバーチェックの際には
対象となります。

この動作は 1.2 release version の直後、自動登録を拡張する際に導入され
ました。

［歴史］この導入のため # off と # skip はどう違う？という疑問がその後
	生まれることになりました。

なおメンバーファイルとしては各行のアドレスより後ろの部分は
何にも使われていませんので、勝手に使って構いません。

しかしながら、自動登録の場合は $MEMBER_LIST と $ACTIVE_LIST は同じもの
（$MEMBER_LIST）が使われます。よってそのフォーマットは $ACTIVE_LIST 形
式であると仮定する必要があります。


.S	actives ファイルのフォーマットと構造
.k	actives ファイルのフォーマットと構造

$ACTIVE_LIST (default members) で定義されるファイルは ＄MEMBER_LIST と
同様の構造を持ちます。

しかし actives ファイルは拡張された表現として各アドレスのオプションを
行の残りの部分に持つことができます。

	アドレス	オプション	# コメント

	注意：なお、それぞれの↑ブロックの間には必ず一つ以上の SPACE
	か TAB があると仮定しています。

よって勝手に何かを書いた場合オプションとみなされます。付加情報は # コ
メント として行の最後にでも書いて下さい。この辺は shell と同じです。

オプションは V1 と V2 フォーマットがあります。

   V1 フォーマットは

	数字(フォーマット)	まとめおくりの指定
	数字以外		リレーサーバ

   V2 フォーマットでは将来の拡張のため

	m=まとめ送り指定
	r=リレーサーバ
	s=1(skip を意味する)

のように alphabet=option-value の形で定義されています。現在のところこ
れ以外のキーワードは将来のために予約されています。

現在のルーチンは V2 のみを理解します。よって V1 -> V2 に変換する必要が
あります。この変換は

	libfml.pl で ChangeMemberList が呼ばれた時

つまりメンバーリスト等へのなんらかの変更を行なう時に自動的に行なわれま
す。


.S	actives と members の違い
.k	actives と members の違い

フォーマット的には上述の通りです。後は自動登録の章で述べられている通り
members はメンバーであるか否か？の認証、 actives は配送リストです。

自動登録では members 一つを認証と配送リスト両方に使っています。
そのため表現の拡張が必要だったわけです。


.S	複数のメンバーリスト、複数の配送リスト
.l	@ACTIVE_LIST
.l	@MEMBER_LIST

	@ACTIVE_LIST	複数の配送リスト

	@MEMBER_LIST	複数のメンバーリスト

を定義できます。地方ごととか組織ごとにリストを管理するのに便利かも知れ
ません。

デフォールトでは @ACTIVE_LIST は使われていません。@MEMBER_LIST は 
members と members-admin です。

歴史: 最初に管理者を設定して後はリモートですべてをおこなうという目的の
ために拡張されました。


.S	msendrc ファイルのフォーマットと構造
.k	msednrc ファイルのフォーマットと構造


msendrc は $MSEND_RC で定められる場所におかれます。そのフォーマットは

	アドレス	次回に送る最初の記事番号

です。msednrc は msend.pl が制御するログファイルです。

msend.pl は $ACTIVE_LIST を見て、

	・あるアドレスがまとめ送りになった
		そのアドレスのエントリを msendrc 内に新しく作る

	・あるアドレスがまとめ送りで”なくなった”
		そのアドレスのエントリを消去

	・まとめおくりを配送した
		次回に送る最初の記事番号を msendrc に記録する		

ということを msendrc に対して行ないます。
また、msend.pl 以外のプログラムが msendrc をいじることはありません。


.S	パスワードファイルのフォーマットと構造
.k	パスワードファイルのフォーマットと構造
.l	etc/passwd
.xref	bin/passwd.pl remote
.k	$PASSWD_FILE
.k	$DIR/etc/passwd

パスワードを保存しているファイルは通常 etc/passwd に置かれています。

	$PASSWD_FILE (default "$DIR/etc/passwd") 

で定められます。フォーマットは

	アドレス	cryptされたパスワード

です。つまり UNIX 伝統のパスワードファイル形式の先頭の部分です。
＃crypt(3) についてはマニュアル参照

ＭＬサーバのリモート管理で使われます。
.xref	remote

あるアドレスをこのファイルへ登録する時などは bin/passwd.pl を使うと良
いでしょう。
＃また、admin コマンドには initpass という初期化コマンドもあります。


.S	fml インストール後の maintenance と version up に関して
.l	fml-maintenance
.k	How to maintan the installed fml source
.k	インストール後のメインテナンスとversion up
.k	version up of fml
.k	maintenance of fml

上述のデータ構造とファイルの扱いを考慮した場合、インストール後の
version up や maintenance に便利な形は次のようなものだと思っています。
＃僕はこんな感じにやってます。

version up は基本的に 
	cp -p fml-source/src/*.pl your-directory 
です。
＃以下 $HOME は適当に各自の環境に合わせて展開して考えて下さいね

	$HOME/libexec/fml/ に *.pl を全部いれておく

また、ＭＬのスプールを

	$HOME/w/spool/fml-support
	$HOME/w/spool/foreign-tv-ml

のように作っておく。config.ph や spool としてＭＬの記事の保存場所はこ
こです。よって、include は

	"|$HOME/libexec/fml/fml.pl $HOME/w/spool/fml-support"

のようなファイルを /etc/aliases から呼び出します。僕はＭＬ用には
$HOME/etc/aliases を使ってたりしますが:-)
＃ sendmail.cf は O AliasFile=/etc/aliases, それ以外のaliasファイル
.k	sendmail.cf
.k	O AliasFile=...

version up の仕方は、例えば次のようになるでしょう。

	% cd /var/tmp
	% tar zxvf fml-current.tar.gz
	% cp -pr fml-2.1何か/src/*.pl $HOME/libexec/fml

で終りだと:-)

maintenance は コマンドのパスやＭＬ全体共通の設定は

	$HOME/libexec/fml/sitedef.ph 
.k	sitedef.ph 

で行ない、各ＭＬごとの設定は

	$HOME/w/spool/fml-support/config.ph 
.k	config.ph 

で制御する。



.C	Security 
.l	security


.S	Security 関係の基本思想

基本的に

   1	デフォールトではすべてを認めない
   2	大丈夫と思われるものを通すようにする
   3	疑わしきものははじいて判断をＭＬの管理者へあおぐ

という風に構成されています。


.S	Security Check Routine
.l	SecureP
.l	InSecureP
.k	InSecureP
.k	SecureP

ファイアウォールでも同様ですが、概念的に２種類の考え方が出来ます。

	1 明らかに危ないものを除いていく
	2 安全なものを許可していってそれ以外は拒否する

fml-support: 00950 でも述べていますが

	1.x は外掘から埋める方式 (関数 InSecureP)
	2.y は内掘から埋める方式 (関数 SecureP)

といってます(^^)。1.x と 2.y の関係はそのまま 上の 1 と 2 の違いといっ
て間違いありません。


SecureP は以下のように

   コマンドとしてうけいれる命令(メールの一行全体について実行)の形を限定

します。

    １ 	\w/\w の部分は見逃す。＃ ../ とか .[a.]/ とかはだ〜め
       	/ でOKのところは消去する
	また、まとめ送り等の m=数字 等の特別なシンタックスは消去する。

    ２ 	/^[\#\s\w\-\[\]\?\*\.\,\@\:]+$/

    の形はゆるす。
    ＃注意： \w は [A-Za-z0-9_] なので、 "-" を加えた

    ３ 	これ以外を含んでいたらエラー

    ４ 	特殊なケース（admin コマンドの admin addr m=3) は
	事前に例外処理をした後 &SecureP にまわす。
	

例：	許される例

   # summary
   # mget 1-20,30,last:20 mp 1
   # mget 10? mp 1			(default では許さない)
   # mget 1[012]? mp 1			(default では許さない)
   # chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp 


例：	許されない例
   # mget `domainname`


例外処理として：

   # whois 日本語

をどうしよう？という問題があります。今のところ”通さない”設定のままで
すが、これはこれで何とかするべき問題なのですが、良い解決策はありません。
.l	whois-security
.k	whoisと日本語の問題


.S	許されるコマンドのシンタックス

Quoted from 4.4BSD:/usr/share/man/cat1/sh.0 
.q
       Shell Patterns

       A pattern consists of normal characters, which match them-
       selves, and meta-characters.   The meta-characters are
       ``!'', ``*'', ``?'', and ``[''.  These  characters lose
       there special meanings if they are quoted.  When command
       or variable substitution is performed and the dollar sign
       or back quotes are not double quoted, the value of the
       variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (``*'') matches any string of characters.   A
       question mark matches any single character. A left bracket
       (``['') introduces a character class.  The end of the
       character class is indicated by a ``]''; if the ``]'' is
       missing then the ``['' matches a ``['' rather than intro-
       ducing a character class.  A character class matches any
       of the characters between the square brackets.   A range
       of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclama-
       tion point the first character of the character class.

       To include a ``]'' in a character class, make it the first
       character listed (after the ``!'', if any).  To include a
       minus sign, make it the first or last character listed
.~q


.S	mget でユーザから与えることのできるシンタックス
.k	mget と Shell Match Pattern(e.g. * 1?)
.key	$SECURITY_LEVEL

$SECURITY_LEVEL < 2 では 

	# mget * 
とか
	# mget 10? 

が使えます。デフォールトは"Backward Compatibility を無視して2" です。
通常 Backward Compatibility は重視されているのですが、security 関係は
例外です。

また、何もしなくても、

# mget 正規表現 送り返されるメールの時間間隔（ｓｅｃ）

	と

# mget2 1-10,5みたいなsyntax 送り返されるメールの時間間隔（ｓｅｃ）

の両方を理解します。サーバが自動的に切替えます。


.S	DNS Spoofing
.l	DNS Spoofing
.k	$LOG_CONNECTION
.l	$PeerAddr
.k	$PeerAddr

デフォールトでは何もしていませんが、

	$LOG_CONNECTION = 1;

コネクションを張ってきた相手先のIPアドレスを $PeerAddr に設定します。
Gauntlet(firewall) 越しだったりすると無意味ですが…

$PeerAddr を使って DNS Spoofing Check コードをHOOK掛ければよいでしょう。


.S	Address Spoofing
.l	Address Spoofing
.k	Gauntlet
.k	Firewall

これは無理っす。もっと下のlayerで何とかしてね。


.S	SYN Flooding
.l	SYN Flooding
.k	SYN Flooding

これもカーネルレベルの話。根本的な対策は難しい。


.S	アドレス表現とRFC822
.k	アドレス表現
.k	RFC822

	From: なんか / なんか (なんか)

とかいう怪しげなフィールドを作ると経路の途中でエラーになって、その先に
配送されないことがあります。 secuirity 関係の話なので詳しいことは説明
しませんが…

それは(設計思想として)「疑わしきものははじく」ということから来ています。
sendmail のソースを読めばなぜ弾くのか理解できます。


RFC822 は BNF表現でできる理論限界を表現している文書です。確かに使って
も構わないのですが、表現のクラスをかなり制限したアドレスを使っていない
と通信できない可能性はあります。

では、どういうものならよいのか？というとすべてを網羅した表現はうまくで
きませんが…



.S	Gauntlet Firewall
.l	Gauntlet
.l	Firewall

http://www.tis.com/
http://www.iij.ad.jp/service/FIREWALL.html


.S	smrsh.c

smrsh.c は、
	"|program ..."

の program が何を実行するか？ではなく program の名前が /usr/adm/sm.bin 
の中にあるかどうか？を見ています。＃ access(2) で、

よって、/usr/adm/sm.bin/fml.pl ですね:-)


.S	access(2) 

smrsh.c は acceess(2) を使っています。

=E
smrsh.c uses acceess();

--- NetBSD 1.2REL /usr/share/man/cat2/access.0

CAVEAT
     Access() is a potential security hole and should never be used.

4th Berkeley Distribution     September 15, 1996                             2

--- perl5.003/perl.c

	/* On this access check to make sure the directories are readable,
	 * there is actually a small window that the user could use to make
	 * filename point to an accessible directory.  So there is a faint
	 * chance that someone could execute a setuid script down in a
	 * non-accessible directory.  I don't know what to do about that.
	 * But I don't think it's too important.  The manual lies when
	 * it says access() is useful in setuid programs.
	 */


.S	Directory Permissions

複数の人が fmlserv と一緒に使う場合 fmlserv はメンバーリストを書き変え
る等のために group permission が必要です。
＃ そのために root process を作れば、そうでなくてもできなくはないはず
＃ ですが、root process を増やすことはやりたくないので

	$USE_FML_WITH_FMLSERV
.l	$USE_FML_WITH_FMLSERV

変数はそれを意味するための内部変数ですが、普通は fml.pl が $DIR の隣に 
fmlserv という directory があるなら自動的に設定します。うまくいかない
ときは explicit に設定して下さい。それから

	$GID
.l	$GID

も fmlserv のために導入された変数ですね。



.C	Portings

.S	Micro$oft NT 4.0
.k	$HAS_GETPWUID
.k	$HAS_GETPWGID
.k	$HAS_ALARM

	$HAS_GETPWUID
	$HAS_GETPWGID
	$HAS_ALARM

の変数はOFFになります。U*ix ではデフォールトでONです。 

.S	arch/ Directory
.k	$COMPAT_ARCH

fml.pl の次の行は

    if ($COMPAT_ARCH)  { require "arch/${COMPAT_ARCH}.pl";}

Architecture 依存コードをロードするためのものです。



.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
