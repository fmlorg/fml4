.C	fml の基本動作と起動オプション…
.l	fml-process

ＭＬサーバの基本動作を知っておくとカスタマイズの時役にたつでしょう。


.S	ＭＬサーバの動作 (fml と sendmail の役割分担)
.key	ＭＬサーバの動作
.l	ml-process

   メールが SMTP で送られてくる

             ↓

   SMTP で待ち構えているプログラムがうけとる (例： sendmail)

             ↓

   /etc/aliase から何をすれば良いのかを理解して、
   setuid 操作等を行なった後
   fml の STDIN にメールが送り込まれる。
             ↓

   (sendmail -> fml へ引き渡される。ここからが fml の担当)
   config.ph による設定に従い、ヘッダの解析、ＭＬメンバーのリストに従い
   配送 or コマンド要求を処理した結果のメールを
   sendmail 等のSMTPサーバへ引き渡す

             ↓

   (ここから再び sendmail の担当)
   sendmail 等のSMTPサーバがメールの配送を行なう。


フィルタだけなら sed でも十分だし、“配るだけ”なら Sendmail 8.x でも
十分でしょう。しかし、＋αでログをとり、スプールし、必要なら取り寄せら
れるようにちょこっとだけ複雑なことをしようとするならこの サーバ まで必
要となるわけです。

なお、この図でわかるとおり、まとめおくりはこれとは別のプロセスです。
.xref msend


.S	sendmail -> fml 時の動作
.k	sendmail -> fml 時の動作
.l	sendmail2fml

sendmail から fml へメールが渡される時は次のように動作します。

○ まず /etc/aliases にある

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で、sendmail はこのファイルを実行します。

	/usr/local/list/Elenaの中身は

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

のようになっています。

次に fml が上の引数（上例では コマンドラインオプションがないが）は 
/var/spool/ml/elena/ を Elena ML の home directory だと見なし
/var/spool/ml/elena/config.ph に従い fml の設定を行います。

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは 	/usr/local/list/Elena の中で

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

や（デフォールト）

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena --distribute "

のように書きます（コマンドラインオプションをつける場合）。

引数の書き方の順番は任意です。引数の最初の directry をMLのホーム
(config.phのある場所 もしくは spool やメンバーファイルのある場所)と見
なします。


.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)
.k	fml.plと引数
.k	DIR
.k	LIBDIR

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

のように起動されるわけですが、この場合

	/usr/libexec/fml/fml.pl 
の
	/usr/libexec/fml 

部分をとりだします。そして

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた（複数可能）場合、例えば

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 
	3   /usr/lib/uja
	4   /lib/uja

のような順番でファイルを探します。


.S	オプション設定の優先順位
.k	オプション設定の優先順位

オプション設定の強い順番に並べると

	1   コマンドラインオプション (fml.pl -d や --distribute 等)
	2   sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3   各MLごとの config.ph による設定
	4   fml デフォールト設定

大抵の program と同様ですね。ちなみにインストール時に 
samples/sitedef.ph が作られますので参考にしてみて下さい。
とりあえずこれはＭＬごとではなくそのマシン共通の設定になるもの

	tar や gzip はどこにある？

の設定のみを sitedef.ph でしています。



.# ##########################################################
.#	command line options
.include clo.wix


.S	fmlのプロセス

.S	fml process の signal handling
.k	$SIGARLM
.k	$TIMEOUT

現在は次のように設定されています。
これは alarm(3) を使ういつものやり方です。
TIMEOUTを待つ時間は $MAX_TIMEOUT で決まります。

    # signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'}  = $SIG{'QUIT'} = 'SignalLog';

$TIMEOUT 後 $SIG{'ALRM'} で定義された関数(TimeOut)を実行します。

TimeOut は管理者へTIMEOUTを知らせ、ログを残しfmlを終了します。
これがないとずっとロック(flock)がかかったままになるからです。

なお、flock を使わない時はTIMEOUTしたメールを保存し、管理者へTIMEOUTを
知らせます。詳細は liblock.pl を見るとわかるでしょう。


.S	SMTPライブラリについて
.k	SMTP
.k	Simple Mail Transfer Protocol
.k	MTA
.k	Mail Transport Agent

SMTP ライブラリは SMTP(プロセス間通信)で sendmail 等のMTA(Mail
Transport Agent)と通信するライブラリです。

$PORT = 25 (25/tcp) で通信しますが、

	$PORT 

を変えることで別のポートで通信することもできます。また、標準で

	$SMTP_LOG

というファイルに通信のログを残します。このログはデバッグに非常に役立ち
ます。

	$NOT_TRACE_SMTP 
.k	$NOT_TRACE_SMTP 

をセットすると、このログは残りません。


.S	予備のSMTPサーバ
.k	@HOSTS

もしSMTPサーバに何かあった時のために @HOSTS に複数台の sendmail の走っ
ているマシンを定義することが出来ます。

   @HOSTS = (machine-1.domain, machine-2.domain, machine-3.domain, ...);

この場合、もし machine-1 に connect() できない時は machine-2 へ…とい
う風に予備のサーバを使い何とか配送をしようと試みます。


.S	その他の変数（未解説）

	$COMPAT_CF1
	$UMASK
	$GOOD_BYE_PHRASE
	@MEMBER_LIST


.C	fml 内部におけるデータ構造
.l	data-structure
.xref	hack


ここでは fml 内部処理におけるデータ構造について解説します。これらの知
識は改造する上で必須の事柄でしょうが、単に変数を 1 or 0 にセットするだ
けしか config をいじらないなら読む必要はないでしょう。


.S	変数名の Naming Convention
.key	変数の名前つけ
.key	変数の Naming Convention
.key	Naming Convention


○ 大文字（[A-Z0-9_]+）だけの塊はユーザーのカスタマイズで使う目的の
   Global 変数です。

	例：	$ML_MEMBER_CHECK

○ ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語はメー
   ル本体やヘッダをSubroutine間で渡しあうための Global 変数です。

	$MailBody	$Reply_to
	%Envelope	*_cf

	例外： *_cf は システム情報をもっている名前空間です。

   %Envelope は最も重要な変数です。
   しかしながら、こういう変数は本来出来るだけ少なくするべきです。

   注意：
	全部小文字でグローバル変数という例外が歴史的に２つあります。
	$debug と $rcsid です。歴史的にそうなっているというだけなので
	今後そういう変数名は作られることはありません。

○ 小文字は基本的にlocal Variableで、大抵はsubroutineの先頭でlocal宣言
   されています。


○ 補足
なお、Directory を定義する $*_DIR タイプの変数には

	$*_DIR 		$DIR からの相対パス
	$FP_*_DIR 	絶対パス

の２種類があります。 $FP_*_DIR タイプの変数は自動的に変換され定義され
ます。基本的には絶対パスが使われます。

	$FP_TMP_DIR
	$FP_VARDB_DIR
	$FP_VARLOG_DIR
	$FP_VARRUN_DIR
	$FP_VAR_DIR
    	$FP_SPOOL_DIR
.k	$FP_TMP_DIR
.k	$FP_VARDB_DIR
.k	$FP_VARLOG_DIR
.k	$FP_VARRUN_DIR
.k	$FP_VAR_DIR
.k    	$FP_SPOOL_DIR


.S	subroutine 名の Naming Convention
.k	subroutine 名の Naming Convention

例外を除いて
    ”１単語の先頭一文字が大文字、残りは小文字”の塊からなる単語
です。

基本的に subroutine の名前はX11風だったりします。最近のはlisp風味も混
ざってます:-) #おおむねX11風ですね

○ fml 1.5 以降では若干例外があります。

ファイル操作をする関数で

	変換インターフェイスとしての 	f_関数 名
	＃いつか、なくなるだろう

		と 

	そのモードのコンストラクタ	Cnstr_関数 名
	そのモードのディストラクタ	Destr_関数 名

が例外です。「将来 replace するべきです」と当時言ったまま replace され
ないままですが:-)


.S	%Envelope (ハッシュテーブル)
.k	%Envelope
.k	struct envelope e;


%Envelope には今 fml を起動したメールの内容(ヘッダ、ヘッダの各フィール
ド、本文等)が格納されます。また、そのメールに対しどういうMETHODでREPLY
を返すべきか？や、sendmail との通信等の設定に関しての付加情報も 
%Envelope を通じて渡されます。
それはこのメールに対する METHOD の定義とみなしているからです。


sendmail の struct envelople e; に対応するものです。
しかし、perl 4 を本来ターゲットにしているため

	$Envelope->$Header->$From = "uja@domain";

のような使い方はしません(できない)。
これと同様のことを意図したシンタックスが

	$Envelope{"h:From:"}  = "uja@domain";

で表現されています。 h = header で From: はわざと Field だとわかりやす
いように : まで含めています。

   以下、%EnvelopeのKEYについて説明します。
   ＃ハッシュなので、KEY => VALUE が $Envelope{KEY} の値が VALUE ですね

	h: ではじまるものKEYは「ヘッダの各フィールドのデータ」です。

	h:Capital:	補正されたデータ
	h:lower-case:	オリジナルデータ

	それ以外に その Envelope のメールをどういうモードで処理するか？
	や、そのメールへのREPLY、エラーレポート処理をどうするか？
	というMETHODの指定等の付加情報も付け加えることもあります。
.#	hack:

	[ヘッダ関係]

	h:field:	上述のヘッダ：フィールド：設定値

	fh:field:	field(小文字) はfmlがある値を強制する

			例： fh:to: は To: を $Envelope{'fh:to:'} の値にする

	oh:field:	field はOriginalのヘッダフィールドを使う

	GH:field:	コマンドの結果を返すメールは GenerateHeader() という
			ルーチンでメールヘッダを生成する。
			そこでの値を変更したいならこのKEYを使う。

	Addr2Reply:	コマンドの結果の返事を返すアドレス
			reply-to: > From:

	[メールが呼び出すべきモードやメソッドのConfig]

	macro:x		x は sendmail の $x に対応する内容を保存

	mode:x		モード設定値 

	mci:mailer	mci は Mail Connection Information (MCI)
			mci:mailer は ipc(SMTP) か prog(exec sendmail)
			のどちらかである

	[内部表現]

	Header		オリジナルのヘッダ
	Body		オリジナルのメール本文
	Hdr		送り出すメールのヘッダ（&Smtpの直前に生成される）

	message		メールをサーバへ送ったユーザへのメッセージ
	error		管理者への(エラー)メッセージ

	MIME		ISO-2022-JP is detected (toggle Flag)
	UnixFrom	Unix From
	Hdr2add		$SUPERFLUOUS_HEADER の時につかうバッファ
	nclines		# command の行数
	nlines		メール本文の行数
	preamble	メール本文の前につける文章
	trailer		メール本文の後につける文章


   例： Subject:

    $Envelope{'h:subject:'}	
	は来たメールそのもの

    $Envelope{'h:Subject:'}	
	は来たメールの Re: をとり
	必要なら [Elena 100] のようなものを処理したもの

   のような違いがある。	配送されるヘッダと大文字ではじまる単語
   は次のように対応する

   配送メールのヘッダ	%Envelope
	Date: 		h:Date:
	From:		h:From:
	To: 		h:To:
	Sujbect: 	h:Subject:



.S	データ構造の初期化
.k	データ構造の初期化

各データの初期化は次の順序で行なわれる。

	&InitConfig
	   &SetDefaults
		%Envelope
		DNS 設定
		各種設定
		@HdrFieldsOrder

	   &LoadConfig
		$DIR/config.ph
		sitedef.ph

   	   &SetOpts
		コマンドリンオプション

	   COMPATIBILITY CODE
   
	&Parse
		%Envelope へ Header Body 等のオリジナルデータをセット
		
	&GetFieldsFromHeader
		%Envelope へ h:field: および h:Field: をセット

	&FixHeaders
		h:Field: への各種補正を行なう

	&CheckEnv
		%Envelope による設定、動作モードチェック

	この後各種フックがそれぞれの場所で評価される。
	例：
		$START_HOOK
		$SMTP_OPEN_HOOK
		$FML_EXIT_HOOK


.C	fml 設定ファイルのフォーマットと構造
.k	fml 設定ファイルのフォーマットと構造

fml の設定ファイル、メンバーリストは基本的に shell like な構造で記述さ
れていると期待されています。つまり # ではじまる行はコメント、空行は飛
ばす等の挙動を各ルーチンはしています。

以下では各設定ファイルのフォーマットについて言及します。


.S	members ファイルのフォーマットと構造
.k	members ファイルのフォーマットと構造

$MEMBER_LIST (default members) で定義されるファイルは

	#.FML
		…fml がつけるコメント…
	#.endFML
	アドレス1
	アドレス2
	# アドレス3
	##BYE アドレス4
	アドレス5

のような形をしています。歴史的理由により現在では

   # の後空白 でコメントアウトされているものもメンバーチェックの対象
   ## ではじまるところはコメント

となっています。よって上の例では ##BYE の行は無視されますが、それ以外
のアドレス１〜アドレス５（４を除いて）すべてがメンバーチェックの際には
対象となります。

この動作は 1.2 release version の直後、自動登録を拡張する際に導入され
ました。

［歴史］この導入のため # off と # skip はどう違う？という疑問がその後
	生まれることになりました。

なおメンバーファイルとしては各行のアドレスより後ろの部分は
何にも使われていませんので、勝手に使って構いません。

しかしながら、自動登録の場合は $MEMBER_LIST と $ACTIVE_LIST は同じもの
（$MEMBER_LIST）が使われます。よってそのフォーマットは $ACTIVE_LIST 形
式であると仮定する必要があります。


.S	actives ファイルのフォーマットと構造
.k	actives ファイルのフォーマットと構造

$ACTIVE_LIST (default members) で定義されるファイルは ＄MEMBER_LIST と
同様の構造を持ちます。

しかし actives ファイルは拡張された表現として各アドレスのオプションを
行の残りの部分に持つことができます。

	アドレス	オプション

よって、勝手に何かを書いた場合、オプションとみなされます。
オプションは V1 と V2 フォーマットがあります。

   V1 フォーマットは

	数字(フォーマット)	まとめおくりの指定
	数字以外		リレーサーバ

   V2 フォーマットでは将来の拡張のため

	m=まとめ送り指定
	r=リレーサーバ
	s=1(skip を意味する)

のように alphabet=option-value の形で定義されています。

現在のルーチンは V2 のみを理解します。よって V1 -> V2 に変換する必要が
あります。この変換は

	libfml.pl で ChangeMemberList が呼ばれた時

つまりメンバーリスト等へのなんらかの変更を行なう時に自動的に行なわれま
す。


.S	actives と members の違い

フォーマット的には上述の通りです。後は自動登録の章で述べられている通り
members はメンバーであるか否か？の認証、 actives は配送リストです。

自動登録では members 一つを認証と配送リスト両方に使っています。
そのため表現の拡張が必要だったわけです。


.S	msendrc ファイルのフォーマットと構造
.k	msednrc ファイルのフォーマットと構造


msendrc は $MSEND_RC で定められる場所におかれます。そのフォーマットは

	アドレス	次回に送る最初の記事番号

です。msednrc は msend.pl が制御するログファイルです。

msend.pl は $ACTIVE_LIST を見て、

	・あるアドレスがまとめ送りになった
		そのアドレスのエントリを msendrc 内に新しく作る

	・あるアドレスがまとめ送りで”なくなった”
		そのアドレスのエントリを消去

	・まとめおくりを配送した
		次回に送る最初の記事番号を msendrc に記録する		

ということを msendrc に対して行ないます。
また、msend.pl 以外のプログラムが msendrc をいじることはありません。


.S	パスワードファイルのフォーマットと構造
.k	パスワードファイルのフォーマットと構造
.xref	bin/passwd.pl
.xref	remote

パスワードを保存しているファイルは通常 etc/passwd に置かれています。

	$PASSWD_FILE (default "$DIR/etc/passwd") 

で定められます。フォーマットは

	アドレス	cryptされたパスワード

です。つまり UNIX 伝統のパスワードファイル形式の先頭の部分です。

ＭＬサーバのリモート管理で使われます。
.xref	remote

あるアドレスをこのファイルへ登録する時などは bin/passwd.pl を使うと良
いでしょう。
.xref	bin/passwd.pl






.C	Security 

.S	Security Check Routine
.l	InSecureP
.k	InSecureP
.k	SecureP

ファイアウォールでも同様ですが、概念的に２種類の考え方が出来ます。

	1 明らかに危ないものを除いていく
	2 安全なものを許可していってそれ以外は拒否する

fml-support: 00950 でも述べていますが

	1.x は外掘から埋める方式 (関数 InSecureP)
	2.y は内掘から埋める方式 (関数 SecureP)

といってます(^^)。1.x と 2.y の関係はそのまま 上の 1 と 2 の違いといっ
て間違いありません。


SecureP は以下のように

   コマンドとしてうけいれる命令(メールの一行全体について実行)の形を限定

します。

    １ 	\w/\w の部分は見逃す。＃ ../ とか .[a.]/ とかはだ〜め
       	/ でOKのところは消去し、

    ２ 	/^[\#\s\w\-\[\]\?\*\.\,\@\:]+$/

    の形はゆるす。
    ＃注意： \w は [A-Za-z0-9_] なので、 "-" を加えた

    ３ 	これ以外を含んでいたらエラー

    ４ 	特殊なケース（admin コマンドの admin addr m=3) は
	事前に例外処理をした後 &SecureP にまわす。
	

例：	許される例

   # summary
   # mget 1-20,30,last:20 mp 1
   # mget 10? mp 1			(default では許さない)
   # mget 1[012]? mp 1			(default では許さない)
   # chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp 


例：	許されない例
   # mget `domainname`


例外処理として：

   # whois 日本語

をどうしよう？という問題があります。今のところ”通さない”設定のままで
すが、これはこれで何とかするべき問題なのですが、良い解決策はありません。
.k	whoisと日本語の問題


.S	DNS Spoofing
.l	DNS Spoofing
.k	$LOG_CONNECTION
.k	$PeerAddr

デフォールトでは何もしていませんが、

	$LOG_CONNECTION = 1;

コネクションを張ってきた相手先のIPアドレスを $PeerAddr に設定します。
Gauntlet(firewall) 越しだったりすると無意味ですが…

$PeerAddr を使って DNS Spoofing Check コードをHOOK掛ければよいでしょう。


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996      fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
