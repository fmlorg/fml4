.C	フック、カスタマイズ（例を見る方がはやいかも）
.l	hook
.label	{customize}

.S	インタプリタとconfig.ph
.seealso	command-hook

インタプリタなので(例えば config.ph に)HOOK を定義すれば
適当な場所でそのHOOKは評価され実行されます。

その HOOK でちょっと複雑な設定やダイナミックなサーバの挙動の変更をした
りできます。config.ph で定義するのでMLが複数あってもMLごとに変更できる
わけです。

以下、HOOKおよび、それを使ういくつかの例です。


.S	$START_HOOK
.key	$START_HOOK

この時点では、ヘッダの各フィールドの切り出しは終っている。が、配送orコ
マンド本体を行なう前である。

例： 配送前に、もし #ではじまらない行が８行以上あれば、たとえ#ではじま
る行があっても普通のメールとおもうようにする。

$START_HOOK =q%
    if ($Envelope{'nlines'} - $Envelope{'nclines'} >= 8) {
	undef $Envelope{'mode:uip'};
    }
%;


.S	$HEADER_ADD_HOOK
.key	$HEADER_ADD_HOOK

ヘッダに”新たに”つけくわえる フィールドをかいて、カスタマイズするた
めのフック。

現在では $body という変数はこのためだけに使われる。
＃注意：昔は違った

例：
    $HEADER_ADD_HOOK = q#
	$body .= "X-Baycity-Weather: Mizumaki\n";
    #;

ヘッダに X-Baycity-Weather: Mizumaki とつけくわえる（意味不明（笑））

例２：
Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.asia>

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: ".
	sprintf("<19%2d%02d%02d.%05d.%s>\n", $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.asia");
#;


.S	$DISTRIBUTE_START_HOOK
.k	$DISTRIBUTE_START_HOOK

配送を始める関数に入った時に最初に評価されるHOOK


.S	$SMTP_OPEN_HOOK
.key	$SMTP_OPEN_HOOK

このフックの後、 Sendmail へ渡すヘッダの処理が始まります。
ここで強制的にヘッダの内容を変えたりすると効果的です。

例：	Reply-To: フィールドをＭＬ自体へ強制書き換え

実はコマンドラインで --oh:reply-to=mailing-list でできちゃうんですが(^^;)

一応別解は一杯あって、別解の一つは (fh == forced header がみそ)

$SMTP_OPEN_HOOK = q#
	$Envelope{'fh:reply-to:'} = $MAIL_LIST; 	
#;

例２：	Precedence: を bulk へ

$SMTP_OPEN_HOOK = q#
	$Envelope{'h:Precedence:'} = 'bulk';
#;

実は config.ph で $PRECEDENCE = 'bulk'; でＯＫです。


.S	$SMTP_CLOSE_HOOK

$SMTP_CLOSE_HOOK は配送が終った後で、かつまだロックされている状態で実
行されます。具体的には &Distribute; を離れる直前に実行されます。


.S	$FML_EXIT_HOOK
.key	$FML_EXIT_HOOK
.seealso expire

fml.pl が最後に実行する フック。このときすでに 

	”排他制御の lock も解除”（＊＊＊重要！＊＊＊）

されていることに注意。expire とかがその例ですね。


.S	$MSEND_OPT_HOOK
.key	$MSEND_OPT_HOOK

デフォールトでは、まとめおくり や mget の時の Subject は

Subject: Matomete Send [PLAINTEXT(UNIX FROM)] (1/1) (Elena Lolobrigita ML)

のようになります。が    ↑↑↑↑ここのところの文章がきにいらないので
OVERWRITE したいときは、

$MSEND_OPT_HOOK = q%
    $MSendOpt{'#uf'} = "#Overwritten... $MSendOpt{'#uf'}";
%;

このように、
		$MSEND_OPT_HOOK 
に 連想配列の 
	#モード の値が #説明の文章

のようにかいてください。なにをやってるのかは、libutils.pl の中の
sub MSendModeSet  という関数を見るとわかるとおもいます。


.S	COMMAND_HOOK（コマンドへの追加）
.label	command-hook
.key	customize-of-commands
.key	コマンドのカスタマイズ
.key	$COMMAND_HOOK

インタプリタですから、コマンドでそのＭＬ独自の機能をもたせたかったら
config.ph にセットして下さい（そうすれば、ＭＬが複数あってもそれぞれ別
様にカスタマイズできる）。

これはリストを返すようにするコマンド "# list" を新たに付け加える例です。

--------- in config.ph ---------
$COMMAND_HOOK =q#
      if(/list/io) {
	  &Log("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;
--------- in config.ph ---------

この例だとは # 〜 # の間をquoteしています。#...コメントをとかははさめ
ません。
＃q syntax は q# ... # の形で任意の二つの文字（今はたまたま #）の間を
quoteする関数（本当の意味での関数ではないそうだ）


.S	コマンドの増やし方

config.ph に↓書くと、コマンドチェックのループの最後にこのフックを評価
します。こういうことをしてもいいというのは、大抵コマンドは一メールあた
り１、２回しか呼ばれないので、eval は重たいけど、１、２度ならまぁ便利
さの方が優先という経験と観察に基づいてます。


.S	HOOKによるコマンドの実装例： "# list" and "# rsummary"
.key	$COMMAND_HOOK

注意： rsummary は現在は summary 引数 の形で実行できます

例：
	# list		list リストファイルを取り寄せる

sub Command では $to にコマンドの結果の返し先が設定されています。

$COMMAND_HOOK は sub Command の中で定義されています。

$COMMAND_HOOK =q#
      if (/list/io) {
	  &Log("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;

例：
# rsummary 100-200	Count 100-200 までのサマリの部分だけを見る

$COMMAND_HOOK = q#
    if (/rsummary/io) {
	&Log("R Summary ". $Fld[2]);
	if ($Fld[2] =~ /^(\d+)\-(\d+)$/) {
	    local($r);
	    local($a) = $1; 
	    local($b) = $2; 

	    open(TMP, $SUMMARY_FILE) || do { &Log($!); next GivenCommands;};
	    while (<TMP>) {
		if (/\[$a:/ .. /\[$b:/) { $r .= $_;}
	    }
	    close(TMP);

	    &Mesg(*e, "Restricted  Summary $Fld[2]\n$r\n");
        }
	else {
	    &Log("Summary ($From_address)");
	    &SendFile($to, "Summary $ML_FN", "$DIR/summary");
	}

	next GivenCommands;
    }
#;


.S	HOOKによろコマンド実装例： "# sget"
.key	$COMMAND_HOOK

# sget uja		subjectに uja というキーワードが入っているファ
			イルを取り寄せる

$COMMAND_HOOK =q#
    if (/^sget$/io) {
	local($s);

	if (open(F, $SUMMARY_FILE)) {
	    while (<F>) {
		/$Fld[2]/ && do {/\s\[(\d+):/ && ($s .= $s ? ",$1" : $1);}
	    }
	    close(F);
	}
	else {
	    $s = "Fail";
	    &Log("Search and Get $Fld[2] Fail");
	    next GivenCommands;
	}

	&Log("Search and Get $Fld[2]");
	&Sendmail($to, "Search and Get $Fld[2] $ML_FN", $s);
    }
#;


.S	HOOKによるコマンド実装例： "# admin" アドミンコマンド
.key	$COMMAND_HOOK
.key	$ADMIN_MEMBER_LIST
.key	$ADMIN_HELP_FILE
.key	$REMORE_AUTH
.key	admin-command
.key	アドミンコマンド
.seealso	REMOTE-ADMINISTRATION 

"# admin" アドミンコマンド って昔あったんですが、今は config.ph で

	$REMOTE_ADMINISTRATION = 1;
	$REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1; (default)


.S	"# admin" アドミンの昔の呼出し方

lib/remote/REAMDE をみてもらうとわかりますね。 


.S	HOOKの例：ある行数を越えるメールは廃棄する設定

	
$START_HOOK = q#
    if ($Envelope{'nlines'} > 1000) {
	&Warn("Discarded on the behalf of too Large Mail", &WholeMail);	
	$DO_NOTHING = 1;
    }
#;


.S	ＭＬメンバーの人数制限

$START_HOOK = q%;

$MAX_MEMBER = 100;

# このファイルにごめんなさいの文章を書いておく
$LIMIT_OVER_FILE = "$DIR/limit.over"; 

sub WC
{
    local($f) = @_;
    local($lines) = 0;

    open(TMP, $f) || return 0;
    while (<TMP>) { 
	next if /^\#/;
        $lines++;
    }
    close(TMP);

    $lines;
}


if (&WC($ACTIVE_LIST) > $MAX_MEMBER) {
    &SendFile($From_address, 
	      "Sorry, the mailing list member exceeds the limit $ML_FN", 
	      $LIMIT_OVER_FILE);
    $DO_NOTHING = 1;
}


%;


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
