.HTML_PRE
		     Fml Operations Guide

   "The Design and Implementation of the fml Mailing List Server"

   			深町 賢一
   			fukachan@sapporo.iij.ad.jp

   [smm/op.wix: smm = System Management Manual]
   http://www.iij.ad.jp/sapporo/staff/fukachan/fml/
   Last modified: 

****************************************************************
*** ごめん、いま大書き直し中…少し順番とか入り乱れてます _o_ ***
****************************************************************

   このファイルは昔FAQという名前でした。
   FAQ、Setting、改造の仕方等に関するガイドになっています。
   ＃注意：なお改造は最新版を手に入れてから行なうのをお奨めします(^^)

   ftp://ftp.iij.ad.jp/pub/IIJ/dist/fukachan/fml/
   http://www.iij.ad.jp/sapporo/staff/fukachan/fml/

.END_HTML_PRE

----------目次----------
#.index

総索引
------------------------


.# ##########################################################
.P	Design Overview of the fml 


   パートIでは、fml の設計思想の概略について述べます。
   実際の細かい設定についてはパートII以降へ譲ります。
   急ぐ人はパートII以降へ進んで下さい。


.C	ＭＬサーバ Overview

.S	Brief Hisotry and Overview

最初の発端は例によって

	bug っているサーバ、
	機能の足りないサーバ、
	直すより自分で書いた方が早い

単にそういう話でした。

歴史的に hml 1.6 を一時期使っていて、その設定ファイルをコンバートする
のは面倒でした。そのため デフォールトの emulation は hml 1.6 を 
support しています。

また、Mailing List == Private Communication を便利にするツール（Filter） 
という観点を重視しているため、デフォールトでは メンバーチェック をする
という考え方を尊重しています。

その辺は設定(config file or command line option)でいくらでも変えられる
ので拘る必要はないのですが、設計思想をしっていると設定のデフォールトが
どうなっているかを推測するに役立つでしょう。


結局のところ、日々の routine work をいかに自動処理化できるか？が重要な
ので、ユーザにみえるインターフェイスはどうでもいいわけです。

デフォールトが hml 1.6 ですが、単なる distributer （配送プログラム）に
することもコマンドだけを実行するようにすることも、伝統の味（謎）の 
listserv のように動かすこともできます。


ＭＬサーバというものは一番肝心な部分はかなり簡単なのですが、実際にはそ
れ以外のさまざまな例外処理は発生します。それをノウハウというわけですが…
また、環境による違いを吸収するためにさまざまな関数をサポートする必要が
あります。例えば ish, lha サポート


これらを踏まえて基本的方針は
   『可能な限り user および ＭＬ管理者 にとっての自由度をあげる』
のようになります。
そして、それらの Configuration を簡単に設定できるようにするべきです。

そのことは、これからＭＬをはじめる方にはそのまま、 ＭＬサーバをカスタ
マイズして使いたいとおもっている方には改造の PLATFORM として利用しても
らうことを想定しています。

多くの変数があるのは、簡単に例えばある変数の値を変えるだけで挙動が変え
られるようにするためで、変数については、このドキュメントに述べられてい
ます。

また、このドキュメントはそれ以上のことをするための、関数の説明、設計思
想 について議論するためでもあります。


各種機能はそれぞれの目的に応じて選んでみて下さい。例えば『あるＭＬのロー
カルな再配送』のような場合はコマンド機能を落して使うほうがよいでしょう。
例： 
   ip-connection を受けるアドレスに使う時は --distribute モードで使う


.S	fml 2.1 Overview

fml 2.1 は Mailing List Server package(Perl Scripts package)で、
僕が壱から Full Scratch したものです。
＃おまけCDROMつき雑誌等にある「…の改良」の記述は間違った推測なのです

ML server, management tool, .forward 等メールを使う各種インターフェイスの
集合体です。

これは（歴史的理由により）デフォールトでは hml 1.6 という Perl Script 
を Emulationします。
＃正確にはその元祖の shell script の program というべきであらう

subset として ユーザにとってもＭＬ管理者にとっても使い勝手が同じになる
ように作動させることができます。

デフォールトの挙動はそうですが、さまざまな動作を実行できます

	○コマンド機能等を一切使わずにフォワードするだけ等
	   配送だけして「spoolingするaliasesと同じ」
	○hml のシンタックスで使う （Default Emulation）
	○listserv or majordomo インターフェイス
	   みかけがあたかも listserv のように fml のコマンド群を使う
	○forward でのMLのための仕組み(slocal や vacation)
	   .forward に仕掛けて slocal や
	   .forward から fml の機能を使うことで自分のaccountでMLを実行
	○まとめおくり等の配送の仕方の制御
	   メールをリアルタイムに配送したり、
	   一定時間ごとにためてまとめておくる

等はすぐに実行できます。例えばリモートでＭＬを管理や HTML へ変換してス
プールするとか expire をかける等さまざまな機能はモジュールとして配布パッ
ケージに１セットになっています。

必要に応じて、コマンドラインオプション か Configuration file で機能の
追加・削減を行うことができます。

ようは、インターフェイスだけを変えて、ユーザにとってどう見えるか？とい
う部分を用意すればよいので、様々なコマンド、ライブラリ群を好きなインター
フェイスで使えるということです。


.S	インストール

とりあえず非常に細かいチューニングを行なわなくてよいなら

	○対話的プログラムで行なう 
	○コマンドラインで引数を２つほど指定して make する

ことで、ＭＬの設定は終ります。その時、自動的に環境に合わせた各種見本設
定も自動生成しますので、それを cut and paste すればインストールは終り
です。

詳しくは INSTALL というファイルを見て下さい。


.S	fml 1.x とのCompatibility

fml 1.x を使っていて fml 2.x に入れ換える場合
   そのまま perl script 群だけを入れ換えれば動きます。
   config.ph で複雑な HOOK を書けている場合は
   ちょっと注意がいるかもしれません。
   ＃詳しくは doc/op 参照

.S	 hml 1.6 との compatibility

members や log file等をそのままに、*pl 群と config.phを差し替えればい
きなり動きます。


.C	Brief Overview of functions [fml の機能についてのサマリ]

以下、代表的な機能一覧について見る

.S	基本機能

	fml 2.1 が hml 1.6 と同様に目指したものは
	(以下 hml 1.6 README.jpn より)

	＊ 大規模なメーリング・リストでの使用に耐えます。
	＊ 豊富なコマンドを持っています。
	   ヘルプ、過去の記事の一覧、入手、一時的な離脱／再開など。
	＊ メンバのアドレスのチェックをしていますので、非メンバからの不法な
	   アクセスを防止することが可能です。
	＊ perl で書いてあるので改造が容易です。


.S	簡単なインストーラーから複雑な設定まで


初心者には、簡単なインストーラーによるお手軽インストールでよいとおもい
ます。最初は何をやっているか良くわからないものです。

しかし、必要なら複雑な設定まで（コードを直接いじることなく）できるべき
だとおもいます。

そうでないとソフトの複数のプラットホームでの作動が保証できないというの
ことでもあります。

そこで、代表的な『ある動作をするか？否か？』についてはすべて config
file もしくはコマンドラインオプションで ON OFF することができます。

そして、アーカイブやスプール、help ファイルの場所 や
『tar ish lha のような system のコマンド』
のようなものもすべて hard coding ではなく user が外部から制御できる変数
として定義されています。
＃変数リストは cf/MANIFEST を見て下さい。


.S	たくさんのドキュメント（複数のフォーマットで）

PLAINTEXT版はあらかじめ用意されています。

HTML 版は var/html/ の下に用意されいますが、
operation manual (旧FAQ) は巨大なのでこれの HTML 版は
shell% make doc でつくってください
最新版は
   http://www.iij.ad.jp/sapporo/staff/fukachan/fml/
をのぞいてみてください


.S	user 権限で実行

daemon とかで動かすのはなく user 権限で動かすために setuid() 
を行なった後 fml.pl へ渡します。

fml は実装上 Trusted User 等を気にする必要はありませんから daemon で動
かす必要はありません。

POSIX 準拠 OSは setuid() をちゃんと行なえる user はroot に限られます。
これは、これで正しい選択ですし、ターゲットの 4.4BSD もそういう実装をとっ
ています。そのため setuid() はできるだけ sendmail 等の SMTP をうけるプ
ログラムを信頼します。

sendmail 等がうまく setuid() を実行できない場合、 4.3 BSD では fml.c 
を compile して使えば良いでしょう。

fml.c を user 環境にあわせて compile するには直接 edit してもよいです
が、make すれば自動的に環境に合わせて fml という wrapper program を生
成します。これはすでに setuid() されています。

POSIX 準拠等では ＊非常に危ないですが＊ この fml を root 権限に setuid 
しなければなりません。fml.c のcode と fml をどこにおいて使うべきか？に
ついて自信がない場合あなたのサイト or マシンの管理者に相談するとよいで
しょう。



.S	モジュール化 


モジュール化にすることにより、 メンテもしやすいですが、自分だけのモジュー
ルを独立にメンテすることも容易になります。

もともとSMTP部分の独立保守と 常時使うわけではないコマンド部分を切り離
すことを目的としたモジュール化でしたが、現在では必要に応じて dynamic
loading するさまざまなライブラリをデフォールトで提供しています。

また、libtraffic.pl のように contribution されたコードも同様に配布して
います。libtraffic.pl は 

	libfml.pl の関数呼びだしインターフェイスに合わせれば、後は
	すべて user defined で作れる

というよい例です。
＃ぼくは中身についてタッチしていません。fml master code tree とは独立
＃に保守されています（感謝）

module はＭＬに configuration file と別の場所におくとよいでしょう。そ
うすることで、『ひとつのfmlで複数のＭＬを扱うように拡張』が容易になり
ますし、version up も楽です。


ＭＬを配送ではなく特定の目的のサーバのみを dynamic loading して
『特定の目的のサーバ』にすることも簡単にできます。
＃ $LOAD_LIBRARY に設定するだけ

これにより、
	コマンド 専用サーバ
	ftp 用サーバ
	ftpmail  専用サーバ 
	メールで request をうけてURLの中身を返すサーバ

等をカスタマイズできます。	

whois や ftpmail はライブラリモジュールとして提供されています。	

その他にもさまざまな改造事例集(contrib/)がついています
例： 	投票サーバ例
	WWW-MAIL(Mail で WWW Server とのリレーをし返送)
	Whois（ローカルキャッシュと本物の whois の両方）


.include tbl_lib.tbl


.S	容易なカスタマイズとその保守

各種変数は user が define できます。また Lisp のように多くのフックが用
意されています。
そのため、ソースコードを直接いじらなくてもたくさんの制御変数とフックで
カスタマイズできます。

また、それで不十分な場合モジュール化されているため、自分のモジュールを
書いて置き換え、それだけをメンテナンスすればよいことになります。

カスタマイズは config.ph とコマンドラインオプション両方で行えます。


.S	自動的にメンバー登録をするとかしないとか…


前述のとおりデフォールトは来たメールの From: を見て、メンバーチェック
をします。

自動的に登録することも、メンバーチェックをせずにす通しをすることもでき
ます。


各種動作モード等

	す通しをする。つまりスプールし再配送するだけ
	メンバーチェックし、メンバーなら配送しコマンドもうけつける
	メンバーチェックし、メンバーでないなら
		中身に関わらず登録
		Subject: に subscribe のようなキーワードを必要
		本文に subscribe のようなキーワードを必要

ちなみにキーワードは変えられます。


.S	豊富なファイル操作：取り寄せとまとめ送りと…

それぞれのユーザごとに細かく設定可能です。

get, mget, matome 等のコマンドにはオプションで MIME/Mulitpart 形で記事
をまとめて送り返して欲しい 等の変更ができます。

mget と まとめおくりでの User interface は次のようなものが取り揃えられ
ています。


	PLAINTEST 
		UNIX FROM
		RFC934	
		RFC1153
		MIME/Multipart
	COMPRESSED FILE
		gzip UNIX FROM file
		Lha + Ish 	（自動ＳＪＩＳ変換可）
		Lha + uuencode 	（自動ＳＪＩＳ変換可）
		tar + gzip
		uuencode

mget で取り寄せられるのは デフォールトは $SPOOL_DIR (default "spool") 
ですが、対象は標準のＭＬの記事スプール以外にも @ARCHIVE_DIR でいくらで
も設定できます。


ファイル操作の応用編として user が put も get できるように拡張されたコ
マンドも実装しています（library コマンド）。

ただし、デフォールトでは、put するファイル名は security 上選べません。
ファイル名を明示的に指定する場合は安全のため管理者が変更するべきです。


コマンドを認識するようになっている場合、デフォールトは最初の3行のどこ
かに "# command（英文字Only）" syntax をコマンドと認識します。
これは配送メールとコマンドメールを識別するために必要な処理です。

しかし専用サーバなら # でモードを切替える必要はないわけで、 コマンド 
インターフェイス は拡張され、コマンド専用の場合 # はなくてもかまいません。
コマンド操作の誤チェック機能も実装しました。

当然、Listserv 形式のシンタックスをうけつけるように拡張されたインター
フェイス(libexec/fmlserv.pl)を使う場合には、どっちでもいいわけです。


.S	 MIME や base64 等の処理 


基本的にすどおしですが、MIME 処理は下請けにだして、Subject をdecode し
てから save 等が可能です。

また、base64 の HTML モードでの画像等の変換処理をも行ないます。
つまり、メール中の gif ファイルを変換してメールの記事の html を生成し
ます。


.S	リモートでＭＬを管理すること


管理者として登録された人に対し

	From: 行での認証
	管理者一人ごとのパスワード

の２つで認証をします。デフォールトは2段階ですが、パスワードがいらない
というのであれば、外すことができます。
＃ $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 0;


fml 1.0 で『管理者が本当に操作しているかどうか?という点に関して保証で
きない』という理由ではずしたリモート管理(アドミンコマンド)を再実装し、
サポートします。

保証できないという意味は From: での認証は簡単に偽造できるからです。

そのため普通パスワードも併用します。このパスワードは 各管理者ごとに設
定できます。管理者全体で一つの共通パスワードというような ださい実装な
んかしていません。

これは普通の UNIX の パスワードシステム のミニチュア版です。
サーバ側では etc/passwd に 管理者ごとにパスワードを保存しています。 
保証の度合が上がったわけではありませんが、Password は crypt し保存して
います。一応かつての UNIX 程度の保証はされます。

しかしながら、メールの中では平文パスワードを書く必要がありますし、ひと
りの管理者のパスワードは毎回同じで使い捨てではありません（時系列に沿っ
て）。
よって、間違ってメールが読まれた場合を考えると危険なわけです。


S/KEY 版を実装し、管理用のメールも 使い捨てパスワード にし安全の度合を
あげる予定です。


.S	 さまざまなインターフェイス

   ~/.forward インターフェイス 	 	libexec/fml_lcoal.pl

通常 /etc/aliases をいじるのですが、.forward は本質的に同じものです。
もっとも .forward の場合 user 名以外のものを使うことはできないわけです
が。


   Listserv 互換用インターフェイス 	libexec/fmlserv.pl

fmlserv.pl を呼ぶようにした場合 コマンドは

	コマンド ＭＬ名前 オプション

になります。ようは Listserv 形式のしんたっくすで fml のコマンドを使え
るようにしたインターフェイスです。

	listserv:  fmlserv
	majordomo: fmlserv
	fmlserv: :include:/var/spool/ml/include/fmlserv

のようにしても大丈夫です。

fmlserv.pl のコマンドラインでの --majordomo オプションは 今まで 
majordomo 構造だった directory structure もうけつけるようにするための 
emulation 命令です。



.S	sendmail との通信

デフォールトでは fml は sendmail 等の SMTP配信エージェントと自力で通信
します。

	$Envelope{'mci:mailer'} = 'ipc'; 

がデフォールトですが、

	$Envelope{'mci:mailer'} = 'prog';

とすることで、$SENDMAIL という変数のプログラムを起動して、それに配送を
させることもできます。

	$Envelope{'mci:mailer'} = 'ipc'; 

の場合、自分のマシンで走っている sendmail と通信しようとしますが、
必ずしも自分のマシンで sendmail が走っている必要はありません。

もっとも SMTP を理解してくれるなら sendmail である必要もないですし
配送用に使えるSMTPサーバ があれば動きます。
サイトで走っているSMTPを理解してくれる配送プログラムがあればよいです。
それもなければ、sendmail を 'prog' で起動すればよいだけでよいわけですが…


逆にどうやってメールを受けとるかという問題があります。通常 SMTP を理解
する受けとるサーバが走っていて、メールを受けとり fml.pl へ渡します。

しかし、そうでなくてもよいわけで、例えば 一定時間間隔で POP をかけてＭ
Ｌを動かし、配送はサイトのSMTPサーバにやらせることでＭＬを実行するこは
可能です。


.S	その他の機能


ロックは flock によるロック処理をデフォールトにしています。が flock() 
が動かない場合 UNIX V7 依頼の link() によるロックを使います。

% hack によるリレーサーバを処理します。例えば、関東方面、関西方面にこ
ねがあって、マシンが調達できる場合、関東方面のメールを一回そのマシンに
送ることで関東方面へおくるメールを一つのメールでいっきにおくって、配送
はそのリレー先にまかすことで、配送を高速化できます。

プロバイダ等でDISKに制限があったりする場合は、古い記事は消したいとおも
いますが、そのための Expire 機能をサポートします。

また、同様に newsyslog をサポートし、古いログは自動的に
	e.g. log -> var/log/log.0 
のように変換し保存するようにしています。デフォールトでは members file 
や まとめおくりのログに対して newsyslog を実行しています。

一つのマシン上にある ＭＬ間のクロスポスト の場合、
複数のＭＬに入っている人には一通しか送らないようにします。
＃サイトにまたがる場合はデータのシンクロが必要なため実験段階です


おまけ機能として、スタートレックの宇宙歴をサポート（笑）します。
contrib/Utilities に宇宙歴をつけるmh, mh-e user interface つき:-)です。


.C	Version up と Compatibility 

.S	cp *.pl your-fml-directory

ひろげて *.pl だけ今使っているところへコピーしてください（おしまひ）
＃よく使うライブラリは lib/perl/ の下にlinkしてあります。
＃この下ごと copy するのが楽です

.S	新しい機能を有効にするには？

なお、新しい機能は config.ph へ差分だけを付け加えるか コマンドラインで
指定するかしないと使えません。
つまり、新しい機能・オプションは明示的に指定しない限り単に動きません

.S	Backward Compatibility 

Backward Compatibility は保証していますが 万が一 consistencyのないもの
があったら ＭＬ 等へ御一報ください。
変数の定義の仕方の変更等はあっても内部で自動的に補整してますので気にし
なくて大丈夫です。
＃注意：複雑なフックの場合は注意がいると思います。
＃
＃古いライブラリも一応Packageに一緒に入ってます。
＃lib/Compatibility に移動しておきました。
＃サーバ本体と関係ないもの若干は ./bin の下に移動したものもあります。


.S	1.6より前からの移行について

1.6では、基本的なデータ構造を call by reference 用に書き直したので、
いままでの SMTP_OPEN_HOOK 等の カスタマイズはそのままでは反映されません。
libcompat.pl にBackward compatibility のためのコードがあります。
昔の設定を変えたくないなら、config.ph に 

	$COMPAT_FML15 = 1; 

と書くと複雑なフックをしかけていない限り compatible にできます。
コードの都合上どうしても実現できないカスタマイズもありえます_o_

昔できたことは必ず今の実装でも必ずできるので以下を参照してみて下さい。


.C	用語

以下で使う用語について2、3説明しておきます。

.S	MLのHOME

ML(fml) の HOME は config.ph のある場所です。例えば 
config.ph が /var/spool/ml/elena/config.ph にあるとすると、
directory /var/spool/ml/elena をＭＬのＨＯＭＥと呼んでいます。

現在の実装は config.ph はなくてもかまいません。ですから spool
(/var/spool/ml/elena/spool) や log (/var/spool/ml/elena/log)が作られる
directory (/var/spool/ml/elena) のことだとおもってください。

.S	SMTP

SMTP == Simple Mail Transfer Protocol。 sendmail 間の通信方式のこと。

.S	SMTPでうけるサーバ

sendmail というプログラムが元祖であり、もっとも代表的なプログラムです
が、SMTPを理解すればうけるのは何でも構いません。
例えば、TIS (Trusted Information System) の Gauntlet という Firewall 
では smap というプログラムが受けて queue だけをします。

世の中にはそれ以外にも sendmail もどきのプログラムはありますから、
sendmail に拘る必要はありません。

この文書では Target machine が 4.4BSD なので、sendmail と perl を使う
場合について解説しています。


.S	sendmail

現在も Eric Allman がメンテしている メール配信エージェントのこと。
sendmail は BSDの標準装備です。

どんな複雑な環境でも適応できる柔軟性を兼ね備えている分、security hole 
もありえます。bug つぶしのupdateは非常にはやいです。そのため常に最新版
を使うようにして下さい。

.S	sendmail.cf 

sendmail をコントロールする configration file。これの読み書きができな
いとネットワーク管理者にはなれない（なりたくないって？（泣））。通常は 
motonori さん（motonori@wide.ad.jp）のメンテしている CF パッケージで 
sendmail.cf を簡単に作ることができるが、この見本で十分実用である。

詳しくは、このCFパッケージの日本語マニュアルも参照されたい。

.S	newaliases

/etc/aliases から aliases データベースを作るための操作のこと。
/etc/aliases をいじったら newaliases というコマンドを実行することのこ
と。



.P	インストールとカスタマイズ

ここでは fml の起動の仕方、起動時の設定の有効になる順番について述べます。


.C	fml の基本動作と起動オプション…

.S	ＭＬサーバの動作
.key	ＭＬサーバの動作

	メールが SMTP で送られてくる

             ↓

    	SMTP で待ち構えているプログラムがうけとる
	例えば sendmail が受けとる

             ↓

	fml へ渡す。

             ↓
	フィルター操作（しないなら/etc/aliasesいじるだけ）
	さらにヘッダを一定形式でフォーマットする…
             ↓

	なんらかのリストにしたがって配送


フィルタだけなら sed でも十分だし、“配るだけ”なら Sendmail 8.x でも
十分でしょう。しかし、＋αでログをとり、スプールし、必要なら取り寄せら
れるようにちょこっとだけ複雑なことをしようとするならこの サーバ まで必
要です。


.S	sendmail -> fml の時の動作

sendmail から fml へメールが渡される時は次のように動作します。

○ まず /etc/aliases にある

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で、sendmail はこのファイルを実行します。

	/usr/local/list/Elenaの中身は

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"

のようになっています。

次に fml が上の引数（上例では コマンドラインオプションがないが）は 
/var/spool/ml/elena/ を Elena ML の home directory だと見なし
/var/spool/ml/elena/config.ph に従い fml の設定を行います。

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは 	/usr/local/list/Elena の中で

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

や（デフォールト）

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena --distribute "

のように書きます（コマンドラインオプションをつける場合）。

引数の書き方の順番は任意です。引数の最初の directry をMLのホーム
(config.phのある場所 もしくは spool やメンバーファイルのある場所)と見
なします。


.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena "

のように起動されるわけですが、この場合

	/usr/libexec/fml/fml.pl 
の
	/usr/libexec/fml 
部分をとりだします。そして

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた（複数可能）場合、例えば

	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は

	1   /var/spool/ml/elena 
	2   /usr/libexec/fml 
	3   /usr/lib/uja
	4   /lib/uja

のような順番でファイルを探します。


.S	オプション設定の優先順位

強い順番に並べると

	1   コマンドラインオプション (fml.pl -d や --distribute 等)
	2   sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3   各MLごとの config.ph による設定
	4   fml デフォールト設定

大抵の program と同様ですね。



.# ##########################################################
.#	command line options
.include clo.wix


.C	Install && Configurations
.label	{configuration}

ここはおおむね概論です。細かい詳細（フラッグ等のsetting）は後の章を御
覧下さい（その名前の章があれば…ですが）。


.S	Version up

Version up は *.pl をコピーすれば終りです。
＃fml 1.x 時代への注意は .seealso{appendix:fmlR1}


.S	インストール後にサーバの設定（パラメータ）をいじるには？
.key	fml.plの起動のしかた
.key	exec fml.pl
.key	$DIR
.key	$LIBDIR
.key	fml.c
.key	fml.plの引数
.label	{c-wrapper}

例によって複数のやり方があります:-)

○	ひとつしかMLがない場合
	
	config.ph をいじるか コマンドラインオプションで変更します。
	
○	複数のMLがある場合

	ML固有の変更はそれぞれのMLの config.ph へ変更を加えるか

	include file 等で fml.pl --distribute のようにコマンドラインオ
	プションで変更するか？

ですが、複数のMLに共通の設定であれば libsmtp.pl 等がおいてある場所に 
sitedef.ph を作って、これの中にいれておくとよいでしょう。


.S	fml.plの呼び方、引数の渡し方(4.3BSD)
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list
.label	{calling-fml.pl}
.seealso fml-uid, plural-handling-1, plural-handling-2, plural-handling-3

fml.pl の中に変数は今はもうありません（fml 1.2）。

fml.cの中でfml.pl directoryという形で呼ぶようになってます。
＃ fml.pl config.phのあるdirectry libaries の形で呼ぶ

上と同じことを↓こういう書き方（ちゃんと動くか否かはsendmail の 
version依存）ができます。

	/etc/aliases では

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

	/usr/local/list/Elenaの中身は

	"|/usr/libexec/fml/fml.pl directory"

こうするとElena（ファイル）の所有者のＩＤで動くようになります。



.S	fml.plの呼び方、引数の渡し方(4.4BSD or POSIX)
.label	{calling-fml.pl-POSIX}
.key	POSIXなsetuid
.key	POSIX
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list

もし POSIX なら 

% make OPT=-DPOSIX 

とすると、 uid gid を今の環境からわりだして自動的にこういう風にcompile
します。↓
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
perl sbin/ccfml cc -s -O -DPOSIX   fml.c -o fml
O.K. I'll try to guess your OS...
-f /usr/include/sys/types.h
-f /usr/include/unistd.h
#	... No OS= option specified; dynamically determining OS type
#	... OS appears to be "nos4"

cc -s -O fml.c -o fml  -DXXUID=65536 -DXXGID=999 -DPOSIX  -DOS=nos4 
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

fml ができたら スーパーユーザー権限で

# chown root fml
# chmod 4755 fml

これで、setuid が動くはずです。この場合は root の権限で一回動いて あな
たのuidに設定して fml.pl を起動します。
＃これ最後の手段だから…

こういう時は /usr/local/ml/driver/fml とかにして そこは root 以外は絶
対に書けないとかにしておくくらいの注意を払いたいものです。
それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。管理者の方と相談して見てください。

新しい発見 or bugがあったら fml-support ML か fml-bugs （fukachan@ に
のみフォワード）に御一報くださいませ _o_


.S	binary の driver 


	/usr/local/list/Elena というファイルを sendmail が実行し
	その中身は
	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"
	のように書いてある。

と上述しましたが、このやり方が変なOSもしくは古いsendmailでは駄目な場合
があります。

その場合次のような setuid された driver(binary) を使うということになり
ます。fml.c をいじり、compile します。fml.c は通常 最初の make の時に
あなたの環境に併せて変更されていますが、確認はしてみてください。

それは次のような内容です。fml.c の中に

	fml.plの場所   config.phのある場所   ライブラリの場所

の形でexecするように埋め込んで最初にcompileしました。
directoryを変えるにはここを書き換えてrecompileです。
＃since 1.1.2.17 1994.3.14 version

例： fml.c

execl("/usr/spool/EXP/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/usr/spool/EXP", /* config.ph は どこ？ */
      "/usr/spool/lib", /* fml packeage の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル等を見ながら直してみて下さい。

version up は *.plファイルをコピーするだけなので 一度設定すれば driver 
の設定を変更する必要ありません。

.S	binary の driver 


	/usr/local/list/Elena というファイルを sendmail が実行し
	その中身は
	"|/usr/libexec/fml/fml.pl /var/spool/ml/elena"
	のように書いてある。

と上述しましたが、このやり方が変なOSもしくは古いsendmailでは駄目な場合
があります。

その場合次のような setuid された driver(binary) を使うということになり
ます。fml.c をいじり、compile します。fml.c は通常 最初の make の時に
あなたの環境に併せて変更されていますが、確認はしてみてください。

それは次のような内容です。fml.c の中に

	fml.plの場所   config.phのある場所   ライブラリの場所

の形でexecするように埋め込んで最初にcompileしました。
directoryを変えるにはここを書き換えてrecompileです。
＃since 1.1.2.17 1994.3.14 version

例： fml.c

execl("/usr/spool/EXP/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/usr/spool/EXP", /* config.ph は どこ？ */
      "/usr/spool/lib", /* fml packeage の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル等を見ながら直してみて下さい。

version up は *.plファイルをコピーするだけなので 一度設定すれば driver 
の設定を変更する必要ありません。

ただ、この binary driver 方式では root に setuid した binary を作る必
要があります＃ POSIX 準拠の場合

これは、非常にいやらしいし、setuid コマンドは慎重に扱う必要があります。
それでできれば sendmail が正しく動いて setuid の部分をうけもってくれる
ことが望ましいとおもわれます。


.S	fml.plの呼び方 と OS一覧
.label	{calling-fml.pl-and-OS}
.key	OS_dependence

INSTALLにOSのまとめ一覧があります。ご覧ください


.S	まとめおくり
.label	{msend-0}
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.seealso msend-c, msend-1, msend-2, msend-3

選択肢は
	Release 4 で system にbundleされたCRON をつかう
		か
	fml の cron.pl (CRON clone)
	を使う

各ユーザーごとに

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を（ユーザーが）えらべます。

ソースは MSendv4.pl があれば十分で、
[Ｎ通たまったらメールを送る まとめおくり]だけは別で
Contrib/Matomeokuri-NOCRONの下に
	store-and-deliver.ph	(configuratio file)
	store-and-deliver.pl
があります。

くわしくは、まとめおくりの章をご覧ください
.seealso msend-c

まとめおくり Release 4 は
「特定時間になるとactivesの情報に基づき、その時間におくることになって
いる人に、まだ送っていなかった分のメールをスプールから取り出して送る」
ということをしています


.S	コントロール専用アドレス
.label	{control-addr}
.seealso calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス
.key	コントロール専用アドレス

config.phの中で

$CONTROL_ADDRESS = 'Elena-ctl';

をセットすると、 Elena-ctl宛のメールはコントロールコマンドのルーチンだ
けしか呼ばないようになります。つまり、このアドレスにくれば間違ったメー
ルがきても配送はしない

この場合/etc/aliasesに

	Elena-ctl:"|/usr/libexec/fml/fml"

とか書くことが必要です。
＃あ、newaliasesも忘れずにね


.S	メンバーチェックのはなし
.seealso	auto-regist

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトはメンバーチェックを行なう(subroutine
MLMemberCheck)。

チェックするか否かはconfig.phの中で

$ML_MEMBER_CHECK = 1;		# if non-nill, do a member check

で指定します。ここを（↓自動登録ということ）

$ML_MEMBER_CHECK = 0;		# if non-nill, do a member check

にすると見知らぬ人から来た場合その人を自動的に登録して配布モードにはい
るようになる（subroutine MLMemberCheck）。
注意：自動登録の場合はactivesを使わずmembersファイルがmemberとactives
の両方を兼任する形になっています。

単にメンバーチェックをしない時はMLMemberCheck が常にreturn 1; としても
いいでしょう


.S	$MAINTAINERって何？
.key	UNIX FROM
.key	$MAINTAINER

“大雑把に”いうとエラ−メ−ルの帰る場所です。
＃エラーが変える時にこれがＭＬ宛になっていると無限ループするわけですね

[歴史]	hml 1.6 はこのアドレスを

	sendmail -f"$MAINTAINER"

の形で使っていました。


.S	他の人にＭＬのスプールを見せないような設定はどうするんですか？

% ls .
Elena	lib	driver

という directory とする。
＃以下省略して書くので適当にdirectory名は補ってください

driver/driver には "|lib/fml.pl Elena lib"

lib Elena は 700、driver は755としておけば、

	sendmail(uid = 1)
	→	
	driver/driver を起動すると、uidが あなたのuidに変わる。
	→	
	ここから後は、lib, Elena は自分のuidになっているので、700でＯ
	Ｋです。


.S	デバッグモード
.label	{debug-mode}

デバッグモードのフラッグ。１がデバッグモード。配送以外のことは全部でき
るので、テストに使って下さいませ。０にすると配送もするようになります。
.key	$debug
	$debug        = 1;

.S	配送されるメールのヘッダのカスタマイズ
.seealso header-custom

.S 	OS, MISC: OTHER CUSTOM OPTIONS
.seealso config-misc

.S HOOKS: ML-specific hooks e.g. "# list"
.seealso	customize

フックの章をみてください



.C	配送のモード

.S	DEFINE_MODE マクロ

マクロというのは正確ではないですが、config.ph で 簡易モード設定ができます。

特に歴史的な理由で自動登録とメンバーチェックをするモードの設定はわかり
にくいので、このモード設定をつかうと楽かも知れません。

モード設定は config.ph を評価した後行なわれます。そのため、

config.ph の中で

	メンバーチェック
	&DEFINE_MODE('autoregist'); # 自動登録

とか書くと、自動登録モードになり、メンバーチェックと宣言したことは 
overwrite されてしまいます。

注意：コマンドラインオプションはこの定義よりも強いのに注意して下さい。

config.ph の中で
	メンバーチェック
	&DEFINE_MODE('autoregist'); # 自動登録

でもコマンドラインで

	fml.pl --distribute ...

のようになっていた場合は、distribute モード（メンバーチェックも自動登
録もせずに、配送しスプールするだけのモード）に設定されます。

モード一覧は コマンドラインオプションを見て下さい。
コマンドラインで

	--mode

のように指定する内容を config.ph 中では同じことを

	&DEFINE_MODE('mode');

のように書けば実現できます。

例：

	"| /uja/fml.pl /DIR --distribute  "
は
	/DIR/config.ph で &DEFINE_MODE('distribute');

と同じ


.S	簡易モード一覧

詳細はコマンドラインオプションの項を見てね。
また、ソースを見るなら、libmodedef.pl です。

	distribute	配送だけ
	hack		ローカルハック用
	fmlserv		listserv emulation
	fml		デフォールト
	hml		hml emulation
	emudistribute	distribute を emulate(配送だけ＋ヘッダ変換等)
			注意：↑ distribute というprogramもあるのである 
	html		var/html に html 化した記事も作っていく
	check		メンバーチェック
	commandonly	コマンドだけを実行するサーバ
	mime		MIME 変換した記事等を置くなど MIME オプション
	through		すどおし
	auto		自動登録（どういうメールが来ても登録）
	autosubject	subject: subscribe のキーワードを必要とする
	autobody	メール本文にsubscribe のキーワードを必要とする
	cack		コマンドをだれでも実行できる（ + trick の時有用）


ソースより(以下 libmodedef.pl 2.0.2)：
.q
sub ModeDef
{
    local($mode) = @_;

    &Debug("ModeDef::$mode()") if $debug;

    require 'libhack.pl' if $mode eq 'hack';

    &FmlServMode    if $mode eq 'fmlserv';
    &FmlMode        if $mode eq 'fml';
    &HmlMode        if $mode eq 'hml';
    &EmulateDistributeMode if $mode eq 'emudistribute';
    &HtmlMode       if $mode eq 'html';

    if ($mode eq 'check')       { $ML_MEMBER_CHECK = 1;}
    if ($mode eq 'commandonly') { $COMMAND_ONLY_SERVER = 1;}
    if ($mode eq 'mime')        { $USE_MIME = 1;}
    if ($mode eq 'through')     { $SUPERFLUOUS_HEADERS = 1;}
    if ($mode eq 'auto')        { $ML_MEMBER_CHECK = 0;}

    if ($mode eq 'autosubject') { 
	$ML_MEMBER_CHECK = 0;
	$REQUIRE_SUBSCRIBE = "subscribe";
    }

    if ($mode eq 'autobody')     { 
	$ML_MEMBER_CHECK = 0;
	$REQUIRE_SUBSCRIBE = "subscribe";
	$REQUIRE_SUBSCRIBE_IN_BODY = 1;
    }

    if ($mode eq 'caok') {	# command anyone ok
	$Envelope{'mode:anyoneok'} = 1;
	$PROHIBIT_COMMAND_FOR_STRANGER = 0;
    }

    1;
}
.~q


.S	自動登録について
.seealso fml-mechanism
.key $ML_MEMBER_CHECK
.key 自動登録
.key 自動登録の仕方のヴァリエーション

$ML_MEMBER_CHECK が 0 とか "" のようになっている時が
”自動登録モード”
	で、
”それ以外はメンバーチェックをするモードです”。

コマンドラインオプションでは

 --auto
	投稿者がメンバーでない場合自動的にMLに登録する

 --check 
	投稿者がMLのメンバーか否かチェックを行う

です。

例：
	/usr/libexec/fml/fml.pl /var/ML-dir --auto 


そして、自動登録で使うアドレスと、メールでどういうふうに明示的な意志表
示をしてほしいか？のvariationが以下の話です。

.key 登録に使うアドレスはどこから選ぶ？
登録に使うアドレスはどこから選ぶ？：
From: を見てメンバーチェックをし、知らない人かどうかを決めています。
明示的に普段の From: と違うアドレスで登録したいなら
＃例えば、ＭＬからのメールは マシン名つきのアドレスでうけるとか？

本文の先頭に subscribe email-address（変更したいもの） を書いて下さい。
＃Reply-to はLoopbackだけならともかく危険なので、自動登録の時は考慮す
＃るのをやめました。

	自動登録のパターンは
	見知らぬ人からメールがきた	→

	１．	自動的に登録してそのままＭＬにフォワードする。	
	.seealso auto-regist-4

		ＯＦＦ会用ＭＬなんかに便利です。
		例：「出席します」メールがそのまま流れる


	２．	自動的に登録してそのままＭＬにはフォワードしない
	.seealso auto-regist-3

	３．	そのメールにSubject: subscribe のようなキーワードが必要
		（キーワード必須）
.#	.seealso auto-regist-6

	４．	そのメール本文に subscribe のようなキーワードが必要
		（キーワード必須）
.#	.seealso auto-regist-7

のVariationがあります。くわしい設定はそれぞれのセクションを見て下さい。

＃注意：２の”フォワードするか否か？”は１、３、４と独立事象です。つま
り、２ｘ３＝６通り

基本的な挙動は、

	メンバーチェック（もしくはしない）、失敗したらロックを外して終り
	見知らぬ人からのガイドの要求ならガイドを送る。
	＃See INSTALL, README, config.ph

	&MLMemberCheck; が呼ばれると

	ここでは、
	１．メンバーファイルと比較して
	２．見知らぬ人なら	
	３．メンバーファイルに登録して（ここからはlibutils.plを使う）
	４．管理者へ知らせ
	５．WELCOME（ぱふぱふぅ〜♪）というメールを返す

というのをします。この５↑のために config.ph に
	
	$WELCOME_FILE	= "$DIR/guide";		# could be "$DIR/welcome"
	$WELCOME_STATEMENT = 
	"Welcome to our $ML_FN\n You are added automatically\n";

というのがあって $WELCOME_FILE は歓迎の文章を書いたファイル（とりあえ
ず、guideにしておいてあります）で、そのメールの Subject が

	$WELCOME_STATEMENT = 
	"Welcome to our $ML_FN\n\sYou are added automatically\n";

になります。


.S	再配送だけをするサーバ（コマンドを必要としないサーバ）
.key	再配送だけをするサーバ
.seealso	--distribute

単に配送を待って、それをスプールすることだけを目的にするMLを作ることも
あるでしょう。つまり ガイドを相手に返すこともなく、単に再配送するだけ
です。

	コマンドラインオプションの --distribute はそういう目的です。

		
.S	コマンド専用サーバ

fmlのデフォールトの挙動は

	メールの最所の３行のどこかが 
	# command（英文字だけの塊）
	の場合コマンドモードへ移行する

です。これは 配送するのか？コマンドを実行するのか？の切替の合図に #
command を使っているからです。
Emacs の C- (control) とか vi のモード切替えみたいなものです。

コマンドしか受け付けないアドレスなら "# command" syntax じゃなくてもい
いはずでず…	それは次説参照


.S	特殊目的専用のサーバへの変更
.key	特殊目的専用のサーバへの変更
.label	server-for-command-only

$CONTROL_ADDRESS にアドレスを登録すると コマンド専用になります
別の汎用の仕方として、

	$LOAD_LIBRARY = 'libfml.pl'; 

のようにバインドしたら コマンド専用だし、

	$LOAD_LIBRARY = 'libftpmail.pl'; 

とすれば、ftpmail 専用のアドレスに早変わりです。

それは $LOAD_LIBRARY が設定されていると、配送じゃなくて、そのライブラ
リを実行するように動くからです


.S	リモートで管理する設定
.seealso	REMOTE-ADMINISTRATION

SMTPってしょせん…なのでデフォールトではリモートでサーバを管理するよう
にはなっていません。リモートで管理もできるようにモードを変えるには、

	コマンドラインオプションで --remote か

	$REMOTE_ADMINISTRATION = 1;

としてください。デフォールトではパスワードを要求する設定です。
＃つまり   $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1; の状態

パスワードは $DIR/etc/passwd に crypt された形で保存されます。

新たにパスワードを初期化する場合は
	bin/passwd -i mail-address new-passwod
のようにしてください。

例：
	% bin/passwd -i fukachan@sapporo.iij.ad.jp password

fukachan@sapporo.iij.ad.jp のパスワードを password という文字列に
設定する（実際にこんな間抜けなパスワードを付けてはいけません:-）

カスタマイズするべきファイル等は

   アドミンと認めるメンバーのリスト（Email-address）
   $ADMIN_MEMBER_LIST	= "$DIR/members-admin";

   アドミンのコマンドのHELPファイル
   $ADMIN_HELP_FILE	= "$DIR/help-admin";

   リモート管理にパスワードを要求する場合には１に
   $REMOTE_ADMINISTRATION_REQUIRE_PASSWORD = 1;

   その場合のパスワードを保存するファイル
   $PASSWD_FILE        = "$DIR/etc/passwd";

詳細は(.seealso REMOTE-ADMINISTRATION )を見てくださいませ。


.# ##########################################################
.include msend.wix
.include remote.wix


.C	自動登録
.label	{auto-regist}


.S	基本挙動

	１．メンバーファイルと比較して
	２．見知らぬ人なら	
	３．メンバーファイルに登録して
	４．管理者へ知らせ
	５．WELCOME（ひゅ〜ひゅ〜どんどんぱふぱふぅ）というメールを返す
	６．	→ そのメールをＭＬにフォワードする（配送）
	   or	→ そのメールをＭＬにフォワードしない（配送しない）
	７．管理者にはいづれの場合でもメールをフォワードする


.S	メンバーチェック or 自動登録
.seealso auto-regist

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトはメンバーチェックを行なう(subroutine
MLMemberCheck)。

チェックするか否かはconfig.phの中で

.key	$ML_MEMBER_CHECK
$ML_MEMBER_CHECK = 1;		# if non-nill, do a member check

で指定します。ここを

$ML_MEMBER_CHECK = 0;		# if non-nill, do a member check

にすると見知らぬ人から来た場合その人を自動的に登録して配布モードにはい
るようになる（subroutine MLMemberCheck）。
注意：自動登録の場合はactivesを使わずmembersファイルがmemberとactives
の両方を兼任する形になっています。

自動登録は３ｘ２種類もヴァリエーションがあるので、詳細については自動登
録の章を御覧下さい。デフォールトはメンバーチェックをするのですが、上の
フラッグを変えた時は、「自動登録して、かつそのメールをＭＬに流す」とい
うＯＦＦ会用の設定になってます。
.seealso auto-regist

.key reply-to
それから ＲＦＣ８２２を素直に解釈すれば登録の時に reply-to: をみて明示
的に登録したいアドレスの変更ができるようにするべきな気がします。
しかし、実際やってみると結構変なことが置きます。
ヘッダをいじらない、つまり reply-to は前のメールから何も考えずにつけた
ままにする人とかいろいろです。

そこで明示的にアドレスを変えたい時は listserve のようにBody に

subscribe Email-address

とかいてあれば変更、ないときは From: からアドレスを決定します。
このキーワードの変更は

.key	$DEFAULT_SUBSCRIBE
$DEFAULT_SUBSCRIBE = "subscribe";

です。

注意： 
	$REQUIRE_SUBSCRIBE = "subscribe";

は自動登録の時に”必ず subscribe syntaxが必須” です。

デフォールトはガイド以外の見知らぬ人からのメールはメールの内容とはかか
わらず登録です。


.S	自動登録した時にそのメールをフォワードするか否か？
.seealso	{auto-regist}
.seealso	{auto-regist-3}
.key	$AUTO_REGISTERD_UNDELIVER_P

	$AUTO_REGISTERD_UNDELIVER_P = 1;

自動登録はデフォールトでは登録要請をしているそのメールをＭＬへ流さない。
つまり、「Subscribe」としか本文にないメールは流さない

メール	→	登録	→ＭＬへ流す（デフォールト、
					$AUTO_REGISTERD_UNDELIVER_P = 0;）

				→ＭＬへは流さない
					$AUTO_REGISTERD_UNDELIVER_P = 1;）

注意： この変数をセットしても subscribe だけのメール（じつは８行）は 
デフォールトでも流しません。管理者以外は見てもうれしくないでしょ？
８ ＝ １ ＋ ３行本文 ＋４行シグニチャア ってことで

デフォールトは $AUTO_REGISTRATION_LINES_LIMIT = 8; となってます
これを -1 にしておけば、たとえ 中身なしメールでも流れます:-)
＃０だと、８に変更されてしまうから


.S	自動登録の時にSubject: subscribe と明示的に書いてもらうようにしたい
.key	Subject: subscribe 

明示的な自動登録をする時にセットして下さい。
例えば Subject: subscribe とか書いてもらうようにしたい時です。

	config.ph に使いたいキーワード（e.g. subscribe）を次のようにセッ
	トすると、そのキーワードがある時に登録を行ないます。

.key	$REQUIRE_SUBSCRIBE
	$REQUIRE_SUBSCRIBE = "subscribe"; 

デフォールトはセットされてません：
	$REQUIRE_SUBSCRIBE = "";	# e.g.  "subscribe";

例：
	$REQUIRE_SUBSCRIBE = "subscribe";

ちなみに、このメールを ＭＬ本体にフォワードさせるか否か？
.key	$AUTO_REGISTERD_UNDELIVER_P
	$AUTO_REGISTERD_UNDELIVER_P = 1;
とは独立な事象です


.S	同様だが自動登録の時にメール本文にsubscribeと明示的に書いてほしい
.key	$REQUIRE_SUBSCRIBE_IN_BODY
.key	$REQUIRE_SUBSCRIBE

上と同様に	config.ph で
	$REQUIRE_SUBSCRIBE = "subscribe"; 
に加え
	$REQUIRE_SUBSCRIBE_IN_BODY = 1;

のようにします。すると本文の先頭をみて判断します。（注意！最初の一行だ
けです）

ちなみに、これを ＭＬ本体にフォワードさせるか否か？
	$AUTO_REGISTERD_UNDELIVER_P = 1;
とは独立な事象です。


.S	メンバーチェックはしないけど自動登録はしたくない(+ trick)
.label	{auto-regist-1}
.key	+
.key	/etc/aliases＋アーカイブ

membersに

	+

とだけ書いて

	$ML_MEMBER_CHECK  = 1;


とすると、メンバーチェックはしないけど登録もしないという動きをします。
＃ＮＩＳにならう:-)


.S	自動登録モードで、複数アドレスから投稿だがうけとりは一つ( skip )
.key	skip
.key	s=skip
.key	複数アドレスからの投稿だが受けは一つ
.label	{auto-regist-2}

自動登録では見知らぬアドレスは全部新しい人とおもってしまうのですが、少
数の人だけが

	複数アドレスから投稿可能だが
	うけとりはあるアドレスに送って欲しい

という場合を考えて、members(自動登録では actives と兼任) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証（新人さんチェック）には使うけど配送はしないというア
クションをします

つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

今の話とは無関係ですが 
fukachan@phys.titech.ac.jp	matome

の行もスキップしています。まとめ送りの人だから


.S	From と 配送先が一致した時に、配送を止めたい(dynamical skip?)
.key	$skip{'mail-address'}
.key	skip
.key	skip-but-determined-dynamically
.key	$START_HOOK

こういう処理を config.ph にかいてください。

$START_HOOK = q#
	$skip{'fukachan@phys.titech.ac.jp'} = 1
		if &AddressMatch($From_address, 'fukachan@phys.titech.ac.jp');
#;

こうすると fukachan@phys.titech.ac.jp あてのメールは skip します。
↑ここは actives とかに現れるものと同じにして下さい。

複数あるなら 全部を うえのフックに加えて下さい。


.S	自動的に登録してそのままＭＬにフォワードする
.label	{auto-regist-4}

これが一番シンプルなやつですね。もともとＯＦＦ会用ＭＬなんです。
＃「いきます」メールがＭＬにながれると便利だから


.S	自動登録モードだと最初のメールから全部流れてしまうのはちょっと…？
.label	{auto-regist-3}
.key	$AUTO_REGISTERD_UNDELIVER_P

config.ph の中で 
	$AUTO_REGISTERD_UNDELIVER_P = 1;

なら 登録要請をしている最初のメールはＭＬへ流さないようになります。
デフォールトは０で 流してしまいます。

ＯＦＦ会用ＭＬなんかだと流れててしまう（「わたしもいきま〜す！」メール）
方がよいのですが…ケースバイケースですよね


.S	ＯＦＦ会とかでも subscribe一行だけのメールはＭＬに流さなくても…？
.key	$AUTO_REGISTRATION_LINES_LIMIT 

登録要請をするメールで８行に達しない（つまり７行まで）のメールは、大抵
『subscribe』とsignature４行くらいしか書いてなかったりするので、ＯＦＦ
会用ならともかく自動登録で使う時は

	$AUTO_REGISTRATION_LINES_LIMIT 

の値以下の行数のメールはＭＬサーバから配送されません。
＃もちろん管理者には知らせます

$AUTO_REGISTRATION_LINES_LIMIT を明示的にセットしないと、８行にセット
されます。

config.ph では一応

	$AUTO_REGISTRATION_LINES_LIMIT = 0;

とセットしています。


.S	サーバーをインストールしたホストからのメンバーの自動登録ができない

.q

FROM: fukachan@phys.titech.ac.jp
正確には user@domain フォームでない ILLEGAL なメールアドレスに 対して
なんらかの Operation を実行するのはよくない。
という根拠に基づいて…ということですが

localhost とからとか条件をつければ出来るでしょうけど（getpeername()）

user@domain フォームでない ILLEGAL なメールアドレス がすどおりして、サ
イトを越えて Deliver されてしまうようなこともあるので、
＃もちろんよくないが実際に出来てしまう。

変な補整を加えてしまうとかえってまずいとおもうんです。

.~q

＃＃＃＃＃＃＃＃＃＃

対策編１：
ってことなんですが、
“From行のアドレスに@以下をつけないでメールが送られてくる”
をやらせないために、
メール本体に subscribe uja@localhost-name.uja.jp とかかけばＯＫってい
えばＯＫなんですけどね（↑ From: より優先されるから）

対策編２：
自動補整も やってやれなくはないです。でも変なこと（or illegal）
がおこってもおこらないでね:-) YOUR OWN RISK

$START_HOOK  = q#
	if ($From_address !~ /\@/) {
		$From_address = "$From_address\@ローカルなドメイン";
	}
#;

ローカルなドメイン は自分のドメイン




.C	fml のプロセス

.S	律速段階
.key	何がどこが遅くさせるか？

律速段階はやっぱり sendmailの配送プロセスそのものでしょう。
この部分の overhead は R5 にくらべ R8 では非常に改善されましたが
それでもかなりのものです。

論理をひっくりかえすと、fml 自体を tuning して速度を例えば 0.1 sec 上
げても ML の配送プロセスには何のメリットも生じないということでもありま
す。

余計なプロセスがついても、配送速度には効きません。それよりはいろいろな
ことができたほうがおもしろいでしょう？という思想的背景はここに起因しま
す。

これを改善する方法は基本的に複数の sendmail で作業を分割することです。

１	十分なパワーのマシンで十分な file descriptor や 
	多くの process が走っても大丈夫であれば、
	複数の sendmail を起動して配送を試みる。
	この場合ちゃんと Load Average と sendmail.cf を tune する
	必要がある。 
	
２	非力でも複数のマシンが用意できるなら複数のマシンでパラレルに実行

３	リレーサーバを用意する。例えば東京方面、関西方面のように分けて
	一回そのリレーサーバに投げて、そこから再配送をする。

１、２は”MCI_… ” という変数群がそれを可能にします。

リレーサーバは各ユーザごとに”管理者”が設定できます。
リレーサーバは相手のマシンに負荷をかけるり、ネットワークトポロジーを
考慮の上決めるべきです。
また、fml のリレーハックは RFCにはない % hack を前提にしています。
そのため、管理者が注意深く設定すべきです。



.S	プロセスは誰の権限で動くか？
.key	uid
.key	setuid
.key	ユーザー権限ということ
.label	{fml-uid}

「プロセスは誰の権限で動くか？」というのは sendmail 自体は root 権限で
走っているからで、fml 実行時は fml 管理者のプロセスとして走ります。
システムに「 fml 管理者の プロセスとして走る」用に命令することが
システムによって違うことがあるので少し厄介なことが発生します。

○ローカルに fml にメールを投げる

	自分のuidで実行します

○外からメールがやってきたら？
	つまり sendmail がうけとって fml を起動する場合

	外→	
		sendmail は uid = 0 で待っている(デーモン)
		＃昔の sendmail だと daemon の場合もあるだろう

		→ setuidしてユーザー権限 (uid=your own) にして
		   fml.pl を起動し、メールを fml.pl へ渡す
		＃これは fml.c で作った fml を使うか
		＃:include list 形

.seealso configuration, calling-fml.pl, msend-0, msend-1, msend-2, msend-3, msend-dir

ここでsetuidの話が関係するわけです。

各ＯＳでどう setuid をすればうまくいくか？ は次の節にまとめてあります。

注意：以下のまとめは昔 INSTALL に書いてありましたが、INSTALL のサイズ
は適当な大きさに押えたいので細かいデータはすべてこの doc/op に収録して
いくことにしてます。


.S	/etc/aliases と ＯＳ依存性（make する時 OPT=-DPOSIX が必要か？）

make すると fml という "C Wrapper" (setuidをするもの) が生成されます。
fml（fml.c から作られる）自体は、make の時 fml.c を自動的に補正してく
れているはずです。

/etc/aliases では
	Elena: :include:/some/directory/include-file 
		もしくは
	Elena: "|/some/directory/fml-2.1/fml"
の両方の書き方ができますが、ＯＳによってうまくいったりいかなかったりし
ます。現在では include-file 形式が普通のような気がします。

sendmail が setuid をちゃんと実行できないからで、ターゲットマシン(4.4
BSD )以外では挙動がまちまちみたいです

問題は“ setuid のしかた”で大別すると、以下の２種類に別れます

 [4.3BSD]
	fml でも :include: でもOKでしょう

 [4.4、POSIX準拠のOS、その他]
	:include: 式か 
	最後の技;-) rootにsetuidされたfml(make OPT=-DPOSIX)	

以下は実際にテストされたOS一覧です

	キーワード：
	uid		ownerが自分自身で 4755 した fml
	include		sendmail に setuid をまかせる :include:を使う
	root		ownerがrootで 4755 した fml
			＃こういうことは最後の手段であまりやりたくない…

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
4.3BSD			uid include
4.4BSD 			include
BSD386 1.1		include
SUN4.1.2 - 4.1.3JLE 	uid include
Solaris 2.4 		include
Solaris 2.3J 		だめ？
DEC OSF/1		[:include でかつ perl -U が必要（なぜ;_;？）]
OSF/1 Alpha AXP V2.1 	include
HP UX 9?		[:include でかつ perl -U が必要？]
			＃なんか、setreuid しかないんだけど…＞HP-UX
SVR3 [4.3BSD とおなじ]	uidでＯＫのはず

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
manualで確認した機種一覧
4.3BSD系	SONY NEWS 4.x
		4.1.3JLE
		SVR3

POSIX準拠	4.4BSD
		NetBSD 
		BSD/OS 2.x
		BSD386 1.1
		Solaris 2.4	

その他の注意：
・単に NFS ごしだからうまくいかなった という場合(オチ;-)もあるでしょう

そのときはsetuid する時だけ local ならいいわけで、
たとえば /usr/local/ml/fml とかを作ってもらってfml.pl自体は NFS ごしの 
home とかにおいてある という風にしてあればＯＫでしょう

・NFSごしにファイルが存在すると setuid を認めない機種 もある
たとえば
		SUN 4.1.3JLE 4.1.4
		＃これは fpathconf の return 値が問題

・uid と include を試してみてどっちもうまくいかなかったら
最後の手段（root）： 

まず fml.c をPOSIX版で 作りなおしてください（make OPT=-DPOSIX）。
make OPT=-DPOSIX として make してください

root のケースでは rootでしかかけない /usr/local/ml/driver 
とかにインストールしてもらうとかしたほうがいいとおもいます。取り扱いに
は注意してくださいね。管理者とよく相談してみてください（重要）
＃もしかしたら sendmail が呼ぶ関数のどこかで rootのsetuid をみとめない
＃かもしれないということもあるかもしれない。単にＮＦＳかもしれないが:-)






.C	コマンドの実行に関する２、３のこと…

.S	コマンドの # syntax は必要か？ 

“コマンド専用のアドレスにメールが来た時だけ”は考える必要がないですね
もし、コマンド専用のアドレスで

	# get 1
		も
	get 1

同じにコマンドとして動いて欲しいなら＃もちろん off bye 等も同様

	コマンドラインオプションで --commandonly か
	$COMMAND_ONLY_SERVER = 1; と config.ph に書く

かしてください。

もっとも、こうしておくと listserv とかわりませんな:-) 
.seealso fmlserv


.S	コマンドは一辺に実行できるか？

	% cat foo
	# get 1
	# get 2
	# get 3
	# help
	# summary
	% cat foo | Mail ＭＬのアドレス

とすると、1 2 3 の記事を取り寄せ、ヘルプとさらにサマリーファイルもとり
よせるという働きをします。bye を除き 一行一コマンドなら順番にすべて実
行します。

それは各行ごとにどんどん処理をするようになっているからです。
＃ ただし # exit はコマンドの終りです。ここで exit = end = quit


.S	コマンドは一辺に実行できるか？２
.label	{command-plural2}

でも、
	% cat foo
	uja
	# get 1
	# get 2

というファイルだとエラーです。最初の３行のどこかで#ではじまる行があれ
ばコマンドモードとみなして処理を行なうためです。
最初の行は空行で２行目に#があるメールが、間違えてながれたりしないため
の防止機構です。この“３”行の“３”を変えたいときは

config.ph の中の
	$COMMAND_CHECK_LIMIT = 3;（最初の３行をチェックする）
を変えます。


.S	間違ったコマンドへの警告
.seealso USE_WARNING 

デフォールトでは警告しません。

$USE_WARNING = 1; でない限り、間違ったコマンドへの警告メールをだすこと
はありません。これは signature を自動的に付ける設定をしている場合への
対処です。 

# exit 等で明示的にコマンド指定を終わらせるほうがよりよいでしょうが


.S	コマンドの終り（シグニチャア対策）
.key シグニチャア対策

# exit 
# end
# quit

を追加しました。このコマンドのところでアクションは終了します。
シグニチャアがあってもいいように、こうしました。


.S	各種directory ($TMP_DIR = './tmp'; を各種作業に使います…)
.key	$TMP_DIR

デフォールトでは $DIR/tmp (つまり $TMP_DIR = './tmp';) を使います。
変更したい場合は 1.3.1.3 からは $TMP_DIR をセットして下さい。

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。

private communication なので public な場所にファイルを残すことはしない
方針なのです。

その他にも 4.4BSD 風の directory 構造の中に各種のログやキャッシュが保
存されています。


.S	コマンドの結果を送り返すときにヘルプやなにかの情報も付加する設定

	$PREAMBLE_MAILBODY	（前）
	$TRAILER_MAILBODY	（後）
	を本文の前後に必ず付けます。

つまり、
	e.g. HELP コマンドにたいして、

	$PREAMBLE_MAILBODY	（前）
	HELPファイル本文
	$TRAILER_MAILBODY	（後）

のようにです。

おまけ：

もし、なんらかの理由で普通の配送時のメールになにか付けたいなら
＃それは、人の郵便をかってに開けて、人の手紙に手を加えるようなもので、
＃倫理的に許されないと思うが…世の中いろいろなんだそうです

$SMTP_OPEN_HOOK = q#
	$Envelope{'Body'} .= $PREAMBLE_BODY.$Envelope{'Body'};
#;

とでもすればよいでしょう。普通のＭＬのメールに $PREAMBLE_BODY がついて
配送されます。

これと同様にすれば、本文にメールカウントを埋め込むことも可能になります。

$SMTP_OPEN_HOOK = q#
	$Envelope{'Body'} .= "Mail Count: $ID\n\n".$Envelope{'Body'};
#;


.include forward.wix
.include fml_local.wix


.# ##########################################################
.C	fml 本体一つで複数のメーリングリストを運用する
.key	複数のメーリングリストの運用
.label	{plural-handling-1}
.seealso c-wrapper, calling-fml.pl


「	in /etc/aliases

	ML-1: "|fml ML-1"
	ML-2: "|fml ML-2"

はできるか？もしくはfml を用いて複数のメーリングリストを運用する時に、
fml 本体は一つに済ませて、メーリングリスト毎に必要なファイルだけを分割
できるか？」という命題ですが、次をどうぞ(^^;)


.S	ひとつのfmlで複数のＭＬを扱う方法(fml.plの引数について)
.label	{plural-handling-2}
.seealso c-wrapper, calling-fml.pl

まずconfigurationはfml.plの引数(/etc/aliases or fml(C wrapper))と
config.phの２箇所ですべてです。そして基本的に

	fml.pl	config.phのdirectory libraryの場所

の形で与えています（.seealso c-wrapper )。プロセスの最初で directory を評
価するので、config.phはfml.plの引数のdirectoryのパラメータの下の
config.ph（members, log等もここのを見ます）をみているわけです。

例えば ＭＬのおき場所が
＃以下すべて適当に directory 名は省略してます。

	Elena/config.ph
	manami/config.ph
	lib/fml.pl
	lib/libsmtp.pl

なら、次のように起動すれば

	lib/fml.pl Elena  lib 
	lib/fml.pl manami lib 

上は Elena/config.ph を評価して Elena ＭＬ、
下は manami/config.ph を評価して manami ＭＬにかわります。
ライブラリは lib の下の lib*.pl等をみているわけです。
＃問題はfml.plが使うライブラリがどこにあるかで
＃	“一番簡単な手は /usr/local/lib/perl にいれてしまう”
＃というものです:-) ＃これはコンパイルの時 perl にはいっているはず。
＃それがいやな場合のために
＃
＃	fml.pl	"directory(config.ph)"	"Perl libraries"
＃
＃と解釈するようにしました。（from 1.2.0.6）

ただ、それぞれ非常に違うＭＬでlibfml.pl等もばらばらのものにしたいなら
書き換えてそれぞれのdirectry(e.g. Elena)におけばいいでしょう。

include する時は 

	/usr/local/lib/perl   Elena   library

の順で探しますから（先にマッチしたところで取り込むから）
(see also Appendix about @INC)

注意１：ＭＬ独自の fml.pl にしてしまったら上の論法は使えません（あたり
まえ）。fml.c も書き換えておく必要があります。
ただし、コマンドの改造はフックを用いれば簡単です
.seealso	command-hook



.S	ひとつのfmlで複数のＭＬを扱う方法(setuid programをばらばらに作る)
.key	setuid-program
.key	setuid-source-exapmles
.label	{plural-handling-3}

setuid program をばらばらに作ればいいわけです。
＃可変引数をとる setuid program は security hole になり得るからいちい
ち作る

で、中身は上と同じことをするように次のように作ります。後は同じです。

例えば、 /usr/spool/driver の下に
	manami
	aiko
というのを作るとしましょう。
＃manami → ML-1、 aiko → ML-2 :-)

	% cc -s -o manami manami.c
	% chmod 4755 manami
	% cc -s -o aiko aiko.c
	% chmod 4755 aiko

そして /etc/aliases に
manami:"|/usr/spool/driver/manami"
aiko:"|/usr/spool/driver/aiko"

＃fml.c を参考にして下さい。これは↓4.3BSDです
   ------------------- manami.c -------------------
#include <stdio.h>
main()
{
  setuid(geteuid());
  setgid(getgid());
  execl("/usr/spool/lib/fml.pl", 
	"(fml)", 
	"/usr/spool/manami", 
	"/usr/spool/lib", 
	NULL);
  exit(1);
}
   ------------------- aiko.c -------------------
#include <stdio.h>
main()
{
  setuid(geteuid());
  setgid(getgid());
  execl("/usr/spool/lib/fml.pl", 
	"(fml)", 
	"/usr/spool/aiko", 
	"/usr/spool/lib", 
	NULL);
  exit(1);
}
   -------------------------------------------------


.S	ひとつのfmlで複数のＭＬを扱う方法(setuid をちゃんとするsendmail）
	上のセクション及び .seealso calling-fml.pl

上のセクションにならいます。

/etc/aliasesでsetuidをちゃんとやってくれるという自信があれば、
＃つぅか Sendmail の問題ですが…

例えばこんなかんじでしょう
＃ほんとに最終仕様かどうかは知りません。将来変わるのかも…

	/usr/spool/driver の下に
		manami
		aiko

	/usr/spool/driver/manamiの中身
	"|fml.pl /usr/spool/manami /usr/spool/lib"

	/usr/spool/driver/aikoの中身
	"|fml.pl /usr/spool/aiko /usr/spool/lib"

	in /etc/alises
	
	manami: :include:/usr/spool/driver/manami
	owner-manami: fukachan

	aiko: :include:/usr/spool/driver/aiko
	owner-aiko: fukachan

この場合/usr/spool/driver/manami の所有者権限で実行されるので適宜設定
してください。あとは上のセクションと同じ。


.S	複数のＭＬがあるけど、コマンドの処理は一つのアドレスで一括してやりたい
.key	コマンド専用アドレスその２
.comment beth2

今 master.fml というそのためのアドレスを作ったとします。 

解説０：
ｆｍｌ は メンバーへの配送サーバ ＋ そのサーバの抱えているスプール等へ
	のコマンドを制御する

解説：で、今の場合（ｍａｓｔｅｒ．ｆｍｌ）は ｆｔｐ、 WWW 等へのアクセ
スの中継と、（おまけで）ｆｍｌ（ＭＬサーバ）群への中継をおこなう

例：	だから シンタックスは次のようになります。
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

普通のＭＬ宛のメール	→	sakisan@phys...(e.g. サキさん)

サキさんの 記事１をとりよせる。

"# get 1"		→	sakisan@phys...(e.g. サキさん)
もしくは（推奨↓）
"# get 1"		→	sakisan-ctl@phys...(e.g. サキさん)
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

一方、一箇所で集中管理したい場合（master.fml）のほうでは
WWW.phys.titech.ac.jp へのアクセス

"www http://www.phys.titech.ac.jp/"	→	master.fml@phys..

サキさんの 記事１をとりよせる。

"# get sakisan 1"	→	master.fml@phys..
       ↑ここにはＭＬ名が入る（ここが要注意）

となってます。実は中でＭＬサーバへただ中継してるだけです（笑）

コマンド一覧：（<list>はＭＬ名（アドレスの＠前の部分））
help		<list>
objective	<list>
guide		<list>
msg		<list>
member		<list>
members		<list>
active		<list>
actives		<list>
summary		<list>
on		<list>
off		<list>
bye		<list>
get		<list> <filename>
mget		<list> <filename>

end
quit
exit	

本来の目的は	www, ftp, wais, gopher とのＩＰＣの中継をする
おまけ機能で 
subscribe ML-address とか
member ML-address とか
which とか
できる（あくまでおまけ）＃実は単にＩＰＣの中継してるだけ:-)



.# ##########################################################
.C	ヘッダのカスタマイズ
.label	{header-custom}


.S	ヘッダのフォーマット
.key	ヘッダの保存
.key	@HdrFieldsOrder 
.key	--through

fml はヘッダのフィールドの成形を行います。これは配列変数

	@HdrFieldsOrder 

に従い、その順番に並べかえます。凝る場合:-)は、 @HdrFieldsOrder を 
config.ph 等で定義してください。

@HdrFieldsOrder で定義された必要なフィー
ルドのみをきりだしますが、Received: Return-Receipt-To: を除くすべての
フィールドを使うには

	$SUPERFLUOUS_HEADERS = 1;

かコマンドラインで --through と定義してください。
例：
	fml.pl $DIR --through 



.S	Cc: フィールドを“つけない”

デフォールトではつけますので、切り落とすときは

	$NOT_USE_CC = 1;


.S	ヘッダでの MIME 問題
.key	$PREVENT_MIME

デフォールトでMIME の３つのフィールドを通しています。

	MIME-Version:
	Content-Type:
	Content-Transfer-Encoding:

	$PREVENT_MIME = 1; 

とするとこれらのフィールドを切り落とします。
＃つまり MIME反対派の方は $PREVENT_MIME をセットしてください


.S	MIME Decoding を行なう
.key	MIME
.label	{MIME-1}
.key	$USE_MIME

各種の MIME Decoding を行うためには、

	$USE_MIME	= 1;

と定義します。これを定義した場合

	「summaryに書くsubjectをMIME decodeをしてから書き込む」

ようになります。

例：
	……
	Subject: Re: TELEPHONE 
	=?ISO-2022-JP?B?GyRCJD0kcyRKJCEhQRsoQg==?=

	……
というメールが来たとすると、summary ファイルには

	94/04/03 20:47:47 [1:fukachan@phys.t] Re: TELEPHONE そんなぁ〜

と記録されます

注意：subject をちょんぎったりはしませんが、一行にしてからdecodeして全
部書いてます。summaryは１行１メールがわかりやすくていいでしょ？


.S	MIME Decoding を行なうに関するメモ…

ISO-2022-JP の文字がない限りは require しません（ま、たいして軽くはな
らんが…）。

.key RFC1522
RFC1522	2. Syntax of encoded-words

   encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
   charset = token    ; see section 3
   encoding = token   ; see section 4
   token = 1*<Any CHAR except SPACE, CTLs, and especials>


.S	配送するメールのMIME部分はDecodeしてから配送したい
.label	{MIME-2}
.seealso MIME-1

＃注意：以下試していない。

sub Distribute で

    for (@HdrFieldsOrder) {
	$lcf = $_; $lcf =~ tr/A-Z/a-z/; # lower case field name

という部分を

    for (@HdrFieldsOrder) {
	if (/ISO\-2022\-JP/o) { $_ = &DecodeMimeStrings($_);}

とすれば ISO-2022-JP で始まる部分だけをMIME decodeします。
実はこうすると、本文の中のMIMEもDecodeしてしまいますね(^^)


.S	MIMEのカスタマイズ変数
.label	{MIME-customizing}
.key	$MIME_VERSION
.key	$MIME_CONTENT_TYPE
.key	$MIME_MULTIPART_BOUNDARY
.key	$MIME_MULTIPART_PREAMBLE
.key	$MIME_MULTIPART_TRAILER

右辺はデフォールトの値（Built-in）です。

$MIME_VERSION = '1.0';

$MIME_CONTENT_TYPE = 'multipart/mixed;';

以下は MIME/Multipart で使う変数です。

$MIME_MULTIPART_BOUNDARY = "--Thu_18_May_95_02:36:26--"

な形で日付を設定します。

そのあと、これら↓の変数を設定してます。

	$MIME_MULTIPART_DELIMITER  = $MIME_MULTIPART_BOUNDARY;
	$MIME_MULTIPART_DELIMITER .= "\nContent-Type: message/rfc822\n";
	$MIME_MULTIPART_CLOSE_DELIMITER = $MIME_MULTIPART_BOUNDARY;

くぎり

$MIME_MULTIPART_BOUNDARY = 

本文の前口上

$MIME_MULTIPART_PREAMBLE = なし

本文の後につく部分

$MIME_MULTIPART_TRAILER = なし


.S	Subject: の成形 ([Elena:ID] を抜く)
.key	Subjectから[Elena:ID]を抜く
.key	$STRIP_BRACKETS

	$STRIP_BRACKETS = 1;

とすると、Subjectから [ML:fukachan] みたいな部分をカットする。
これは Subject: [Elena:ID] の形で配送するための前処理です。

	    # e.g. Subject: [Elena:001] Uso...
	    $contents =~ s/\[$BRACKET:\d+\]\s*//g;
	    $Subject = $contents;

にしちゃいました:-)。つまり multiple Re: 問題はサーバがメール本文をい
じるのは気持ち悪いので、そういうことを極力少なくするために（Subjectの
変更は個人がやってくれると期待して）いじらないことにしました。


解説：昔は、

	Subject: Re: [*] Re: サブジェクト
				→	Subject: Re: サブジェクト
	Subject: Re: [*] サブジェクト
				→	Subject: Re: サブジェクト
	Subject: [*] サブジェクト
				→	Subject: サブジェクト

ということをするために

	if(/^Re:[\s\n]*\[[\s\S\n]*\][\s\n]*Re:[\s\n]*([\s\S\n]*)/o) {
		$Subject = "Re: $1"; next;
	}
	if(/^Re:[\s\n]*\[[\s\S\n]*\][\s\n]*([\s\S\n]*)/o) {
		$Subject = "Re: $1"; next;
	}
	if(/^[\s\n]*\[[\s\S\n]*\][\s\n]*(.*)/o) {
		$Subject = $1; next;
	}
	$Subject = $contents; next;

こんなけったいな処理をしていましたが、やめました:-)
＃このコードにもどせばmultiple Re:を削ることができます。

何のために必要な前処理かというと、次を見てみよう(^^;;


.S	hml 1.6 のSubjectのフォーマット
.S	Subject: [Elena:ID] という形にする
.key	$SUBJECT_HML_FORM
.key	$BRACKET
.key	hml形のSubject

オリジナルの hml 1.6 は
……
From:	エレナさんＭＬ
Subject: [3:fukachan] フリーキックはやっぱりエレナさんが最高さ
……

こんな形のヘッダですね。で、私が嫌いなので:-)、
＃無駄に多いヘッダは嫌いなんですよぉ。To: 見りゃわかるのにX-ML-Nameと
＃か…X-ML-Count は違う種類の情報（Reference）だからいいんですが…

デフォールトは[]ものはなしで、オプショナルで次のようなSubject形になる
ようにしました。

	$SUBJECT_HML_FORM = 1;
	$BRACKET	= 'Elena';

で、こういう形にしようと思いますが、Fromの処理がhml 1.6と違うので
＃今のFrom は ML名 じゃなくて ユーザー名

最近よく見られる形の [MLの名前:articleのID] という形を採用しました。
つまり（今の場合だと）

	Subject: [Elena:ID] サブジェクト
#	Subject: [$BRACKET:$ID] $Subject	というコードが書いてある

の形になります。この場合

	$SUBJECT_HML_FORM = 1; なら $STRIP_BRACKETS = 1;

にしてます（config.phの中で）＃必要なので勝手にonしてしまいます


.S	Subject: を (Elena 100) とかの任意の形に成形する

	fml 	Subject: はいじらない
	hml	Subject: [Elena:100]

なんですが、他のフォーマットを使うために 
例えば、

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '(';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ')';
	$SUBJECT_FREE_FORM_REGEXP = "\\($BRACKET \\d+\\)";

と定義すると (Elena 100) の形になり、Reply のメールの (Elena 99) をは
ずし新しい (Elena 100) をつけるようになります。

他の例： Subject: [Elena 100]

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '[';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ']';
	$SUBJECT_FREE_FORM_REGEXP = "\\[$BRACKET \\d+\\]";

	

.S	ＮＩＦＴＹ対策をするか？（参加者にＮＩＦの人もいる）
.label	{NIFTY}
.label	{$AGAINST_NIFTY}
.label	{against-nifty}

注意：もう必要ないらしい

	$AGAINST_NIFTY = 1;（対策をする）

NIFTY は非常識にも、Errors-to という時代おくれの部分しかみてないので;_;、
config.ph あたりで

	$AGAINST_NIFTY = 1

とするとメール本文に

.key	Errors-To: $MAINTAINER
	Errors-To: $MAINTAINER

がつきます。これで NIFTY からのエラーメールが $MAINTAINER に返るように
なってくれます。後向きな解決法ですが;_;。
＃前向きなのは、みんなで文句をいって直させること
＃でも、僕はアカウントをもってない;_;。アカウントを持ってる人が一年く
らいいいつづけないとだめなんだろうなぁ（はぁ）


.S	Message-IDの保存
.key	Message-ID
.key	Uniq_Identifier_of_Message-ID
.key	$USE_ORIGINAL_MESSAGE_ID

$USE_ORIGINAL_MESSAGE_ID = 1; とすると、オリジナルのMessage-IDを保存し
てヘッダにつけます。デフォールトは fml がつけます。


.S	Message-IDを個人の趣味でカスタム化する
.key	Message-IDのカスタム化
.key	$HEADER_ADD_HOOK

Message-ID: uja@aoi.chan.panic とするなら

$HEADER_ADD_HOOK = q#
$body .= "Message-ID: uja@aoi.chan.panic\n";
#;

と、config.ph にでも書く。あとはずらずらかく（あはは、うじゃ）

他の例：
Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.jp>

$HEADER_ADD_HOOK = q#
$body .= "Message-ID: ".
	sprintf("<19%2d%02d%02d.%05d.%s>\n", $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.jp");
#;


.S	宇宙歴(外国TVシリーズMLで使ってます:-)

   http://www.iij.ad.jp/sapporo/staff/fukachan/href/Startrek/

config.ph で	$APPEND_STARDATE = 1; とすると宇宙歴がつきます:-)

	Date: Fri, 19 May 95 22:31:09  JST
	From: "No.6 Fukachan" <fukachan@phys.titech.ac.jp>
	Subject: Re: Nantonaku Leonard Nimoy 
	To: enterprise@phys.titech.ac.jp (Foreign TV Series ML)
	X-ML-Name: Prisoner
	X-Stardate: [-31]5697.8164

	…本文略…

みたいになります。スタートレックＦＡＱにプログラムがのっています
libStardate.pl はその perl 版です。


.S	1つのMLに複数の投稿用アドレス
.key	1つのMLに複数の投稿用アドレス

何の意味があるのかは聞かないでください（笑）

例：
Elena@phys.titech.ac.jp というＭＬで
Elena@phys.titech.ac.jp	と Anna@phys.titech.ac.jp
の両方を投稿可能にする（いくつあっても全部配列にして ずらずらかけばおなじ。）

config.ph に次のような設定をしてください

@PLAY_TO = (	'Elena@phys.titech.ac.jp', 
		'Anna@phys.titech.ac.jp');

# Here is a playing of "To addresses change"; string to eval
$SMTP_OPEN_HOOK .= q#
    local($a);
    foreach (@PLAY_TO) {
        $a = (split(/\@/, $_))[0];
        if ($Envelope{"to:"} =~ /$a/) {
            $MAIL_LIST = $_;
        }
    }
#;

その複数のアドレスを(ループチェックに使うために) @PLAY_TO が必要です。
配列の先頭がオリジナルのアドレス(==$MAIL_LIST)です。

こうすると Elena になげても Anna に投げても どっちでもＯＫで、
to: と reply-to:を変更します。
＃名前の変更 in 1.5delta. Playing_to  -> SMTP_OPEN_HOOK

＊＊＊ 注意： Playing_to は削除しました。 ＊＊＊
libcompat.pl にBackward compatibility のためのコードがあります。



.# ##########################################################
.C	config.phのその他の設定
.label	{config-misc}
.S	どのマシンのSendmailを使う？

・Sendmailが動くマシン（デフォールトは今ソースを広げたマシンです）

.key	$HOST
	$HOST         = 'localhost';

デフォールトはそのマシンです。もしＭＬサーバのマシン（受けるマシン）が
貧弱ならそのマシンが何十通もメールを送り出すのは酷です。
そういう場合上の変数を書き換えて、別のマシンに配送を任すこともできます。
その時は

	$HOST         = 'beth.foo.bar.ac.jp';

のようにそのマシン名を書いて下さい。
＃ただしgethostbynameできないようなマシンじゃだめですが。
＃もちろんアクセスできないマシンとかではできません（あったりする）

勝手にそのマシンのパワーを使うことになるのでそのマシンを使う許可を得る
べきでしょう。


.S	ロックアルゴリズムの選択と変数の設定
.seealso fml-mechanism, seq-file

＃fml 1.2.2 からあとでは flockでどのＯＳでも大丈夫だとおもいます。

ロックアルゴリズムは二通り用意されてます。
一つはプロセスＩＤで区別するやりかた。もう一つがflock system callを使
うもの。flockがお奨めです

.key	$USE_FLOCK
	$USE_FLOCK    = 1;

でflock system call

	$USE_FLOCK    = 0;

でＩＤを使うやり方にセットできます（デフォールトはflock）。

・プロセスＩＤで区別するやりかたでそのＩＤをもったロック用ファイル
をつくるdirectoryの指定

.key	$LOCKDIR
	$LOCKDIR      = "$DIR/LOCK";

・その場合のデフォールトのＩＤのとり方。

.key	$LOCKFILE
	$LOCKFILE     = "$$";
＃$$はプロセスのＩＤ（% man sh）


.S	# helpとかの形式がいや。#helpとか#getfileがいいの
次節

.S	コマンドの書き方 [e.g. # get 1 と #get 1は同じものとみなす]

コマンドの書き方についてのオプションです。

hml 1.6 では
	# get 1
	# help
のような書き方をしてきました。で、こうでない書き方は解釈してくれなかっ
たので、今度は

	# get 1 と #get 1は同じものとみなす（両方使える）
	すべてのコマンドで同じように "# " -> "#" 解釈する。
	さらに#getfile ...も# get ...と理解する。

としました。つまり、

	# get 1
	#get 1
	# getfile 1
	#getfile 1

は同じもの。同様に

	# help
	#help

も同じものです。

.key	$COMMAND_SYNTAX_EXTENSION
	$COMMAND_SYNTAX_EXTENSION = 1;
	両方解釈するなら１、"# summary"みたいなhml 1.6形だけなら０。


.S	コマンドは一辺に実行できるか？２
.seealso	command-plural2


.S	WHOISを使うか？
.key	whois
.seealso whois
.key	$USE_WHOIS

	$USE_WHOIS = 0;			# Use Whois library

０ならｆｍｌデフォールト（whoisは使わない）。１なら使う。ただし、これ
はｈｍｌとは違い、本物の任意のwhois serverとソケット間通信をするための
ものです。
＃ｈｍｌは独自に自分だけのｗｈｏｉｓを抱えていた（無意味＆＆security
hole）

例：

% echo  "# whois fukachan" | Mail -v Elena@phys.titech.ac.jp

% echo "# whois -h どっかのwhois fukachan" | Mail Elena@phys.titech.ac.jp

は ”どっかのwhois” に聞きにいきます。

	$DEFAULT_WHOIS_SERVER = "localhost";

で デフォールトの whois サーバを変更できます。コマンドの -h オプション
で変更できるわけですが、コマンドの-hオプションが優先します。

例：
	"# whois -h どっかのwhois fukachan"


.S	まとめおくり(Rel. 4)のデフォールトで RFC934 形をつかうか？
.key	$USE_RFC934

	$USE_RFC934 = 0;

まとめおくり(Rel. 4)で、０はデフォールトのUNIX FROMで区切られたメールを
送り出すが、１なら次のような形のものを送るようになる。これは mh の
burstで複数の展開に展開できます。
＃あと、どういうソフトがあるのか知らない…:-)

９３４形式の例：
------- Forwarded Message
From: uja
Subject: daa 

うじゃ
------- Forwarded Message
From: uja
Subject: daa

あおいちゃんパニック もいいけど せいふくもの もよくてよ
------- Forwarded Message


.S	まとめ送りのデフォールトを RFC1153 digest へ
.label	{RFC1153}
.key	RFC1153

これは それぞれに通し番号をつけなければなりませんので、まとめおくりの
デフォールトを1153にすることになります。

つまりコマンド # matome 3 はgzip ではなく 1153 形を意味します。

config.ph で $USE_RFC1153_DIGEST = 1; としてください。

デフォールト以上の細かい部分は librfc1153.pl でフォーマットを決めてく
ださい

注意：
一時期 デフォールトで 3時間に 強制的に設定しておいてある version があ
りますが、ようは番号の整合性をとるためです。
１時間おきの１１５３送りの人と、３時間おきの１１５３送りの人、があると
番号が食い違ってしまいますから

番号の整合性を無視すれば、どうでもいいことなんですが…
とりあえず、この部分はコメントアウトしてあります（95/6/27)


.S	コマンドのフック
.label	{command-hook}
.key	customize-of-commands
.key	コマンドのカスタマイズ
.key	$COMMAND_HOOK

インタプリタですから、コマンドでそのＭＬ独自の機能をもたせたかったら
config.ph にセットして下さい（そうすれば、ＭＬが複数あってもそれぞれ別
様にカスタマイズできる）。

これはリストを返すようにするコマンド "# list" を新たに付け加える例です。

--------- in config.ph ---------
$COMMAND_HOOK =q#
      if(/list/io) {
	  &Logging("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;
--------- in config.ph ---------

この例だとは # 〜 # の間をquoteしています。#...コメントをとかははさめ
ません。
＃q syntax は q# ... # の形で任意の二つの文字（今はたまたま #）の間を
quoteする関数（本当の意味での関数ではないそうだ）

fml 1.3 ではライブラリの多くの機能はこれを使うことを前提にＲＥＡＤＭＥ
等が書かれています。

応用は フックの章 に例題がのっています。



.S	lzh + ish option
.key	lzh
.key	ish
.key	$LHA
.key	$ISH

	# mget 200-210 ish

の用に指定するとlzh して ish(s7 mode)したものを送り返します。

$LHA = "/usr/share/bin/lha";
$ISH = "/home/axion/fukachan/bin/ish";

等をどこかで（config.phとか）で設定して下さい。
しないと上の↑Built-inデフォールト値になります。


.S	SJIS にファイルを変換して送る （lzh + ish option）
.key	lzh
.key	ish

config.ph で $USE_SJIS_in_ISH = 1; をセットしてください。

使う時は jcode.pl を INCLUDE PATH へいれておいてください。
^M ^Z もつけます。すべて、外部コマンドを使わずに自力でやります。


.S	コマンドで単なるシンタックスエラーの警告をしない
.label	{USE_WARNING}
.key	$USE_WARNING

明示的に $USE_WARNING をセット
e.g. in config.ph

	$USE_WARNING = 1;

するとコマンドメールでの単なるシンタックスエラーの警告をしない

e.g. 
# helps 			←コマンドのエラーは警告
＃うじゃ			←シンタックスエラー警告なし
＃しぐにちゃ〜	uja@uja.ac.jp	←シンタックスエラー警告なし


.S	mgetのファイルサイズ（送り返し）
.key	$MAIL_LENGTH_LIMIT

in libsendfile.pl

	$MAIL_LENGTH_LIMIT = 1000;

を変える。Internetならともかく、パソコン通信の人へも配送する時は気を使
いますよね。
＃最近は３０００らしいまで設定可能みたいです(e.g. NIFTY)
＃参照 http://www.iij.ad.jp/sapporo/staff/fukachan/fml/ の下
＃pc-van は何の問題もなかったと思いました（たしか）
   
１０００行でだいたい５０ｋくらいになります。



.S	mgetのシンタックスの Shell Match Pattern(e.g. * 1? )
.key	$SECURITY_LEVEL

$SECURITY_LEVEL < 2 では 

	# mget * 
とか
	# mget 10? 

が使えます。パッケージは １ （Backward Compatibility）にして配布してま
す。＃前のヴァージョンとおなじになるように


.S	mgetのシンタックス

何もしなくても、

# mget 正規表現 送り返されるメールの時間間隔（ｓｅｃ）

	と

# mget2 1-10,5みたいなsyntax 送り返されるメールの時間間隔（ｓｅｃ）

の両方を理解します。サーバが自動的に切替えます。


.S	許されるコマンドのシンタックス

Quoted from 4.4BSD:/usr/share/man/cat1/sh.0 
.q
       Shell Patterns

       A pattern consists of normal characters, which match them-
       selves, and meta-characters.   The meta-characters are
       ``!'', ``*'', ``?'', and ``[''.  These  characters lose
       there special meanings if they are quoted.  When command
       or variable substitution is performed and the dollar sign
       or back quotes are not double quoted, the value of the
       variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (``*'') matches any string of characters.   A
       question mark matches any single character. A left bracket
       (``['') introduces a character class.  The end of the
       character class is indicated by a ``]''; if the ``]'' is
       missing then the ``['' matches a ``['' rather than intro-
       ducing a character class.  A character class matches any
       of the characters between the square brackets.   A range
       of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclama-
       tion point the first character of the character class.

       To include a ``]'' in a character class, make it the first
       character listed (after the ``!'', if any).  To include a
       minus sign, make it the first or last character listed
.~q



.# ##########################################################
.C	アーカイブ, Archive & Expire
.label	{archive}

場所をとるから古い記事にはgzipかけたい。でも一つ一つやるより１００個ず
つとかならさらに効率が上がります。以下を参照

.comment beth
.S	古い記事にはgzipかけたいなぁ、場所をとるから
.key	@ARCHIVE_DIR

config.ph の例：

@ARCHIVE_DIR = ('old');
＃ @StoredSpool_DIR = ('old');はObsolete

spool/1-100	-> +tar+gzip	-> old/100.gz と作っているとする
＃（趣味）僕は恐いので その gzip fileは自分で自動では作らないようにしてい
ます。

これは次のように fml.pl は解釈します。

例えば、"# get 1 " というコマンドを送り込んだとする。その時は
−−−−−−−−−−
$STORED_BOUNDARY（今は100まで）以下の記事の請求（get等）がもしあったら、

	ml-dir/spool/	を探索し、もし、ファイル spool/1 が見つからない時は

	ml-dir/old/	という場所も探し、1-100 までがtar + gzipされて
	いる old.100.gzを送り返す。


.S	gzip fileにしよう！（アーカイブへの変換）
.key	Archive.pl

それには fml-1.3.x/bin/Archive.pl というのを使って下さい。
さらに cron で自動処理するなら次の節を御覧下さい

これは Archive.pl 2000とかすると、２０００までのファイルを１００個ずつ
の塊にして、oldに作ります。変数はArchive.plの先頭でセットしてください。
スプールのオリジナルは消さないので、注意を払って消して下さい（とりかえ
しがききませんから、それは）
＃自分じゃ、こわいのである程度まとまったところでこうやって手動でつくり
ますね、アーカイブは

例えば、

spool/1-100	->  +tar+gzip	-> old/100.gz
spool/101-200	->  +tar+gzip	-> old/200.gz

のようなファイルをoldの下に作るプログラムがfml-1.3.x/bin/Archive.pl で
す。

目的のＭＬの場所にまでいって
% ls 

MSendrc		actives		config.ph	deny
guide		help		list		log
members		objective	seq		spool
summary		welcome

% mkdir old

% perl Archive.pl 3800
…たくさんメッセージが出るが省略…

% ls old

100.gz   1400.gz  1900.gz  2300.gz  2800.gz  3200.gz  3700.gz  700.gz   
1000.gz  1500.gz  200.gz   2400.gz  2900.gz  3300.gz  3800.gz  800.gz   
1100.gz  1600.gz  2000.gz  2500.gz  300.gz   3400.gz  400.gz   900.gz   
1200.gz  1700.gz  2100.gz  2600.gz  3000.gz  3500.gz  500.gz   
1300.gz  1800.gz  2200.gz  2700.gz  3100.gz  3600.gz  600.gz   

spoolの３８００までの１００個ずつのパッケージを作りました。
spoolの方の元メールを自動的に消しはしない（安全のため）ので、
自分で消して下さい。


.S	gzip fileにしよう！（cron で自動処理）
.key	Archive.cron
.key	crontab

cronで自動的（例えば週一日曜の朝とか）に次の形で

	fml-1.3/bin/Archive.cron "MLサーバのdirectory名

をよんでください。 いくつかＭＬがあるなら、シェルスクリプトにまとめて
呼ぶといいでしょう。
＃まとめ送りと一緒とかでもよいですね

Archive.cron の先頭に変数があります

	DIR="$1"
	ARCHIVE="$DIR/bin/Archive.pl"

Archive.pl が gzip化 のメインなのでこれのおき場所をちゃんとセットして
下さい。

例：
----- crontab -----
0 * * * *	fukachan /bin/sh /適当な場所/ML-Archive 2>&1 | Mail あなたのアドレス
-------------------
----- ML-Archive -----
#!/bin/sh

	sh fml-1.3/bin/Archive.cron Elena
	sh fml-1.3/bin/Archive.cron Uja
	sh fml-1.3/bin/Archive.cron Sayori

-------------------


.S	gzip fileにしよう！（理論編）

何故、まとめてgzip化したいのか？

１．一個一個gzipかけると、約半分にしかなりませんが、１００個まとめて書
けると、ヘッダとかの重なりがあるので約２５％にまで圧縮できるようになり
ます。

２．Mail-Countが万を越える頃になるとi-nodeの計算に時間がかかるようにな
るのでファイル数を減らす or ほかの場所に移すことに意味があるようになり
ます。そこでspoolの中身をうつし、１００分の一のファイル数にすると効果
が非常にあります。


.S	expire
.label	{expire}
.key	$FML_EXIT_HOOK

形式： &Expire(場所, 日数(以上古いファイルを消す));

$FML_EXIT_HOOK = q#
	&use('expire');
	&Expire($SPOOL_DIR, 7);
#;

と設定すれば、$SPOOL_DIR 以下のファイルにたいして 7日以上古いファイル
を消します（いきなり消します。注意）

今： libexpire.pl を作った。
旧： expire.pl を perl の inlcude pathのどこかにいれてください

まぁこれだと、毎回起動するたびに一個ずつ消すことになるので、やることの
わりにおおげさですね。

cron で 
	expire.pl -s spool-directory -e expire-period 
とかを設定して、週一くらいで動かせばいいのでは？


.S	expireを残すファイルの数で指定して行なう
.label	{expire_with_number}
.key	$FML_EXIT_HOOK

形式： &Expire(場所, 残すファイル数 , 1（ファイルで実行を指示するため）);

$FML_EXIT_HOOK = q#
	&use('expire');
	&Expire($SPOOL_DIR, 50, 1);
#;

今： libexpire.pl を作った。
旧： expire.pl を perl の inlcude pathのどこかにいれてください

と設定すれば、$SPOOL_DIR 以下のファイルにたいして 
	”５０個残して”（注意）
それ以外の古いファイルを消します（いきなり消します。注意）

cron で 
	expire.pl -s spool-directory -e expire-period 
とかを設定して、週一くらいで動かせばいいのでは？


.S 	いきなりExpireの実験はしないほうが…

$SPOOL_DIR じゃなくて tmp の下に tmp/spool とか作って、実験したほうが
いいですね。


.S	expire.pl コマンドラインオプション
.label	{expire_getopt}
.label	{expire.pl}
.key	$FML_EXIT_HOOK

expire.pl [-h] [-e expire_days] [-s spool_directry] [-n]
    -h                 : HELP
    -e expireする日数
    -s スプール
    -n （残すファイル数を設定して、expireするモード）



.S	logファイルの整理、消去をする → newsyslog
.seealso	newsyslog


.S	newsyslogをする（デフォールト）
.label	{newsyslog}
.key	$NOT_USE_NEWSYSLOG
.key	@NEWSYSLOG_FILES

まとめおくりの MSendv4.pl は日曜朝６時に（デフォールト）

	libnewsyslog.pl を実行します

この３つのファイル（デフォールト）に対し

@NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak")

rm -f var/log/members.4
mv -f var/log/members.3 var/log/members.4
mv -f var/log/members.2 var/log/members.3
mv -f var/log/members.1 var/log/members.2
mv -f var/log/members.0 var/log/members.1
ln -s members.bak 	var/log/members.0

を実行します。必要なら この @NEWSYSLOG_FILES に これ↑をやってほしいファ
イル（log とか…）をつけくわえて 

@NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak", "log")

とか	config.ph に書いておいてください。


.S	cronでnewsyslogをする

たとえば、

0	6	*	*	0	(chdir dir-of-fml; sh bin/newsyslog.sh log var/log)

とかかく


.S	newsyslogをしない
.label	{newsyslog-2}
.seealso	newsyslog
.key	$NOT_USE_NEWSYSLOG

$NOT_USE_NEWSYSLOG = 1; なら実行しません





.# ##########################################################
.include href.wix


.P	トラブル対策

.include os.wix
.include trouble.wix


.P	ライブラリ と hack

.include mget.wix
.include function.wix
.include cwhois.wix
.include fred.wix

.include modify.wix
.include localhack.wix

.include ftpmail.wix

.# ##########################################################
.include hook.wix

.# ##########################################################
.C	WIX Language

言語自体はおおむね nroff like + texinfo like 折衷版くらいです

専用のフォーマッタ bin/fwix.pl を使って４種類のフォーマットで 
マニュアルを生成します。

plain text は
	doc/op そのもの 

html 版は
	make doc でつくってください

nroff と texinfo 版は対応しかけてるところ です。

WIX Language は 
１	nroff 覚え直すのも面倒臭い
２	texinfo, html, nroff, plain text 
	４種類を同時に生成する

ために作られたものです。単に僕が書きやすいか否か？で言語仕様が決まって
ます:-)。ついでに 二か国語対応しかけ code まで入ってたりします;-)



.C	misc
.label	{misc}

.S	はやりのＭＩＭＥ対応については？
.label	{MIME-extension}
.seealso	MIME-1, MIME-2, MIME-3

MIMEまわりは↑を御覧下さい。すべてperlだけで処理しています


.S	ロックアルゴリズム
.key	flock
.key	liblock.pl
.key	pid
.key	rename()

今のは
	1.	flock system call（man flock）

	BSDね。fml 1.2はあまりすっきりしたコードになってないが、1.3は
	かなりすっきりしたとおもう

	2.	pidにもとづくロック（liblock.pl）

	1にくらべ数倍よけいなsystem callがかかる
	＃ちゃんと一周した後も補正している。

	3.	rename() を使う

	rename()をつかって排他制御とか… UNIX V7 の時代からあるやりか
	たですね。結局 1.6 では、これにもどしちゃたんですが…


.S	ロックしてconfig.phのｅｄｉｔをしたい
.key	vipw.pl
.key	bin/vipw.pl
.key	maintenance.pl

flockを使って夜中とかじゃなくてメールが来得る時間帯にメインテナン
スをしたい時は？

% bin/vipw.pl 

とすれば、MLの機能をflockでロックして、

	shell% $EDITOR $PWD/config.ph

を vipw.pl は実行します。maintenance.pl の発展版ですかね

vipw.pl [-d $DIR] [-p] [-h] [-f file-to-edit] [$DIR(of ML)] 
    -h help
    -d ＭＬのconfig.phのあるdirectory
    -p ＭＬのconfig.phのあるdirectoryのしたのetc/passwdを代わりにedit
    -f editしたいファイル
    ＭＬのconfig.phのあるdirectory

すべてを省略した場合 $PWD の config.ph 
もっとも、-f とかの場合ちゃんと ロックしたかったら directory の指定が
必要ですね


.S	maintenance.pl
.key	maintenance.pl

flockを使っていて夜中とかじゃなくてメールが来得る時間帯にメインテナン
スをしたい時は？

maintenance.plはMaintenance用のflockするスクリプトで、fmlと同じロック
ファイルにflockでアクセスしてサーバーを止めるためのものです。中身は
	flock 
	sleep 600 
	flockをはずす
だけです。使い方は

	maintenance.pl -s sleeptime [directory]
# [directory] のデフォールトは PWD です（いまいるところ）

で -s でスリープする時間を変更できます。

flock 使わずに pid 式の ロックを使っているなら
% touch LOCK/1
とでもして、作業の後それを消せばいいわけです。


.S	sendmailとの通信の記録（デバッグ）
.key	var/log/_smtplog
.key	_smtplog
.key	$NOT_TRACE_SMTP

sendmailとのやりとりの記録（もっとも最近のものだけ）デバッグに便利。
（デバッグとか終わっちゃって）もぉ必要なかったら

	$NOT_TRACE_SMTP = 1; 

とconfig.phにかいてください。ログをとらなくなります。



.S	X-MLServer: field って何？
.key	X-MLServer:

起源はデバッグ用だったんだけど（笑）、今の意味は『明示的にＭＬサーバが
ｈｍｌ系である』ことを宣言しているつもりです。無意味ではないと思うんで
すが
＃だってぇ〜hmlじゃないのにhmlのコマンドがＭＬにながれるのをよく見るか
ら:-)

＃けずるときはfml.plの中の sub Distribute のX-MLServerって行をコメント
＃アウトなりなんなりしてください


.S	違うアドレスから来たメールは？
.S	アドレスチェックを緩めたい or 強くしたい
.key	$ADDR_CHECK_MAX

メンバーチェックは送られてきたメールの発信者のアドレスと members に書
かれたアドレスとが一致するか否かで判断しています。今の設定は
＃1.3.2からは…緩くした

	fukachan@titech.ac.jp
	fukachan@phys.titech.ac.jp
	fukachan@beth.phys.titech.ac.jp
	fukachan@exelion.phys.titech.ac.jp

はすべて同じにみなしてます。つまり phys.titech.ac.jp のjp側から数えて
３つの部分の判定チェックですね。（木構造のルートから数える）
＃経験的にここまでやれば十分でしょう

４つ（jp ac phys titech の４つ）までチェックしたいなら、

$ADDR_CHECK_MAX = 4;

と config.ph のどっかに書いておいて下さい。$ADDR_CHECK_MAX という変数
が設定されてない場合は３として動きます。


.S	mget でえた spool の下のファイルを mh 以外で読む時
.key	lib/Utilitites/packmbox.pl
.key	packmbox.pl

lib/Utilitites/packmbox.pl を使って、

	(cd spool; packmbox.pl ) > ~/mbox

として、mbox をつくれば、これにたいして、/bin/Mail なり Rmail なりを使
うことができて便利でしょう。


.S	複数アドレスから投稿したいがうけとりは一つ( "# skip" )
.key	skip
.key	noskip
.label	{skip}

複数アドレスから投稿可能だがうけとりはあるアドレスに送って欲しい。
＃この１週間だけこのアドレスも使いたいしぃ〜とかの場合にも効果的です

という場合を考えて、actives(自動登録では members = actives) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証（新人さんチェック）には使うけど配送はしないという動
作をします

つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

ユーザーがこれを自分でコントロールしたいなら、コマンドは
＃ Admin command でのみ引数が有効です。
 
# skip	 [引数]		From:のアドレス もしあれば 引数のアドレスを
			そこから投稿はできるが、配送はされないものと設定する
# noskip [引数]		上の逆。配送するようにする。

です。例：
# skip 
	From: のアドレスを skip に

# skip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp を skip に

# noskip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp へも配送を


.S	.forwardでのＭＬ	その１

もちろん 特別なＭＬ用のUser をつくって ~/.forward を /etc/aliases と同
じように設定すれば できます。
＃なんらかの形で（お金で解決もあり） /etc/passwd をいじれることが条件
ですね


.S	自動送り返しサーバってどう実装してるんですか？ その１
.key	自動送り返しサーバっ実装例１

なんのことはない。ガイドファイルに適当なファイルを設定して、config.ph 
で強制的にガイド送り返ししかしないようにしてしまえば終わりですね。
＃いままで、きづかなかった…

ポイントは、“$START_HOOK にしかける”ってところですね。

例：
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$FML            = '/home/axion/fukachan/work/spool/EXP';
$GUIDE_FILE	= "$FML/doc/INFO";
$LOGFILE	= "$FML/var/log/fmlinfo-log"; # activity log file

$START_HOOK     = q# $Envelope{'req:guide'} = 1;#;

1;
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


.S	自動送り返しサーバってどう実装してるんですか？ その２
.key	自動送り返しサーバっ実装例２

設問：fml-current@phys.titech.ac.jp 宛に送ったメールは自動返送されて戻っ
てくるのですが、こういったものを作るには、どのような設定をすればいい？

いまでは libSendBack.pl ってのにまとまってます。
/usr/ucb/vacation ってのはこれとほぼ同じですね。
＃もっともあれは unix from をみるんですが

理屈は コードをけずっただけ（笑）というだけですが、

０．いつもの通り仕掛ける
１．ロック
２．メンバーチェックをしないで
３．送り返す
	&SendFile($to, "", 目的のFILE);
４．ロックをはずす

in fml.pl MAIN PART

(!$USE_FLOCK) ? &Lock : &Flock;	# Locking 

#---------------- CHANGE -------------------------

$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$INFO_FILE	= "$DIR/INFO";

$LOGFILE	= "$DIR/fmlinfo-log";		# activity log file

$to             = $Reply_to ? $Reply_to : $From_address;

&SendFile($to, "Info $ML_FN", $INFO_FILE);
&Logging("Info request from $From_address");

#---------------- CHANGE ENDS --------------------

(!$USE_FLOCK) ? &Unlock : &Funlock;# UnLocking 
exit 0;				# the main ends.


.S	X-Stardate: をつける（mh-e）

lib/Utilities/stardate.el を load してください
＃ emacs 19 でなきゃかきかえないとだめ

たとえば、.emacs に
(load-libaray "stardate")
(setq startrek-stardate-process "/some-directory-path/libStardate.pl")

とすると mh-comp の draft buffer をつくるときに 
X-Stardate: をつけてくれます。


.S	POP3

まだカスタマイズまで考えてないから、
	bin/inc_via_pop.pl
で、

$POP_EXEC = "|/どっかにおいて/fml_local.pl -user yamazaki";

を、ファイルの先頭辺りに書いて

	bin/inc_via_pop.pl -host popする先のホスト名

ってのを起動してみてください。

pop のパスワードは ~/.netrc のエントリをみるようにしてあります。

$POP_EXEC のデフォールトは mh のスプールへおとすやつをさがすので、
ただコマンドラインで

	bin/inc_via_pop.pl -host popする先のホスト名

とすると、

	/usr/local/mh/inc -noapop -norpop -host popする先のホスト名

とおなじ（まず、これがうごかなきゃだめだね〜）
＃もっともmhがいんすとーるしてなきゃ意味ないけど…


.S	たとえば、Received: のようなヘッダを残すには？

2.1 では

    unshift(@HdrFieldsOrder, 'received');

とすればいいでしょう。もっともこの場合一行だけ Received ではなく 
received になってしまってちょっと情けないかも知れませんが…
＃RFC822 としては大文字小文字は関係ないので問題はない。カッコ悪いだけ;-)


.# ##########################################################
.include smtp.wix
.include uip.wix
.include lib.wix


.P	misc ...

.include perl.wix
.include log.wix


.P	あとがき

.include freekick.wix


.P	Appendix

.include ref.wix
.include app/fmlR1.wix
.include app/sid.wix
.# .include app/obsolete.wix
.# FAQ ENDS


.# $Id$
