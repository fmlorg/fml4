.HTML_PRE
	Fml Operations Guide

	[smm/op.wix: smm = System Management Manual]
	http://www.phys.titech.ac.jp/uja/fml/
	Last modified: 

	このファイルは昔FAQという名前でした。
	FAQ、Setting、改造の仕方等に関するガイドになっています。
	＃注意：なお改造は最新版を手に入れてから行なうのをお奨めします(^^)
	ftp://ftp.phys.titech.ac.jp/pub/net/fml-current/
	http://www.phys.titech.ac.jp/uja/fml/
	＃README, INFOも見てくださいね、んがんん…
.HTML_PRE_END

----------目次----------
#.index

総索引
------------------------


.# ##########################################################
.C	ＭＬサーバ概論


.S	MLサーバは何をすればいいのか？


.S	サーバの中身は？
.label	{fml-mechanism}

ようは Sendmail からパイプで渡されたメールをヘッダと本文にわけて（ヘッ
ダの解析もして）、メンバーへ配送かコマンドを実行するってだけです

さらっと、fml.plのmain partを説明しましょう。

↓
	引数からINCLUDE PATHを設定する(config.ph libaries...)
	基本ライブラリのインクルード(e.g. SMTP)

		&ChkREUid;
	setuid のチェック、もしだめだと警告を出す
	＃おそらく、その場合はその後のどこかで止まるでしょうが

↓	ファイルや日付等のチェック

		&InitConfig
.key		&InitConfig

	最初の空行を境にヘッダー、本体を分ける。
	コマンドモードか否かを最初の3行が#ではじまっているかどうかで
	判断（コマンド専用のアドレスも作る方が建設的かと…）。

	見知らぬ人からのガイド要求チェック

		&Parsing
.key		&Parsing

	From:とかSubject:の中身を切り出す。

		&GetFieldsFromHeader
.key		&GetFieldsFromHeader

	ロックをして他のプロセスは待たせる（コマンド、配送問わず）。

		(!$USE_FLOCK) ? &Lock : &Flock
.key		$USE_FLOCK
.key		Lock
.key		FLock

	もし、特別なことがしたければｈｏｏｋをしかけておく
	＃ＭＬ依存のことです。デフォールトは何もしない

		$START_HOOK && &eval($START_HOOK, 'Start hook'); 
.key		$START_HOOK

	＃＃＃ いよいよ、メインパート↓ ＃＃＃

	もし見知らぬ人からのガイド要求だったら？
	＃See INSTALL, README, config.ph

		if($GUIDE_REQUEST) { 
.key		$GUIDE_REQUEST

	ガイドを送ってあげる

		&GuideRequest
.key		&GuideRequest

	そうでないならＭＬサーバとして動くので、
	メンバーチェックを実行

		} elsif(&MLMemberCheck) { 
.key	&MLMemberCheck

	メンバーチェック もしくは チェックして自動登録なら登録
	＃その区別は この sub MLMemberCheck 内で場合わけしている

	メンバーチェックを通過したら、
	普通にＭＬへ来たメールなのか？
		or 
	コマンド実行する要求なのか？の最終判断をする。

		&AdditionalCommandModeCheck
.key		&AdditionalCommandModeCheck

	配送以外のなんらかのコマンド要求（LOAD_LIBRARYが空でない）だっ
	たら

		if($LOAD_LIBRARY) {
.key		$LOAD_LIBRARY

	$LOAD_LIBRARY(e.g. libfml.pl)を読み込んでコマンドを実行
	＃デフォールトでは require 'libfml.pl'; と同じ

			require $LOAD_LIBRARY;

	もし、コマンドなら $LOAD_LIBRARY ＝ libfml.pl つまりコマンドを
	実行する。config.ph等で $LOAD_LIBRARY を設定しておけば常にその
	ライブラリ（$LOAD_LIBRARY）をよび、○○専用、例えばftpmail専用
	サーバ等に設定できる（ために汎用化した（1.3.2））。

	コマンドでもなければ配送（ＭＬ本来の挙動）を実行

		} else {
			&Distribute;
.key			&Distribute

	ロックを外しておしまい（通常はここで終り）

		(!$USE_FLOCK) ? &Unlock : &Funlock;# UnLocking 

	■以下は必要に応じて■
	なにかユーザーへ伝えることが起きていたらメールを送る
	例：エラー等の通知。
	&Notify if $_cf{'return'};	# Reply some report if-needed.
.key	&Notify
.key	$_cf{'return'}

	この時点で本体とは直接関係ない残り仕事を”必要”なら実行
	e.g. コマンドのmget とか まとめおくりver.5 をここで実行
	
		&RunHooks;	＃Ｌｉｓｐかいな:-)
.key		&RunHooks

		exit 0

	
.S	ＭＬサーバの考え方？（私見）
.key	ＭＬサーバの理屈

Private Communication を便利にするだけのツール（Filter）
＃Private→メンバーチェックという考え方になる。

考え方：
メール→Sendmailがうけとる
             ↓
	サーバへ渡す。
             ↓
	フィルター操作（しないなら/etc/aliasesいじるだけ）
	さらにヘッダーをいじるとか…
	＃これくらいならsed＋αでも十分
             ↓
	なんらかのリストにしたがって配送
	＃“配るだけ”ならSendmail 8.xでも十分

＋αでログをとり、スプールし、必要なら取り寄せられるようにちょこっとだ
け複雑なことをしようとするならこのサーバまで必要です。


.S	認証プロセス
.key	認証プロセス

せいぜい数百人（←数字100に根拠はありません。ふつうはそんなにいかないも
の〜ってくらい）程度とおもって線形にファイルを探索します

メンバー数万のオーダーとかいわない限り関係ないとおもうんですが…
＃律速段階はやっぱりsendmailでしょう(sub Distribute)

でも、普通 user@foo.bar.uja の user の exact match でreturn しちゃうか
ら、その後の複雑なマッチング処理はあんまり気にしなくてもよいでしょう
（期待値としての振舞いは）



.S	律速段階
.key	何がどこが遅くさせるか？

律速段階はやっぱりsendmailでしょう。

sub Distribute でＭＸ引く時とかサーバプロセスの後のSendmailの配送が遅
いでしょうねぇ。
＃アクティブな人たちをmember fileの最初にするとすると少しは早いかな:-)
＃後、読み込む前に grep 一発かましてからとかね :-)

ひっくりかえすと、sub Distribute のループとか認証プロセス以外は、少し
くらい余計なプロセスがついても、ほとんど効かないということです。
＃正確なProfileははかってないですけど


.S	動く時のuid はどうなってるの？
.key	uid
.key	setuid
.key	ユーザー権限ということ
.label	{fml-uid}

・ローカルに自分が実験したら

	自分のuidで実行

・外からメールがやってきたら？

	外→	
		sendmail は uid = 1で起動（daemon）
		→ setuidしてユーザー権限(uid=your own)にして
		   → fml.pl を起動する
	＃これは fml.c で作った fml を使うか
	＃:include list 形
	.seealso configuration, calling-fml.pl, msend-0, msend-1, msend-2, msend-3, msend-dir

	→ fml.plに渡す

この辺でsetuidの話とかが関係するわけですね。

各ＯＳでどう setuid をすればうまくいくか？については INSTALL にまとめ
一覧があります。そちらをみてくださいませ


.S	自動登録について
.seealso fml-mechanism
.key $ML_MEMBER_CHECK
.key 自動登録
.key 自動登録の仕方のヴァリエーション

$ML_MEMBER_CHECK が 0 とか "" のようになっている時が
”自動登録モード”
	で、
”それ以外はメンバーチェックをするモードです”。

で、自動登録で使うアドレスと、メールでどういうふうに明示的な意志表示を
してほしいか？のvariationが以下の話です。

.key 登録に使うアドレスはどこから選ぶ？
登録に使うアドレスはどこから選ぶ？：
From: を見てメンバーチェックをし、知らない人かどうかを決めています。
明示的に普段の From: と違うアドレスで登録したいなら
＃例えば、ＭＬからのメールは マシン名つきのアドレスでうけるとか？

本文の先頭に subscribe email-address（変更したいもの） を書いて下さい。
＃Reply-to はLoopbackだけならともかく危険なので、自動登録の時は考慮す
＃るのをやめました。

	自動登録のパターンは
	見知らぬ人からメールがきた	→

	１．	自動的に登録してそのままＭＬにフォワードする。	
	.seealso auto-regist-4

		ＯＦＦ会用ＭＬなんかに便利です。
		例：「出席します」メールがそのまま流れる


	２．	自動的に登録してそのままＭＬにはフォワードしない
	.seealso auto-regist-3

	３．	そのメールにSubject: subscribe のようなキーワードが必要
		（キーワード必須）
.#	.seealso auto-regist-6

	４．	そのメール本文に subscribe のようなキーワードが必要
		（キーワード必須）
.#	.seealso auto-regist-7

のVariationがあります。くわしい設定はそれぞれのセクションを見て下さい。

＃注意：２の”フォワードするか否か？”は１、３、４と独立事象です。つま
り、２ｘ３＝６通り

基本的な挙動は、

	メンバーチェック（もしくはしない）、失敗したらロックを外して終り
	見知らぬ人からのガイドの要求ならガイドを送る。
	＃See INSTALL, README, config.ph

	&MLMemberCheck; が呼ばれると

	ここでは、
	１．メンバーファイルと比較して
	２．見知らぬ人なら	
	３．メンバーファイルに登録して（ここからはlibutils.plを使う）
	４．管理者へ知らせ
	５．WELCOME（ぱふぱふぅ〜♪）というメールを返す

というのをします。この５↑のために config.ph に
	
	$WELCOME_FILE	= "$DIR/guide";		# could be "$DIR/welcome"
	$WELCOME_STATEMENT = 
	"Welcome to our $ML_FN\n You are added automatically\n";

というのがあって $WELCOME_FILE は歓迎の文章を書いたファイル（とりあえ
ず、guideにしておいてあります）で、そのメールの Subject が

	$WELCOME_STATEMENT = 
	"Welcome to our $ML_FN\n\sYou are added automatically\n";

になります。

		
.S	コマンド専用サーバなら "# command" syntax じゃなくてもいいわけで…

	次説参照

.S	コマンドの # syntax は必要か？ 

“コマンド専用のアドレスにメールが来た時だけ”は考える必要がないですね
もし、コマンド専用のアドレスで

	# get 1
		も
	get 1

同じに動いて欲しいなら
＃もちろん off bye 等も同じですが

$COMMAND_ONLY_SERVER = 1;

と config.ph に書いてみてください。
＃もっとも、こうしておくと listserv とかわりませんな:-)


.S	コマンドは一辺に実行できるか？

	% cat foo
	# get 1
	# get 2
	# get 3
	# help
	# summary
	% cat foo | Mail ＭＬのアドレス

とすると、1 2 3 の記事を取り寄せ、ヘルプとさらにサマリーファイルもとり
よせるという働きをします。bye を除き 一行一コマンドなら順番にすべて実
行します。

それは各行ごとにどんどん処理をするようになっているからです。
＃ ただし # exit はコマンドの終りです。ここで exit = end = quit


.S	コマンドは一辺に実行できるか？２
.label	{command-plural2}

でも、
	% cat foo
	uja
	# get 1
	# get 2

というファイルだとエラーです。最初の３行のどこかで#ではじまる行があれ
ばコマンドモードとみなして処理を行なうためです。
最初の行は空行で２行目に#があるメールが、間違えてながれたりしないため
の防止機構です。この“３”行の“３”を変えたいときは

config.ph の中の
	$COMMAND_CHECK_LIMIT = 3;（最初の３行をチェックする）
を変えます。


.S	コマンドの終り（シグニチャア対策）
.key シグニチャア対策

# exit 
# end
# quit

を追加しました。このコマンドのところでアクションは終了します。
シグニチャアがあってもいいように、こうしました。


.S	コマンドのエラー警告

デフォールトではしません。$USE_WARNING =1; とすると変なコマンドがあっ
たらメールでユーザーへ知らせます。
.seealso USE_WARNING 


.S	$TMP_DIR = './tmp'; を各種作業に使います。
.key	$TMP_DIR

1.3.1.3 からは $TMP_DIR をセットして下さい。
セットしないと デフォールトでは $DIR/tmp(つまり $TMP_DIR = './tmp';) 
です。

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。
＃だって private communication だもん


.S	コマンド専用サーバ

コマンド専用のサーバ（登録とか、get とか…）
と
Distribution 担当のサーバ
の２つということですね

コマンド専用のアドレスときには

	$COMMAND_ONLY_SERVER = 1; 

となるようにする（たとえば config.ph にかく）。この時
	# command と command 
は同じです。つまり 

	# get 1 
も
	get 1 

は同じです＃以下同様に各コマンド…

ついでに subsribe コマンドも使えたりします。

さらに $ML_MEMBER_CHECK = 1; だと members と actives 両方にアドレスを
登録します


.S	コマンドの結果を送り返すときにヘルプやなにかの情報も付加する 	

	$PREAMBLE_MAILBODY	（前）
	$TRAILER_MAILBODY	（後）
	を本文の前後に必ず付けます。

つまり、
	e.g. HELP コマンドにたいして、

	$PREAMBLE_MAILBODY	（前）
	HELPファイル本文
	$TRAILER_MAILBODY	（後）

のようにです。

もし、なんらかの理由で普通のメールの場合にも付けたいなら
＃それは、人の郵便をかってに開けて、人の手紙に手を加えるようなもので、
＃倫理的に許されないと思うが…世の中いろいろあるだろう〜？？？

config.ph に $_cf{'ADD2BODY'} = 1; と書いておいてください。
普通のＭＬのメールですら、INFO?がつくようになります。

これを利用して、本文に メールカウントを埋め込むことも可能になります。
＃実際、コマンドモードに入るときに $_cf{'ADD2BODY'} = 1;をしています。



.S	リモートで管理する設定
.seealso	REMOTE-ADMINISTRATION

SMTPってしょせん…なのでデフォールトではリモートでサーバを管理するよう
にはなっていません。リモートで管理もできるようにモードを変えるには、

	$REMOTE_ADMINISTRATION = 1;

としてください。

カスタマイズするべきファイル等は

    アドミンと認めるメンバーのリスト（Email-address）
    $ADMIN_MEMBER_LIST	= "$DIR/members-admin";

    アドミンのコマンドのHELPファイル
    $ADMIN_HELP_FILE	= "$DIR/help-admin";

   リモート管理にパスワードを要求する場合には１に
    $REMORE_AUTH        = 0;

    その場合のパスワードを保存するファイル
    $PASSWD_FILE        = "$DIR/etc/passwd";

詳細は(.seealso REMOTE-ADMINISTRATION )を見てくださいませ。



.# ##########################################################
.C	Install && Configurations
.label	{configuration}

ここはおおむね概論です。細かい詳細（フラッグ等のsetting）は後の章を御
覧下さい（その名前の章があれば…ですが）。


.S	Version up

Version up は *.pl をコピーすれば終りです。

さらに RecreateConfig.pl を用いて昔の config.ph の設定を尊重しつつ新し
い機能のためにconfig.ph を作ることができます(from 1.2.1.7)

注意：（たぶん1.2.1.5 ->） 1.2.1.7以降へのヴァージョンアップでは、
RecreateConfig.pl を使うべきです。
（$AUTO_REGISTERD_UNDELIVER_P という変数の設定に関して問題が発生するの
で）。それより昔のものへのヴァージョンアップなら関係ありません。


.S	インストール後にサーバの設定（パラメータ）をいじるには？
.key	fml.plの起動のしかた
.key	exec fml.pl
.key	$DIR
.key	$LIBDIR
.key	fml.c
.key	fml.plの引数
.label	{c-wrapper}

fml.cの中に

	fml.plの場所   config.phのある場所   ライブラリの場所

の形でexecするように埋め込んで最初にcompileしました。
directoryを変えるにはここを書き換えてrecompileです。
＃since 1.1.2.17 1994.3.14 version

例： fml.c

execl("/usr/spool/EXP/fml.pl", /* 本体 fml.pl はどこ？ */
      "(fml)", 
      "/usr/spool/EXP", /* config.ph は どこ？ */
      "/usr/spool/lib", /* fml packeage の library はどこ？ */
      NULL);

これ以外のすべての変数は config.phの中に全部あります。INSTALLやこのファ
イル等を見ながら直してみて下さい。

よってversion upも*.plファイルをコピーすればいきなり使えるようになりま
す。


.S	fml.plの呼び方、引数の渡し方(4.3BSD)
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list
.label	{calling-fml.pl}
.seealso fml-uid, plural-handling-1, plural-handling-2, plural-handling-3

fml.pl の中に変数は今はもうありません（fml 1.2）。

fml.cの中でfml.pl directoryという形で呼ぶようになってます。
＃ fml.pl config.phのあるdirectry libaries の形で呼ぶ

上と同じことを↓こういう書き方（ちゃんと動くか否かはsendmail の 
version依存だろう）でもできる
＃本当にこれが sendmail 8.x の最終仕様なんだろうか？（みたいだなぁ）

	/etc/aliases では

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

	/usr/local/list/Elenaの中身は

	"|/home/axion/fukachan/work/spool/Elena/fml.pl directory"

こうするとElena（ファイル）の所有者のＩＤで動くようになります。


.S	fml.plの呼び方、引数の渡し方(4.4BSD or POSIX)
.label	{calling-fml.pl-POSIX}
.key	POSIXなsetuid
.key	POSIX
.key	fml.plの起動のしかた
.key	fml.plの引数
.key	:include:
.key	onwer-list

もし POSIX なら 

% make OPT=-DPOSIX 

とすると、 uid gid を今の環境からわりだして自動的にこういう風にcompile
します。↓
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
perl sbin/ccfml cc -s -O -DPOSIX   fml.c -o fml
O.K. I'll try to guess your OS...
-f /usr/include/sys/types.h
-f /usr/include/unistd.h
#	... No OS= option specified; dynamically determining OS type
#	... OS appears to be "nos4"

cc -s -O fml.c -o fml  -DXXUID=65536 -DXXGID=999 -DPOSIX  -DOS=nos4 
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

fml ができたら スーパーユーザー権限で

# chown root fml
# chmod 4755 fml

これで、setuid が動くはずです。この場合は root の権限で一回動いて あな
たのuidに設定して fml.pl を起動します。
＃これ最後の手段だから…

こういう時は /usr/local/ml/driver/fml とかにして そこは root 以外は絶
対に書けないとかにしておくくらいの注意を払いたいものです。
それでも、root にsetuid されてると実行しない設定の場合もあるかも知れま
せん。管理者の方と相談して見てください。

新しい発見 or bugがあったら fml-support ML か fml-bugs （fukachan@ に
のみフォワード）に御一報くださいませ _o_


.S	fml.plの呼び方 と OS一覧
.label	{calling-fml.pl-and-OS}
.key	OS_dependence

INSTALLにOSのまとめ一覧があります。ご覧ください


.S	コマンドライン オプション

コマンドラインといっても、デバッグ以外じゃ、/etc/aliasesとかの
"|/Baycity/fml.pl $DIR $LIBDIR -option" の形ですが、

	fml.pl 	   [ options ] $DIR [ options ]  [ $LIBDIR [ options ] ]

	fml.pl MSendv4.pl sid.pl は同じ引数のとりかたをします。
	注意：fml_local.pl は MH を意識してるので異なります。

オプションと引数が共存するときは、引数が -ではじまるならオプション、そ
れ以外は Directoryの変数 だと仮定します。順番は関係ありません
Directory に関しては そのDirectoryが存在すれば、引数の順に $DIR、
$LIBDIR にセットされます。


	-d		デバッグモード
			（ＭＬへの配送以外すべてを実行可能）
	-bt   		アドレステストモード	(Become Test)
			（メンバーチェックのところまで。ＭＬへの配送やコマンドは実行しない）
			いまのところ debug mode とかわらへんねん:-)
	-bd		デーモンモード	(Become Daemon)
	-sOPT $OPT 	をセットする。(e.g. -sdebug == -d)
	-uOPT $OPT 	をオフする。  (e.g. -udebug は $debug = 0; と同じ）
	-lfile	file を $LOAD_LIBRARY 変数に代入する (e.g. -llibfml.pl 下↓参照)


注意：sendmail のように『空白なし』です。(だってその方がコードが簡単なんだもん:-)

例：
	-llibfml.pl とすると、コマンド専用アドレスのできあがりです
	＃ CONTROL_ADDRESS とおなじ意味ですね

	-llibftpmail.pl ftpmail 専用アドレス
	-sdebug		debug mode
	-sFIX_SLOCAL_PIPE	$FIX_SLOCAL_PIPE = 1;と同じ

とかできるわけです

例：
"|/Baycity/fml.pl /Baycity /Baycity/lib -d -sFIX_SLOCAL_PIPE -sDUMPVAR"

デバッグモード かつ $FIX_SLOCAL_PIPE =1; で 変数のダンプを行なう。


.S	コマンド専用のサーバ
.key	コマンド専用のサーバ
.label	server-for-command-only

$CONTROL_ADDRESS にアドレスを登録すると コマンド専用になります
別の汎用の仕方として、

	$LOAD_LIBRARY = 'libfml.pl'; 

のようにバインドしたら コマンド専用だし、

	$LOAD_LIBRARY = 'libftpmail.pl'; 

とすれば、ftpmail 専用のアドレスに早変わりです。

それは $LOAD_LIBRARY が設定されていると、配送じゃなくて、そのライブラ
リを実行するように動くからです



.S	まとめおくり
.label	{msend-0}
.key	UNIX FROM
.key	RFC934
.key	RFC1153
.key	MIME-Multipart
.key	まとめおくり
.key	Cron
.key	Not using Cron
.seealso msend-c, msend-1, msend-2, msend-3

選択肢は
	Release 4 で system にbundleされたCRON をつかう
		か
	fml の cron.pl (CRON clone)
	を使う

各ユーザーごとに

	UNIX FROM形 でメールをひとセットにする
	RFC934形    でメールをひとセットにする
	RFC1153形   でメールをひとセットにする
	MIME/Multipart
	tar + gzip でまとめる
	lzh + ish でまとめる

を（ユーザーが）えらべます。

ソースは MSendv4.pl があれば十分で、
[Ｎ通たまったらメールを送る まとめおくり]だけは別で
Contrib/Matomeokuri-NOCRONの下に
	store-and-deliver.ph	(configuratio file)
	store-and-deliver.pl
があります。

くわしくは、まとめおくりの章をご覧ください
.seealso msend-c

まとめおくり Release 4 は
「特定時間になるとactivesの情報に基づき、その時間におくることになって
いる人に、まだ送っていなかった分のメールをスプールから取り出して送る」
ということをしています


.S	コントロール専用アドレス
.label	{control-addr}
.seealso calling-fml.pl
.key	$CONTROL_ADDRESS
.key	コマンドの専用アドレス
.key	コントロール専用アドレス

config.phの中で

$CONTROL_ADDRESS = 'Elena-ctl';

をセットすると、 Elena-ctl宛のメールはコントロールコマンドのルーチンだ
けしか呼ばないようになります。つまり、このアドレスにくれば間違ったメー
ルがきても配送はしない

この場合/etc/aliasesに

	Elena-ctl:"|/home/axion/fukachan/work/spool/Elena/fml"

とか書くことが必要です。
＃あ、newaliasesも忘れずにね


.S	メンバーチェックのはなし
.seealso	auto-regist

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトはメンバーチェックを行なう(subroutine
MLMemberCheck)。

チェックするか否かはconfig.phの中で

$ML_MEMBER_CHECK = 1;		# if non-nill, do a member check

で指定します。ここを（↓自動登録ということ）

$ML_MEMBER_CHECK = 0;		# if non-nill, do a member check

にすると見知らぬ人から来た場合その人を自動的に登録して配布モードにはい
るようになる（subroutine MLMemberCheck）。
注意：自動登録の場合はactivesを使わずmembersファイルがmemberとactives
の両方を兼任する形になっています。

単にメンバーチェックをしない時はMLMemberCheck が常にreturn 1; としても
いいでしょう


.S	$MAINTAINERって何？
.key	UNIX FROM
.key	$MAINTAINER

“大雑把に”いうとエラ−メ−ルの帰る場所です。
＃エラーが変える時にこれがＭＬ宛になっていると無限ループするわけですね

[歴史]	hml 1.6 はこのアドレスを

	sendmail -f"$MAINTAINER"

の形で使っていました。


.S	他の人にＭＬのスプールを見せないような設定はどうするんですか？

% ls .
Elena	lib	driver

という directory とする。
＃以下省略して書くので適当にdirectory名は補ってください

driver/driver には "|lib/fml.pl Elena lib"

lib Elena は 700、driver は755としておけば、

	sendmail(uid = 1)
	→	
	driver/driver を起動すると、uidが あなたのuidに変わる。
	→	
	ここから後は、lib, Elena は自分のuidになっているので、700でＯ
	Ｋです。


.# ##########################################################
.C	config.phの項目一覧
.key	config.ph
.label	{config}

あくまで Advanced なので慣れてない人はデフォールトでもいっこう
に構いませんし、この章は読み飛ばしていっこうに差し支えありません。
#Mariel
1.3.1.10 前後からは config.ph は項目ごとに並びかえられています。

Advanced の中で今の御時世で特別注意を払うべきなものはこの辺でしょうか
＃次の一覧も御覧下さい

デバッグモード			.seealso debug-mode
$debug		= 1;            

自動登録			.seealso auto-regist
$ML_MEMBER_CHECK = 0;

ＭＩＭＥ			.seealso MIME-1, MIME-2
$USE_LIBMIME	= 1;
$LIBMIMEDIR	= "$DIR/contrib/MIME";

ＮＩＦＴＹ対策			.seealso against-nifty
$AGAINST_NIFTY = 1;		もう必要ないらしい

ロックのしかた
$USE_FLOCK	= 1;		

誤動作コマンドチェック		.seealso command-plural2
$COMMAND_CHECK_LIMIT = 3;

＃簡易config.ph として config.ph-fundamental というのにもっとも基本的
＃なカスタムだけ抜き出したファイルがあります。
＃ここにでてくる変数だけをみるほうがわかりやすいかもしれません
＃つかうなら config.ph-fundamental -> config.ph にしてください


.S	設定一覧（Advanced Setting）


■デバッグモード
$debug		= 1;            

■メンバーチェックと自動登録
$ML_MEMBER_CHECK = 1;		# メンバーチェックするか否か？

・メールの中身を問わずに自動登録する時
$DEFAULT_SUBSCRIBE = "subscribe";
				# ただメールをだせば自動登録の時に
				# 登録アドレスを最初から代えたいなら
				# subscribe Email-address としてもらう。

・共通
$AUTO_REGISTERD_UNDELIVER_P = 1;# 自動登録の時、登録願いメールをＭＬへ
				# フォワードするか否か？

$AUTO_REGISTRATION_LINES_LIMIT = 0;# この行数以下のメール、例えば
				# ただ”subscribe”一行のメールはＭＬ
				# へは流さない
				#（上のUNDELIVER_Pの設定に拘らず）
				#今は 0 の場合デフォールト 8と設定される


・自動登録する時にキーワードを必要とする時

$REQUIRE_SUBSCRIBE = "subscribe";# 自動登録でsubjectに "subscribe" が必要
$REQUIRE_SUBSCRIBE_IN_BODY = 1;	# 自動登録で本文に    "subscribe" が必要


■ヘッダの形

$SUPERFLUOUS_HEADERS = 1;	# ヘッダのadditionalなものをそのまま保存
				# 例えば X-うじゃ の類。
				# デフォールトは切捨て

$USE_LIBMIME	= 1;		# MIME decodingを行なう
$LIBMIMEDIR	= "$DIR/contrib/MIME";
				# MIME decodeをするためのライブラリ

$STRIP_BRACKETS = 0;		# サブジェクト の [Elena:ID] 形を抜く
$SUBJECT_HML_FORM = 1;		# Subject: [Elena:ID] の形
$BRACKET	= 'Elena';	# Subject: [$BRACKET:$ID] ...
				#           ^^^^^^^^キーワード

$AGAINST_NIFTY = 1;		# ＮＩＦＴＹ対策にobsoleteなErrors-to
				# をつける;_;

■ Ｓｅｎｄｍａｉｌとのおつきあい

$HOST		= 'localhost';	# どのマシンのSendmailを使う？

■ＯＳ、その他

$USE_FLOCK	= 1;		# ロックアルゴリズムの選択

$COMMAND_SYNTAX_EXTENSION = 1;	# "#member"形と"# member"形は同じ意味

$COMMAND_CHECK_LIMIT = 3;	# 最初の３行は間違いコマンド探しの対象
				# としてチェックされます。

$USE_WHOIS = 0;			# Whois libraryを使うか？
$DEFAULT_WHOIS_SERVER = "localhost";	# Default whois server

$USE_RFC934 = 0;		# まとめおくりで９３４フォーマット

@ARCHIVE_DIR = ('old');		# gzipした記事群のアーカイブのおき場所


.S	デバッグモード
.label	{debug-mode}

デバッグモードのフラッグ。１がデバッグモード。配送以外のことは全部でき
るので、テストに使って下さいませ。０にすると配送もするようになります。
.key	$debug
	$debug        = 1;


.S	メンバーチェック or 自動登録
.seealso auto-regist

ＭＬサーバはあくまでプライベート・コミュニケイションの延長であると考え
た上での設計なのでデフォールトはメンバーチェックを行なう(subroutine
MLMemberCheck)。

チェックするか否かはconfig.phの中で

.key	$ML_MEMBER_CHECK
$ML_MEMBER_CHECK = 1;		# if non-nill, do a member check

で指定します。ここを

$ML_MEMBER_CHECK = 0;		# if non-nill, do a member check

にすると見知らぬ人から来た場合その人を自動的に登録して配布モードにはい
るようになる（subroutine MLMemberCheck）。
注意：自動登録の場合はactivesを使わずmembersファイルがmemberとactives
の両方を兼任する形になっています。

自動登録は３ｘ２種類もヴァリエーションがあるので、詳細については自動登
録の章を御覧下さい。デフォールトはメンバーチェックをするのですが、上の
フラッグを変えた時は、「自動登録して、かつそのメールをＭＬに流す」とい
うＯＦＦ会用の設定になってます。
.seealso auto-regist

.key reply-to
それから ＲＦＣ８２２を素直に解釈すれば登録の時に reply-to: をみて明示
的に登録したいアドレスの変更ができるようにするべきな気がします。
しかし、実際やってみると結構変なことが置きます。
ヘッダをいじらない、つまり reply-to は前のメールから何も考えずにつけた
ままにする人とかいろいろです。

そこで明示的にアドレスを変えたい時は listserve のようにBody に

subscribe Email-address

とかいてあれば変更、ないときは From: からアドレスを決定します。
このキーワードの変更は

.key	$DEFAULT_SUBSCRIBE
$DEFAULT_SUBSCRIBE = "subscribe";

です。

注意： 
	$REQUIRE_SUBSCRIBE = "subscribe";

は自動登録の時に”必ず subscribe syntaxが必須” です。

デフォールトはガイド以外の見知らぬ人からのメールはメールの内容とはかか
わらず登録です。


.S	自動登録した時にそのメールをフォワードするか否か？
.seealso	{auto-regist}
.seealso	{auto-regist-3}
.key	$AUTO_REGISTERD_UNDELIVER_P

	$AUTO_REGISTERD_UNDELIVER_P = 1;

自動登録はデフォールトでは登録要請をしているそのメールをＭＬへ流さない。
つまり、「Subscribe」としか本文にないメールは流さない

メール	→	登録	→ＭＬへ流す（デフォールト、
					$AUTO_REGISTERD_UNDELIVER_P = 0;）

				→ＭＬへは流さない
					$AUTO_REGISTERD_UNDELIVER_P = 1;）

注意： この変数をセットしても subscribe だけのメール（じつは８行）は 
デフォールトでも流しません。管理者以外は見てもうれしくないでしょ？
８ ＝ １ ＋ ３行本文 ＋４行シグニチャア ってことで

デフォールトは $AUTO_REGISTRATION_LINES_LIMIT = 8; となってます
これを -1 にしておけば、たとえ 中身なしメールでも流れます:-)
＃０だと、８に変更されてしまうから


.S	配送されるメールのヘッダのカスタマイズ
.seealso header-custom

.S 	OS, MISC: OTHER CUSTOM OPTIONS
.seealso config-misc

.S HOOKS: ML-specific hooks e.g. "# list"
.seealso	customize

フックの章をみてください


.# ##########################################################
.C	自動登録
.label	{auto-regist}


.S	基本挙動

	１．メンバーファイルと比較して
	２．見知らぬ人なら	
	３．メンバーファイルに登録して
	４．管理者へ知らせ
	５．WELCOME（ひゅ〜ひゅ〜どんどんぱふぱふぅ）というメールを返す
	６．	→ そのメールをＭＬにフォワードする（配送）
	   or	→ そのメールをＭＬにフォワードしない（配送しない）
	７．管理者にはいづれの場合でもメールをフォワードする


.S	自動登録の時にSubject: subscribe と明示的に書いてもらうようにしたい
.key	Subject: subscribe 

明示的な自動登録をする時にセットして下さい。
例えば Subject: subscribe とか書いてもらうようにしたい時です。

	config.ph に使いたいキーワード（e.g. subscribe）を次のようにセッ
	トすると、そのキーワードがある時に登録を行ないます。

.key	$REQUIRE_SUBSCRIBE
	$REQUIRE_SUBSCRIBE = "subscribe"; 

デフォールトはセットされてません：
	$REQUIRE_SUBSCRIBE = "";	# e.g.  "subscribe";

例：
	$REQUIRE_SUBSCRIBE = "subscribe";

ちなみに、このメールを ＭＬ本体にフォワードさせるか否か？
.key	$AUTO_REGISTERD_UNDELIVER_P
	$AUTO_REGISTERD_UNDELIVER_P = 1;
とは独立な事象です


.S	同様だが自動登録の時にメール本文にsubscribeと明示的に書いてほしい
.key	$REQUIRE_SUBSCRIBE_IN_BODY
.key	$REQUIRE_SUBSCRIBE

上と同様に	config.ph で
	$REQUIRE_SUBSCRIBE = "subscribe"; 
に加え
	$REQUIRE_SUBSCRIBE_IN_BODY = 1;

のようにします。すると本文の先頭をみて判断します。（注意！最初の一行だ
けです）

ちなみに、これを ＭＬ本体にフォワードさせるか否か？
	$AUTO_REGISTERD_UNDELIVER_P = 1;
とは独立な事象です。


.S	メンバーチェックはしないけど自動登録はしたくない(+ trick)
.label	{auto-regist-1}
.key	+
.key	/etc/aliases＋アーカイブ

membersに

	+

とだけ書いて

	$ML_MEMBER_CHECK  = 1;


とすると、メンバーチェックはしないけど登録もしないという動きをします。
＃ＮＩＳにならう:-)


.S	自動登録モードで、複数アドレスから投稿だがうけとりは一つ( skip )
.key	skip
.key	s=skip
.key	複数アドレスからの投稿だが受けは一つ
.label	{auto-regist-2}

自動登録では見知らぬアドレスは全部新しい人とおもってしまうのですが、少
数の人だけが

	複数アドレスから投稿可能だが
	うけとりはあるアドレスに送って欲しい

という場合を考えて、members(自動登録では actives と兼任) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証（新人さんチェック）には使うけど配送はしないというア
クションをします

つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

今の話とは無関係ですが 
fukachan@phys.titech.ac.jp	matome

の行もスキップしています。まとめ送りの人だから


.S	From と 配送先が一致した時に、配送を止めたい(dynamical skip?)
.key	$skip{'mail-address'}
.key	skip
.key	skip-but-determined-dynamically
.key	$START_HOOK

こういう処理を config.ph にかいてください。

$START_HOOK = q#
	$skip{'fukachan@phys.titech.ac.jp'} = 1
		if &AddressMatch($From_address, 'fukachan@phys.titech.ac.jp');
#;

こうすると fukachan@phys.titech.ac.jp あてのメールは skip します。
↑ここは actives とかに現れるものと同じにして下さい。

複数あるなら 全部を うえのフックに加えて下さい。


.S	自動的に登録してそのままＭＬにフォワードする
.label	{auto-regist-4}

これが一番シンプルなやつですね。もともとＯＦＦ会用ＭＬなんです。
＃「いきます」メールがＭＬにながれると便利だから


.S	自動登録モードだと最初のメールから全部流れてしまうのはちょっと…？
.label	{auto-regist-3}
.key	$AUTO_REGISTERD_UNDELIVER_P

config.ph の中で 
	$AUTO_REGISTERD_UNDELIVER_P = 1;

なら 登録要請をしている最初のメールはＭＬへ流さないようになります。
デフォールトは０で 流してしまいます。

ＯＦＦ会用ＭＬなんかだと流れててしまう（「わたしもいきま〜す！」メール）
方がよいのですが…ケースバイケースですよね


.S	ＯＦＦ会とかでも subscribe一行だけのメールはＭＬに流さなくても…？
.key	$AUTO_REGISTRATION_LINES_LIMIT 

登録要請をするメールで８行に達しない（つまり７行まで）のメールは、大抵
『subscribe』とsignature４行くらいしか書いてなかったりするので、ＯＦＦ
会用ならともかく自動登録で使う時は

	$AUTO_REGISTRATION_LINES_LIMIT 

の値以下の行数のメールはＭＬサーバから配送されません。
＃もちろん管理者には知らせます

$AUTO_REGISTRATION_LINES_LIMIT を明示的にセットしないと、８行にセット
されます。

config.ph では一応

	$AUTO_REGISTRATION_LINES_LIMIT = 0;

とセットしています。


.S	サーバーをインストールしたホストからのメンバーの自動登録ができない

.q

FROM: fukachan@phys.titech.ac.jp
正確には user@domain フォームでない ILLEGAL なメールアドレスに 対して
なんらかの Operation を実行するのはよくない。
という根拠に基づいて…ということですが

localhost とからとか条件をつければ出来るでしょうけど（getpeername()）

user@domain フォームでない ILLEGAL なメールアドレス がすどおりして、サ
イトを越えて Deliver されてしまうようなこともあるので、
＃もちろんよくないが実際に出来てしまう。

変な補整を加えてしまうとかえってまずいとおもうんです。

.~q

＃＃＃＃＃＃＃＃＃＃

対策編１：
ってことなんですが、
“From行のアドレスに@以下をつけないでメールが送られてくる”
をやらせないために、
メール本体に subscribe uja@localhost-name.uja.jp とかかけばＯＫってい
えばＯＫなんですけどね（↑ From: より優先されるから）

対策編２：
自動補整も やってやれなくはないです。でも変なこと（or illegal）
がおこってもおこらないでね:-) YOUR OWN RISK

$START_HOOK  = q#
	if ($From_address !~ /\@/) {
		$From_address = "$From_address\@ローカルなドメイン";
	}
#;

ローカルなドメイン は自分のドメイン



.# ##########################################################
.C	ヘッダのカスタマイズ
.label	{header-custom}


.S	ヘッダの形とadditionalなものをそのまま保存すること
.key	ヘッダの保存
.key	$PREVENT_MIME

デフォールトはMIME の３つのフィールドは↓通します。

$PREVENT_MIME をセットしない限り常に 
	MIME-Version:
	Content-Type:
	Content-Transfer-Encoding:
をとおす。（１．４）

＃つまり MIME反対派の方は $PREVENT_MIME をセットしてください

それ以外のすべてのヘッダを通す（Received等はのぞく）時は

.key	$SUPERFLUOUS_HEADERS
	$SUPERFLUOUS_HEADERS = 1;	# preserve more header fields

とすると実行できます。0なら案１です。
＃保存する時はsub GetFieldsFromHeaderでマッチしないフィールドは保存し
ている


.S	CC: フィールドを“つけない”

デフォールトではつけます
$NOT_USE_CC = 1;


.S	CC: フィールドだけをつける
.key	$HEADER_ADD_HOOK

［Obsolete］（やると↓二重についちゃうぞ）
config.ph で

$SUPERFLUOUS_HEADERS = 0;	# preserve more header fields

として、なおかつ

$HEADER_ADD_HOOK = q#
    $body .= "Cc: $Cc\n" if($Cc);
#;


.S	MIME decodingを行なう
.key	MIME
.label	{MIME-1}

summaryに書くsubjectをMIME decodeをしてから書き込むようにするなら１です。

.key	$USE_LIBMIME
	$USE_LIBMIME	= 1;		# when use MIME Extension in libMIME.pl

例：
	……
	Subject: Re: TELEPHONE 
	=?ISO-2022-JP?B?GyRCJD0kcyRKJCEhQRsoQg==?=

	……
というメールが来たとすると、summary ファイルには

	94/04/03 20:47:47 [1:fukachan@phys.t] Re: TELEPHONE そんなぁ〜


と記録されます

注意：subject をちょんぎったりはしませんが、一行にしてからdecodeして全
部書いてます。summaryは１行１メールがわかりやすくていいでしょ？
もし、２行のsubjectは２行でというなら

at sub GetFieldsFromHeader in fml.pl

    # for summary file
    $Summary_Subject = $Subject;
#    $Summary_Subject =~ s/\n(\s+)/$1/g;	←この行を削る
    $User = substr($From_address, 0, 15);

とでもしておいて下さい。

注意２ or メモ： ISO-2022-JP の文字がない限りは require しません（ま、
たいしてかるくはならんが…）。fml.pl中の

	local($INCLUDE_LIBMIME) = 1 if($MailHeaders =~ /ISO\-2022\-JP/o);

.key RFC1522
RFC1522	2. Syntax of encoded-words

   encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
   charset = token    ; see section 3
   encoding = token   ; see section 4
   token = 1*<Any CHAR except SPACE, CTLs, and especials>


.S	配送するメールのMIME部分はDecodeしてしまいたい
.label	{MIME-2}
.seealso MIME-1

では、配送するメールのMIME部分はDecodeしてしまいたい時はどうするか？
例えば、fml.pl の sub GetFieldsFromHeaderで

    if($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
    }

を

    if($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
	$MailBody = &DecodeMimeStrings($MailBody);
    }

で本文の任意の ISO-2022-JP で始まる部分だけをMIME decodeします


.S	MIME decodeをするためのライブラリ libMIME.pl はどこにあるか？
.label	{MIME-3}
	$LIBMIMEDIR	= "$LIBDIR/contrib/MIME";
					# location in libMIME.pl

mimer.plというものを使うinterface部分です。適当に移してくださいませ。
最初はもっと大層なことをしていたのですが、今はmimer.plの関数を一個呼ぶ
くらいです。改造はlibMIME.plの中をいじる方がいいでしょう。

MIME decodingの解説：
最初は、fj.sources,fj.lang.perlにながれた
Message-ID: <C1977.94Jan24130052@crcsn82.mdc.crc.co.jp>
という	mime_pls 1.00a	というもので

mime_pls.doc   mimer.pl       mimew.pl       

の３つセットです。この記事の後のパッチもあててあります。
#thanks to c1977@crcsn82.mdc.crc.co.jp (private communication)

いまでは 1.11a です。2.00alpha  も ftp.physにおいてあります


.S	MIMEのカスタマイズ変数
.label	{MIME-customizing}
.key	$MIME_VERSION
.key	$MIME_CONTENT_TYPE
.key	$MIME_MULTIPART_BOUNDARY
.key	$MIME_MULTIPART_PREAMBLE
.key	$MIME_MULTIPART_TRAILER

右辺はデフォールトの値（Built-in）です。

$MIME_VERSION = '1.0';

$MIME_CONTENT_TYPE = 'multipart/mixed;';

以下は MIME/Multipart で使う変数です。

$MIME_MULTIPART_BOUNDARY   = "--Thu_18_May_95_02:36:26--"な形で日付を設定します。

そのあと、これら↓の変数を設定してます。
	$MIME_MULTIPART_DELIMITER  = $MIME_MULTIPART_BOUNDARY;
	$MIME_MULTIPART_DELIMITER .= "\nContent-Type: message/rfc822\n";
	$MIME_MULTIPART_CLOSE_DELIMITER = $MIME_MULTIPART_BOUNDARY;

くぎり

$MIME_MULTIPART_BOUNDARY = 

本文の前口上

$MIME_MULTIPART_PREAMBLE = なし

本文の後につく部分

$MIME_MULTIPART_TRAILER = なし


.S	Subject: [Elena:ID] サブジェクト の [Elena:ID] を抜く
.key	Subjectから[Elena:ID]を抜く
.key	$STRIP_BRACKETS

これは Subject: [Elena:ID] の形で配送するための前処理です。今は、

	    # e.g. Subject: [Elena:001] Uso...
	    $contents =~ s/\[$BRACKET:\d+\]\s*//g;
	    $Subject = $contents;

にしちゃいました:-)。つまり multiple Re: 問題はサーバがメール本文をい
じるのは気持ち悪いので、そういうことを極力少なくするために（Subjectの
変更は個人がやってくれると期待して）いじらないことにしました。

変数は
	$STRIP_BRACKETS = 0;		# Strip e.g. [ML:fukachan] in Subject

１ならSubjectから [ML:fukachan] みたいな部分をカットする。

解説：昔は、

	Subject: Re: [*] Re: サブジェクト
				→	Subject: Re: サブジェクト
	Subject: Re: [*] サブジェクト
				→	Subject: Re: サブジェクト
	Subject: [*] サブジェクト
				→	Subject: サブジェクト

ということをするために

	if(/^Re:[\s\n]*\[[\s\S\n]*\][\s\n]*Re:[\s\n]*([\s\S\n]*)/o) {
		$Subject = "Re: $1"; next;
	}
	if(/^Re:[\s\n]*\[[\s\S\n]*\][\s\n]*([\s\S\n]*)/o) {
		$Subject = "Re: $1"; next;
	}
	if(/^[\s\n]*\[[\s\S\n]*\][\s\n]*(.*)/o) {
		$Subject = $1; next;
	}
	$Subject = $contents; next;

こんなけったいな処理をしていましたが、やめました:-)
＃このコードにもどせばmultiple Re:を削ることができます。

何のために必要な前処理かというと、次を見てみよう(^^;;


.S	hml 1.6 のSubjectの形がいいの

次項参照↓


.S	Subject: [Elena:ID] サブジェクトという形にする
.key	$SUBJECT_HML_FORM
.key	$BRACKET
.key	hml形のSubject

オリジナルの hml 1.6 は
……
From:	エレナさんＭＬ
Subject: [3:fukachan] フリーキックはやっぱりエレナさんが最高さ
……

こんな形のヘッダですね。で、私が嫌いなので:-)、
＃無駄に多いヘッダは嫌いなんですよぉ。To: 見りゃわかるのにX-ML-Nameと
＃か…X-ML-Count は違う種類の情報（Reference）だからいいんですが…

デフォールトは[]ものはなしで、オプショナルで次のようなSubject形になる
ようにしました。

	$SUBJECT_HML_FORM = 1;
	$BRACKET	= 'Elena';

で、こういう形にしようと思いますが、Fromの処理がhml 1.6と違うので
＃今のFrom は ML名 じゃなくて ユーザー名

最近よく見られる形の [MLの名前:articleのID] という形を採用しました。
つまり（今の場合だと）

	Subject: [Elena:ID] サブジェクト
#	Subject: [$BRACKET:$ID] $Subject	というコードが書いてある

の形になります。この場合

	$SUBJECT_HML_FORM = 1; なら $STRIP_BRACKETS = 1;

にしてます（config.phの中で）＃必要なので勝手にonしてしまいます


.S	ＮＩＦＴＹ対策をするか？（参加者にＮＩＦの人もいる）
.label	{NIFTY}
.label	{$AGAINST_NIFTY}
.label	{against-nifty}

注意：もう必要ないらしい

	$AGAINST_NIFTY = 1;（対策をする）

NIFTY は非常識にも、Errors-to という時代おくれの部分しかみてないので;_;、
config.ph あたりで

	$AGAINST_NIFTY = 1

とするとメール本文に

.key	Errors-To: $MAINTAINER
	Errors-To: $MAINTAINER

がつきます。これで NIFTY からのエラーメールが $MAINTAINER に返るように
なってくれます。後向きな解決法ですが;_;。
＃前向きなのは、みんなで文句をいって直させること
＃でも、僕はアカウントをもってない;_;。アカウントを持ってる人が一年く
らいいいつづけないとだめなんだろうなぁ（はぁ）


.S	Message-IDの保存
.key	Message-ID
.key	Uniq_Identifier_of_Message-ID
.key	$USE_ORIGINAL_MESSAGE_ID

$USE_ORIGINAL_MESSAGE_ID = 1; とすると、オリジナルのMessage-IDを保存し
てヘッダにつけます。


.S	Message-IDを個人の趣味でカスタム化する
.key	Message-IDのカスタム化
.key	$HEADER_ADD_HOOK

Message-ID: uja@aoi.chan.panic とするなら

$HEADER_ADD_HOOK = q#
$body .= "Message-ID: uja@aoi.chan.panic\n";
#;

と、config.ph にでも書く。あとはずらずらかく（あはは、うじゃ）

他の例：
Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.jp>

$HEADER_ADD_HOOK = q#
$body .= "Message-ID: ".
	sprintf("<19%2d%02d%02d.%05d.%s>\n", $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.jp");
#;


.S	宇宙歴0403.3238…（おあそびその１）

＊＊＊ 削除しました(95/10/2) ＊＊＊
libcompat.pl にBackward compatibility のためのコードがあります。

しゃれで作りました (_o_)

	$STAR_TREK_FORM = 1;
とか config.ph でしておくと

Subject: [0403.00128] 外国ＴＶシリーズＭＬむけですね、これは
＃もちろん外国ＴＶ ＭＬといえど実際には使ってないけど:-)

みたいに、宇宙歴もどきとＩＤがセットの形をつけます（おあそび）。
＃お遊びですが、One-actionだから許して(_o_)

余談ですが、このStardateに意味はありません。翻訳の時に適当につけられた
ものです。詳しくは、エンサイクロペディア等をごらんください。
＃http://www.phys.titech.ac.jp/uja/Startrek/


.S	宇宙歴その２

外国ＴＶシリーズＭＬで使ってます:-)
＃http://www.phys.titech.ac.jp/uja/Startrek/

config.ph で	$APPEND_STARDATE = 1;

Date: Fri, 19 May 95 22:31:09  JST
From: "No.6 Fukachan" <fukachan@phys.titech.ac.jp>
Subject: Re: Nantonaku Leonard Nimoy 
To: enterprise@phys.titech.ac.jp (Foreign TV Series ML)
X-ML-Name: Prisoner
X-Stardate: [-31]5697.816493

…本文略…

みたいになります。
スタートレックＦＡＱにプログラムがのっています
libStardate.pl はその perl 版です。


.S	1つのMLに複数の投稿用アドレス
.key	1つのMLに複数の投稿用アドレス

何の意味があるのかは聞かないでください（笑）

例：
Elena@phys.titech.ac.jp というＭＬで
Elena@phys.titech.ac.jp	と Anna@phys.titech.ac.jp
の両方を投稿可能にする（いくつあっても全部配列にして ずらずらかけばおなじ。）

config.ph に次の設定をする。その複数のアドレスを(ループチェックに使うために)

@PLAY_TO = (	'Elena@phys.titech.ac.jp', 
		'Anna@phys.titech.ac.jp');

のように、かいてください。配列の先頭がオリジナルのアドレス(==
$MAIL_LIST)です。

こうすると Elena になげても Anna に投げても どっちでもＯＫで、
to: と reply-to:を変更します。
＃名前の変更 in 1.5delta. Playing_to  -> SMTP_OPEN_HOOK

＊＊＊ 注意： Playing_to は削除しました。 ＊＊＊
libcompat.pl にBackward compatibility のためのコードがあります。


あと、↓このように書いてみてください。

例（全体）： 
----------------------------------------------------------------
# Here is a playing of "To addresses change"; string to eval
$SMTP_OPEN_HOOK .= q#
    local($a);
    foreach (@PLAY_TO) {
        $a = (split(/\@/, $_))[0];
        if ($Envelope{"to:"} =~ /$a/) {
            $MAIL_LIST = $_;
        }
    }
#;

----------------------------------------------------------------





.# ##########################################################
.C	config.phのその他の設定
.label	{config-misc}
.S	どのマシンのSendmailを使う？

・Sendmailが動くマシン（デフォールトは今ソースを広げたマシンです）

.key	$HOST
	$HOST         = 'localhost';

デフォールトはそのマシンです。もしＭＬサーバのマシン（受けるマシン）が
貧弱ならそのマシンが何十通もメールを送り出すのは酷です。
そういう場合上の変数を書き換えて、別のマシンに配送を任すこともできます。
その時は

	$HOST         = 'beth.foo.bar.ac.jp';

のようにそのマシン名を書いて下さい。
＃ただしgethostbynameできないようなマシンじゃだめですが。
＃もちろんアクセスできないマシンとかではできません（あったりする）

勝手にそのマシンのパワーを使うことになるのでそのマシンを使う許可を得る
べきでしょう。


.S	ロックアルゴリズムの選択と変数の設定
.seealso fml-mechanism, seq-file

＃fml 1.2.2 からあとでは flockでどのＯＳでも大丈夫だとおもいます。

ロックアルゴリズムは二通り用意されてます。
一つはプロセスＩＤで区別するやりかた。もう一つがflock system callを使
うもの。flockがお奨めです

.key	$USE_FLOCK
	$USE_FLOCK    = 1;

でflock system call

	$USE_FLOCK    = 0;

でＩＤを使うやり方にセットできます（デフォールトはflock）。

・プロセスＩＤで区別するやりかたでそのＩＤをもったロック用ファイル
をつくるdirectoryの指定

.key	$LOCKDIR
	$LOCKDIR      = "$DIR/LOCK";

・その場合のデフォールトのＩＤのとり方。

.key	$LOCKFILE
	$LOCKFILE     = "$$";
＃$$はプロセスのＩＤ（% man sh）


.S	# helpとかの形式がいや。#helpとか#getfileがいいの
次節

.S	コマンドの書き方 [e.g. # get 1 と #get 1は同じものとみなす]

コマンドの書き方についてのオプションです。

hml 1.6 では
	# get 1
	# help
のような書き方をしてきました。で、こうでない書き方は解釈してくれなかっ
たので、今度は

	# get 1 と #get 1は同じものとみなす（両方使える）
	すべてのコマンドで同じように "# " -> "#" 解釈する。
	さらに#getfile ...も# get ...と理解する。

としました。つまり、

	# get 1
	#get 1
	# getfile 1
	#getfile 1

は同じもの。同様に

	# help
	#help

も同じものです。

.key	$COMMAND_SYNTAX_EXTENSION
	$COMMAND_SYNTAX_EXTENSION = 1;
	両方解釈するなら１、"# summary"みたいなhml 1.6形だけなら０。


.S	コマンドは一辺に実行できるか？２
.seealso	command-plural2


.S	WHOISを使うか？
.key	whois
.seealso whois
.key	$USE_WHOIS

	$USE_WHOIS = 0;			# Use Whois library

０ならｆｍｌデフォールト（whoisは使わない）。１なら使う。ただし、これ
はｈｍｌとは違い、本物の任意のwhois serverとソケット間通信をするための
ものです。
＃ｈｍｌは独自に自分だけのｗｈｏｉｓを抱えていた（無意味＆＆security
hole）

例：

% echo  "# whois fukachan" | Mail -v Elena@phys.titech.ac.jp

% echo "# whois -h どっかのwhois fukachan" | Mail Elena@phys.titech.ac.jp

は ”どっかのwhois” に聞きにいきます。

	$DEFAULT_WHOIS_SERVER = "localhost";

で デフォールトの whois サーバを変更できます。コマンドの -h オプション
で変更できるわけですが、コマンドの-hオプションが優先します。

例：
	"# whois -h どっかのwhois fukachan"


.S	まとめおくり(Rel. 4)のデフォールトで RFC934 形をつかうか？
.key	$USE_RFC934

	$USE_RFC934 = 0;

まとめおくり(Rel. 4)で、０はデフォールトのUNIX FROMで区切られたメールを
送り出すが、１なら次のような形のものを送るようになる。これは mh の
burstで複数の展開に展開できます。
＃あと、どういうソフトがあるのか知らない…:-)

９３４形式の例：
------- Forwarded Message
From: uja
Subject: daa 

うじゃ
------- Forwarded Message
From: uja
Subject: daa

あおいちゃんパニック もいいけど せいふくもの もよくてよ
------- Forwarded Message


.S	まとめ送りのデフォールトを RFC1153 digest へ
.label	{RFC1153}
.key	RFC1153

これは それぞれに通し番号をつけなければなりませんので、まとめおくりの
デフォールトを1153にすることになります。

つまりコマンド # matome 3 はgzip ではなく 1153 形を意味します。

config.ph で $USE_RFC1153_DIGEST = 1; としてください。

デフォールト以上の細かい部分は librfc1153.pl でフォーマットを決めてく
ださい

注意：
一時期 デフォールトで 3時間に 強制的に設定しておいてある version があ
りますが、ようは番号の整合性をとるためです。
１時間おきの１１５３送りの人と、３時間おきの１１５３送りの人、があると
番号が食い違ってしまいますから

番号の整合性を無視すれば、どうでもいいことなんですが…
とりあえず、この部分はコメントアウトしてあります（95/6/27)


.S	コマンドのフック
.label	{command-hook}
.key	customize-of-commands
.key	コマンドのカスタマイズ
.key	$COMMAND_HOOK

インタプリタですから、コマンドでそのＭＬ独自の機能をもたせたかったら
config.ph にセットして下さい（そうすれば、ＭＬが複数あってもそれぞれ別
様にカスタマイズできる）。

これはリストを返すようにするコマンド "# list" を新たに付け加える例です。

--------- in config.ph ---------
$COMMAND_HOOK =q#
      if(/list/io) {
	  &Logging("List ($From_address)");
	  &SendFile($to, "List $ML_FN", "$DIR/list");
	  next GivenCommands;
      }
#;
--------- in config.ph ---------

この例だとは # 〜 # の間をquoteしています。#...コメントをとかははさめ
ません。
＃q syntax は q# ... # の形で任意の二つの文字（今はたまたま #）の間を
quoteする関数（本当の意味での関数ではないそうだ）

fml 1.3 ではライブラリの多くの機能はこれを使うことを前提にＲＥＡＤＭＥ
等が書かれています。

応用は フックの章 に例題がのっています。



.S	lzh + ish option
.key	lzh
.key	ish
.key	$LHA
.key	$ISH

	# mget 200-210 ish

の用に指定するとlzh して ish(s7 mode)したものを送り返します。

$LHA = "/usr/share/bin/lha";
$ISH = "/home/axion/fukachan/bin/ish";

等をどこかで（config.phとか）で設定して下さい。
しないと上の↑Built-inデフォールト値になります。


.S	SJIS にファイルを変換して送る （lzh + ish option）
.key	lzh
.key	ish

config.ph で $USE_SJIS_in_ISH = 1; をセットしてください。

使う時は jcode.pl を INCLUDE PATH へいれておいてください。
^M ^Z もつけます。すべて、外部コマンドを使わずに自力でやります。


.S	コマンドで単なるシンタックスエラーの警告をしない
.label	{USE_WARNING}
.key	$USE_WARNING

明示的に $USE_WARNING をセット
e.g. in config.ph

	$USE_WARNING = 1;

するとコマンドメールでの単なるシンタックスエラーの警告をしない

e.g. 
# helps 			←コマンドのエラーは警告
＃うじゃ			←シンタックスエラー警告なし
＃しぐにちゃ〜	uja@uja.ac.jp	←シンタックスエラー警告なし


.S	mgetのファイルサイズ（送り返し）
.key	$MAIL_LENGTH_LIMIT

in libsendfile.pl

	$MAIL_LENGTH_LIMIT = 1000;

を変える。Internetならともかく、パソコン通信の人へも配送する時は気を使
いますよね。
＃最近は３０００らしいまで設定可能みたいです(e.g. NIFTY)
＃参照 http://www.phys.titech.ac.jp/fml/ の下
＃pc-van は何の問題もなかったと思いました（たしか）

１０００行でだいたい５０ｋくらいになります。



.S	mgetのシンタックスの Shell Match Pattern(e.g. * 1? )
.key	$SECURITY_LEVEL

$SECURITY_LEVEL < 2 では 

	# mget * 
とか
	# mget 10? 

が使えます。パッケージは １ （Backward Compatibility）にして配布してま
す。＃前のヴァージョンとおなじになるように


.S	mgetのシンタックス

何もしなくても、

# mget 正規表現 送り返されるメールの時間間隔（ｓｅｃ）

	と

# mget2 1-10,5みたいなsyntax 送り返されるメールの時間間隔（ｓｅｃ）

の両方を理解します。サーバが自動的に切替えます。


.S	許されるコマンドのシンタックス

Quoted from 4.4BSD:/usr/share/man/cat1/sh.0 
.q
       Shell Patterns

       A pattern consists of normal characters, which match them-
       selves, and meta-characters.   The meta-characters are
       ``!'', ``*'', ``?'', and ``[''.  These  characters lose
       there special meanings if they are quoted.  When command
       or variable substitution is performed and the dollar sign
       or back quotes are not double quoted, the value of the
       variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (``*'') matches any string of characters.   A
       question mark matches any single character. A left bracket
       (``['') introduces a character class.  The end of the
       character class is indicated by a ``]''; if the ``]'' is
       missing then the ``['' matches a ``['' rather than intro-
       ducing a character class.  A character class matches any
       of the characters between the square brackets.   A range
       of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclama-
       tion point the first character of the character class.

       To include a ``]'' in a character class, make it the first
       character listed (after the ``!'', if any).  To include a
       minus sign, make it the first or last character listed
.~q





.# ##########################################################
.include mget.wix
.include hook.wix
.include os.wix
.include trouble.wix

.# ##########################################################
.C	アーカイブ, Archive & Expire
.label	{archive}

場所をとるから古い記事にはgzipかけたい。でも一つ一つやるより１００個ず
つとかならさらに効率が上がります。以下を参照

.comment beth
.S	古い記事にはgzipかけたいなぁ、場所をとるから
.key	@ARCHIVE_DIR

config.ph の例：

@ARCHIVE_DIR = ('old');
＃ @StoredSpool_DIR = ('old');はObsolete

spool/1-100	-> +tar+gzip	-> old/100.gz と作っているとする
＃（趣味）僕は恐いので その gzip fileは自分で自動では作らないようにしてい
ます。

これは次のように fml.pl は解釈します。

例えば、"# get 1 " というコマンドを送り込んだとする。その時は
−−−−−−−−−−
$STORED_BOUNDARY（今は100まで）以下の記事の請求（get等）がもしあったら、

	ml-dir/spool/	を探索し、もし、ファイル spool/1 が見つからない時は

	ml-dir/old/	という場所も探し、1-100 までがtar + gzipされて
	いる old.100.gzを送り返す。


.S	gzip fileにしよう！（アーカイブへの変換）
.key	Archive.pl

それには fml-1.3.x/bin/Archive.pl というのを使って下さい。
さらに cron で自動処理するなら次の節を御覧下さい

これは Archive.pl 2000とかすると、２０００までのファイルを１００個ずつ
の塊にして、oldに作ります。変数はArchive.plの先頭でセットしてください。
スプールのオリジナルは消さないので、注意を払って消して下さい（とりかえ
しがききませんから、それは）
＃自分じゃ、こわいのである程度まとまったところでこうやって手動でつくり
ますね、アーカイブは

例えば、

spool/1-100	->  +tar+gzip	-> old/100.gz
spool/101-200	->  +tar+gzip	-> old/200.gz

のようなファイルをoldの下に作るプログラムがfml-1.3.x/bin/Archive.pl で
す。

目的のＭＬの場所にまでいって
% ls 

MSendrc		actives		config.ph	deny
guide		help		list		log
members		objective	seq		spool
summary		welcome

% mkdir old

% perl Archive.pl 3800
…たくさんメッセージが出るが省略…

% ls old

100.gz   1400.gz  1900.gz  2300.gz  2800.gz  3200.gz  3700.gz  700.gz   
1000.gz  1500.gz  200.gz   2400.gz  2900.gz  3300.gz  3800.gz  800.gz   
1100.gz  1600.gz  2000.gz  2500.gz  300.gz   3400.gz  400.gz   900.gz   
1200.gz  1700.gz  2100.gz  2600.gz  3000.gz  3500.gz  500.gz   
1300.gz  1800.gz  2200.gz  2700.gz  3100.gz  3600.gz  600.gz   

spoolの３８００までの１００個ずつのパッケージを作りました。
spoolの方の元メールを自動的に消しはしない（安全のため）ので、
自分で消して下さい。


.S	gzip fileにしよう！（cron で自動処理）
.key	Archive.cron
.key	crontab

cronで自動的（例えば週一日曜の朝とか）に次の形で

	fml-1.3/bin/Archive.cron "MLサーバのdirectory名

をよんでください。 いくつかＭＬがあるなら、シェルスクリプトにまとめて
呼ぶといいでしょう。
＃まとめ送りと一緒とかでもよいですね

Archive.cron の先頭に変数があります

	DIR="$1"
	ARCHIVE="$DIR/bin/Archive.pl"

Archive.pl が gzip化 のメインなのでこれのおき場所をちゃんとセットして
下さい。

例：
----- crontab -----
0 * * * *	fukachan /bin/sh /適当な場所/ML-Archive 2>&1 | Mail あなたのアドレス
-------------------
----- ML-Archive -----
#!/bin/sh

	sh fml-1.3/bin/Archive.cron Elena
	sh fml-1.3/bin/Archive.cron Uja
	sh fml-1.3/bin/Archive.cron Sayori

-------------------


.S	gzip fileにしよう！（理論編）

何故、まとめてgzip化したいのか？

１．一個一個gzipかけると、約半分にしかなりませんが、１００個まとめて書
けると、ヘッダとかの重なりがあるので約２５％にまで圧縮できるようになり
ます。

２．Mail-Countが万を越える頃になるとi-nodeの計算に時間がかかるようにな
るのでファイル数を減らす or ほかの場所に移すことに意味があるようになり
ます。そこでspoolの中身をうつし、１００分の一のファイル数にすると効果
が非常にあります。


.S	expire
.label	{expire}
.key	$FML_EXIT_HOOK

形式： &Expire(場所, 日数(以上古いファイルを消す));

$FML_EXIT_HOOK = q#
	&use('expire');
	&Expire($SPOOL_DIR, 7);
#;

と設定すれば、$SPOOL_DIR 以下のファイルにたいして 7日以上古いファイル
を消します（いきなり消します。注意）

今： libexpire.pl を作った。
旧： expire.pl を perl の inlcude pathのどこかにいれてください

まぁこれだと、毎回起動するたびに一個ずつ消すことになるので、やることの
わりにおおげさですね。

cron で 
	expire.pl -s spool-directory -e expire-period 
とかを設定して、週一くらいで動かせばいいのでは？


.S	expireを残すファイルの数で指定して行なう
.label	{expire_with_number}
.key	$FML_EXIT_HOOK

形式： &Expire(場所, 残すファイル数 , 1（ファイルで実行を指示するため）);

$FML_EXIT_HOOK = q#
	&use('expire');
	&Expire($SPOOL_DIR, 50, 1);
#;

今： libexpire.pl を作った。
旧： expire.pl を perl の inlcude pathのどこかにいれてください

と設定すれば、$SPOOL_DIR 以下のファイルにたいして 
	”５０個残して”（注意）
それ以外の古いファイルを消します（いきなり消します。注意）

cron で 
	expire.pl -s spool-directory -e expire-period 
とかを設定して、週一くらいで動かせばいいのでは？


.S 	いきなりExpireの実験はしないほうが…

$SPOOL_DIR じゃなくて tmp の下に tmp/spool とか作って、実験したほうが
いいですね。


.S	expire.pl コマンドラインオプション
.label	{expire_getopt}
.label	{expire.pl}
.key	$FML_EXIT_HOOK

expire.pl [-h] [-e expire_days] [-s spool_directry] [-n]
    -h                 : HELP
    -e expireする日数
    -s スプール
    -n （残すファイル数を設定して、expireするモード）



.S	logファイルの整理、消去をする → newsyslog
.seealso	newsyslog


.S	newsyslogをする（デフォールト）
.label	{newsyslog}
.key	$NOT_USE_NEWSYSLOG
.key	@NEWSYSLOG_FILES

まとめおくりの MSendv4.pl は日曜朝６時に（デフォールト）

	libnewsyslog.pl を実行します

この３つのファイル（デフォールト）に対し

@NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak")

rm -f var/log/members.4
mv -f var/log/members.3 var/log/members.4
mv -f var/log/members.2 var/log/members.3
mv -f var/log/members.1 var/log/members.2
mv -f var/log/members.0 var/log/members.1
ln -s members.bak 	var/log/members.0

を実行します。必要なら この @NEWSYSLOG_FILES に これ↑をやってほしいファ
イル（log とか…）をつけくわえて 

@NEWSYSLOG_FILES = 
	("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak", "log")

とか	config.ph に書いておいてください。


.S	cronでnewsyslogをする

たとえば、

0	6	*	*	0	(chdir dir-of-fml; sh bin/newsyslog.sh log var/log)

とかかく


.S	newsyslogをしない
.label	{newsyslog-2}
.seealso	newsyslog
.key	$NOT_USE_NEWSYSLOG

$NOT_USE_NEWSYSLOG = 1; なら実行しません



.# ##########################################################
.C	fml 本体一つで複数のメーリングリストを運用する
.key	複数のメーリングリストの運用
.label	{plural-handling-1}
.seealso c-wrapper, calling-fml.pl


「	in /etc/aliases

	ML-1: "|fml ML-1"
	ML-2: "|fml ML-2"

はできるか？もしくはfml を用いて複数のメーリングリストを運用する時に、
fml 本体は一つに済ませて、メーリングリスト毎に必要なファイルだけを分割
できるか？」という命題ですが、次をどうぞ(^^;)


.S	ひとつのfmlで複数のＭＬを扱う方法(fml.plの引数について)
.label	{plural-handling-2}
.seealso c-wrapper, calling-fml.pl

まずconfigurationはfml.plの引数(/etc/aliases or fml(C wrapper))と
config.phの２箇所ですべてです。そして基本的に

	fml.pl	config.phのdirectory libraryの場所

の形で与えています（.seealso c-wrapper )。プロセスの最初で directory を評
価するので、config.phはfml.plの引数のdirectoryのパラメータの下の
config.ph（members, log等もここのを見ます）をみているわけです。

例えば ＭＬのおき場所が
＃以下すべて適当に directory 名は省略してます。

	Elena/config.ph
	manami/config.ph
	lib/fml.pl
	lib/libsmtp.pl

なら、次のように起動すれば

	lib/fml.pl Elena  lib 
	lib/fml.pl manami lib 

上は Elena/config.ph を評価して Elena ＭＬ、
下は manami/config.ph を評価して manami ＭＬにかわります。
ライブラリは lib の下の lib*.pl等をみているわけです。
＃問題はfml.plが使うライブラリがどこにあるかで
＃	“一番簡単な手は /usr/local/lib/perl にいれてしまう”
＃というものです:-) ＃これはコンパイルの時 perl にはいっているはず。
＃それがいやな場合のために
＃
＃	fml.pl	"directory(config.ph)"	"Perl libraries"
＃
＃と解釈するようにしました。（from 1.2.0.6）

ただ、それぞれ非常に違うＭＬでlibfml.pl等もばらばらのものにしたいなら
書き換えてそれぞれのdirectry(e.g. Elena)におけばいいでしょう。

include する時は 

	/usr/local/lib/perl   Elena   library

の順で探しますから（先にマッチしたところで取り込むから）
(see also Appendix about @INC)

注意１：ＭＬ独自の fml.pl にしてしまったら上の論法は使えません（あたり
まえ）。fml.c も書き換えておく必要があります。
ただし、コマンドの改造はフックを用いれば簡単です
.seealso	command-hook



.S	ひとつのfmlで複数のＭＬを扱う方法(setuid programをばらばらに作る)
.key	setuid-program
.key	setuid-source-exapmles
.label	{plural-handling-3}

setuid program をばらばらに作ればいいわけです。
＃可変引数をとる setuid program は security hole になり得るからいちい
ち作る

で、中身は上と同じことをするように次のように作ります。後は同じです。

例えば、 /usr/spool/driver の下に
	manami
	aiko
というのを作るとしましょう。
＃manami → ML-1、 aiko → ML-2 :-)

	% cc -s -o manami manami.c
	% chmod 4755 manami
	% cc -s -o aiko aiko.c
	% chmod 4755 aiko

そして /etc/aliases に
manami:"|/usr/spool/driver/manami"
aiko:"|/usr/spool/driver/aiko"

＃fml.c を参考にして下さい。これは↓4.3BSDです
   ------------------- manami.c -------------------
#include <stdio.h>
main()
{
  setuid(geteuid());
  setgid(getgid());
  execl("/usr/spool/lib/fml.pl", 
	"(fml)", 
	"/usr/spool/manami", 
	"/usr/spool/lib", 
	NULL);
  exit(1);
}
   ------------------- aiko.c -------------------
#include <stdio.h>
main()
{
  setuid(geteuid());
  setgid(getgid());
  execl("/usr/spool/lib/fml.pl", 
	"(fml)", 
	"/usr/spool/aiko", 
	"/usr/spool/lib", 
	NULL);
  exit(1);
}
   -------------------------------------------------


.S	ひとつのfmlで複数のＭＬを扱う方法(setuid をちゃんとするsendmail）
	上のセクション及び .seealso calling-fml.pl

上のセクションにならいます。

/etc/aliasesでsetuidをちゃんとやってくれるという自信があれば、
＃つぅか Sendmail の問題ですが…

例えばこんなかんじでしょう
＃ほんとに最終仕様かどうかは知りません。将来変わるのかも…

	/usr/spool/driver の下に
		manami
		aiko

	/usr/spool/driver/manamiの中身
	"|fml.pl /usr/spool/manami /usr/spool/lib"

	/usr/spool/driver/aikoの中身
	"|fml.pl /usr/spool/aiko /usr/spool/lib"

	in /etc/alises
	
	manami: :include:/usr/spool/driver/manami
	owner-manami: fukachan

	aiko: :include:/usr/spool/driver/aiko
	owner-aiko: fukachan

この場合/usr/spool/driver/manami の所有者権限で実行されるので適宜設定
してください。あとは上のセクションと同じ。


.S	複数のＭＬがあるけど、コマンドの処理は一つのアドレスで一括してやりたい
.key	コマンド専用アドレスその２
.comment beth2

今 master.fml というそのためのアドレスを作ったとします。 

解説０：
ｆｍｌ は メンバーへの配送サーバ ＋ そのサーバの抱えているスプール等へ
	のコマンドを制御する

解説：で、今の場合（ｍａｓｔｅｒ．ｆｍｌ）は ｆｔｐ、 WWW 等へのアクセ
スの中継と、（おまけで）ｆｍｌ（ＭＬサーバ）群への中継をおこなう

例：	だから シンタックスは次のようになります。
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

普通のＭＬ宛のメール	→	sakisan@phys...(e.g. サキさん)

サキさんの 記事１をとりよせる。

"# get 1"		→	sakisan@phys...(e.g. サキさん)
もしくは（推奨↓）
"# get 1"		→	sakisan-ctl@phys...(e.g. サキさん)
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

一方、一箇所で集中管理したい場合（master.fml）のほうでは
WWW.phys.titech.ac.jp へのアクセス

"www http://www.phys.titech.ac.jp/"	→	master.fml@phys..

サキさんの 記事１をとりよせる。

"# get sakisan 1"	→	master.fml@phys..
       ↑ここにはＭＬ名が入る（ここが要注意）

となってます。実は中でＭＬサーバへただ中継してるだけです（笑）

コマンド一覧：（<list>はＭＬ名（アドレスの＠前の部分））
help		<list>
objective	<list>
guide		<list>
msg		<list>
member		<list>
members		<list>
active		<list>
actives		<list>
summary		<list>
on		<list>
off		<list>
bye		<list>
get		<list> <filename>
mget		<list> <filename>

end
quit
exit	

本来の目的は	www, ftp, wais, gopher とのＩＰＣの中継をする
おまけ機能で 
subscribe ML-address とか
member ML-address とか
which とか
できる（あくまでおまけ）＃実は単にＩＰＣの中継してるだけ:-)



.# ##########################################################
.include msend.wix
.include remote.wix
.include forward.wix
.include fml_local.wix
.include sid.wix
.include ftpmail.wix
.include modify.wix
.include function.wix
.include localhack.wix
.include href.wix

.# ##########################################################
.C	misc
.label	{misc}

.S	はやりのＭＩＭＥ対応については？
.label	{MIME-extension}
.seealso	MIME-1, MIME-2, MIME-3

MIMEまわりは↑を御覧下さい。すべてperlだけで処理しています


.S	ロックアルゴリズム
.key	flock
.key	liblock.pl
.key	pid
.key	rename()

今のは
	1.	flock system call（man flock）

	BSDね。fml 1.2はあまりすっきりしたコードになってないが、1.3は
	かなりすっきりしたとおもう

	2.	pidにもとづくロック（liblock.pl）

	1にくらべ数倍よけいなsystem callがかかる
	＃ちゃんと一周した後も補正している。

	3.	rename() を使う

	rename()をつかって排他制御とか… UNIX V7 の時代からあるやりか
	たですね。結局 1.6 では、これにもどしちゃたんですが…


.S	ロックしてconfig.phのｅｄｉｔをしたい
.key	vipw.pl
.key	bin/vipw.pl
.key	maintenance.pl

flockを使って夜中とかじゃなくてメールが来得る時間帯にメインテナン
スをしたい時は？

% bin/vipw.pl 

とすれば、MLの機能をflockでロックして、

	shell% $EDITOR $PWD/config.ph

を vipw.pl は実行します。maintenance.pl の発展版ですかね

vipw.pl [-d $DIR] [-p] [-h] [-f file-to-edit] [$DIR(of ML)] 
    -h help
    -d ＭＬのconfig.phのあるdirectory
    -p ＭＬのconfig.phのあるdirectoryのしたのetc/passwdを代わりにedit
    -f editしたいファイル
    ＭＬのconfig.phのあるdirectory

すべてを省略した場合 $PWD の config.ph 
もっとも、-f とかの場合ちゃんと ロックしたかったら directory の指定が
必要ですね


.S	maintenance.pl
.key	maintenance.pl

flockを使っていて夜中とかじゃなくてメールが来得る時間帯にメインテナン
スをしたい時は？

maintenance.plはMaintenance用のflockするスクリプトで、fmlと同じロック
ファイルにflockでアクセスしてサーバーを止めるためのものです。中身は
	flock 
	sleep 600 
	flockをはずす
だけです。使い方は

	maintenance.pl -s sleeptime [directory]
# [directory] のデフォールトは PWD です（いまいるところ）

で -s でスリープする時間を変更できます。

flock 使わずに pid 式の ロックを使っているなら
% touch LOCK/1
とでもして、作業の後それを消せばいいわけです。


.S	sendmailとの通信の記録（デバッグ）
.key	var/log/_smtplog
.key	_smtplog
.key	$NOT_TRACE_SMTP

sendmailとのやりとりの記録（もっとも最近のものだけ）デバッグに便利。
（デバッグとか終わっちゃって）もぉ必要なかったら

	$NOT_TRACE_SMTP = 1; 

とconfig.phにかいてください。ログをとらなくなります。



.S	X-MLServer: field って何？
.key	X-MLServer:

起源はデバッグ用だったんだけど（笑）、今の意味は『明示的にＭＬサーバが
ｈｍｌ系である』ことを宣言しているつもりです。無意味ではないと思うんで
すが
＃だってぇ〜hmlじゃないのにhmlのコマンドがＭＬにながれるのをよく見るか
ら:-)

＃けずるときはfml.plの中の sub Distribute のX-MLServerって行をコメント
＃アウトなりなんなりしてください


.S	違うアドレスから来たメールは？
.S	アドレスチェックを緩めたい or 強くしたい
.key	$ADDR_CHECK_MAX

メンバーチェックは送られてきたメールの発信者のアドレスと members に書
かれたアドレスとが一致するか否かで判断しています。今の設定は
＃1.3.2からは…緩くした

	fukachan@titech.ac.jp
	fukachan@phys.titech.ac.jp
	fukachan@beth.phys.titech.ac.jp
	fukachan@exelion.phys.titech.ac.jp

はすべて同じにみなしてます。つまり phys.titech.ac.jp のjp側から数えて
３つの部分の判定チェックですね。（木構造のルートから数える）
＃経験的にここまでやれば十分でしょう

４つ（jp ac phys titech の４つ）までチェックしたいなら、

$ADDR_CHECK_MAX = 4;

と config.ph のどっかに書いておいて下さい。$ADDR_CHECK_MAX という変数
が設定されてない場合は３として動きます。


.S	mget でえた spool の下のファイルを mh 以外で読む時
.key	lib/Utilitites/packmbox.pl
.key	packmbox.pl

lib/Utilitites/packmbox.pl を使って、

	(cd spool; packmbox.pl ) > ~/mbox

として、mbox をつくれば、これにたいして、/bin/Mail なり Rmail なりを使
うことができて便利でしょう。


.S	複数アドレスから投稿したいがうけとりは一つ( "# skip" )
.key	skip
.key	noskip
.label	{skip}

複数アドレスから投稿可能だがうけとりはあるアドレスに送って欲しい。
＃この１週間だけこのアドレスも使いたいしぃ〜とかの場合にも効果的です

という場合を考えて、actives(自動登録では members = actives) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証（新人さんチェック）には使うけど配送はしないという動
作をします

つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

ユーザーがこれを自分でコントロールしたいなら、コマンドは
＃ Admin command でのみ引数が有効です。
 
# skip	 [引数]		From:のアドレス もしあれば 引数のアドレスを
			そこから投稿はできるが、配送はされないものと設定する
# noskip [引数]		上の逆。配送するようにする。

です。例：
# skip 
	From: のアドレスを skip に

# skip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp を skip に

# noskip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp へも配送を


.S	.forwardでのＭＬ	その１

もちろん 特別なＭＬ用のUser をつくって ~/.forward を /etc/aliases と同
じように設定すれば できます。
＃なんらかの形で（お金で解決もあり） /etc/passwd をいじれることが条件
ですね


.S	.forwardでのＭＬ	その２
.label	{dot-forard}
.key	.forwardでのＭＬ

どういうケースが考えられるかよくわからないので、こんなのを考えてみました
＃他にどういうのがあるのかおしえてくださいね

！！どういうふうにすると無限ループしちゃうかをよく考えた上で使って下さい！！

rosy という人が、beth.phys.titech.ac.jp というマシンで 個人的にＭＬをつくるとします。
で、
To: rosy@beth.phys.titech.ac.jp (uja)
                                ＾＾＾
				ここの部分でＭＬなのかＤＭなのかを区別するとする
もしくは
X-ML: uja 
というのも考えられますね（いまのところ、どっちかをつかう、どっちでもＯＫ）
＃他のヴァリエーションとしてヘッダに何かつけて区別とかもありえますよね？
＃どういうのがいいんでしょ？？？

このときは （~ = $HOME です）

~/.forward に
rosy@beth.phys.titech.ac.jp
"|/home/beth/rosy/ml/fml.pl /home/beth/rosy/ml /home/beth/rosy/ml -F||exit 75"

としかけます。ここで -F は.forwardでの利用を fml.pl に教えています。
＃これで loop しないはずですね。

~/.forward はどのマシンからも呼ばれちゃうので、どのマシンで使うか？を
定義しておきます。＃大文字子文字もあわせてね hostname と

$DOT_FORWARD_EXEC_HOST = "beth";

＃ beth はマシン名 (Elizabeth March:-))

/home/beth/rosy/ml/config.ph に次のように書いておきます

そのキーワードの時に実行するコマンド（↓注意：-Fはつかず、普通のｆｍｌ起動）
$forward_key{'uja'} = 
"/home/beth/rosy/ml/fml.pl /home/beth/rosy/ml /home/beth/rosy/ml";

つまり
	sendmail	１-> localにユーザーへ

			２-> fml.pl -F を起動
			  -> (uja) を検出したら（キーワード）
			  -> fml.pl を起動してＭＬとしてはたらく

くれぐれも配送先に自分を指定しないようにしてください（無限ループ）
あとは普通と同じです。

あと この場合、***-requestとかじゃなくて$MAIL_LIST, $MAINTAINERとかも
自分のアドレスですね。 この場合の追加ヘッダ処理は

sub MultipleMLForwarding
の中で

    $Reply_to = "Reply-To: $MAIL_LIST ($KEY)\n";
                            ↑
			本人のアドレスのはず

    $HEADER_ADD_HOOK = q#
	$body .= "X-ML: $KEY";
    #;

			X-ML: uja とかつける

をしてます。＃いじるならここです。

fml.pl への patch が lib/Utilities にあります。あてて、つかってください


.S	あんまり意味ないけど…

上と同じことをして、
$address_key{rosy} = "fml.pl rosy rosy";
$address_key{rosy} = "/bin/cat > /home/beth/rosy/uja";

/etc/aliases で
uja:"|fml.pl $DIR $DIR"
aja:uja
aoi:uja
rosy:uja

とかける（あまり建設的とは思えないのだが…どうせ/etc/aliasesいじるのは一緒なんだから）



.S	自動送り返しサーバってどう実装してるんですか？ その１
.key	自動送り返しサーバっ実装例１

なんのことはない。ガイドファイルに適当なファイルを設定して、config.ph 
で強制的にガイド送り返ししかしないようにしてしまえば終わりですね。
＃いままで、きづかなかった…

ポイントは、“$START_HOOK にしかける”ってところですね。

例：
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$FML            = '/home/axion/fukachan/work/spool/EXP';
$GUIDE_FILE	= "$FML/doc/INFO";
$LOGFILE	= "$FML/var/log/fmlinfo-log"; # activity log file

$START_HOOK     = q# $Envelope{'req:guide'} = 1;#;

1;
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


.S	自動送り返しサーバってどう実装してるんですか？ その２
.key	自動送り返しサーバっ実装例２

設問：fml-current@phys.titech.ac.jp 宛に送ったメールは自動返送されて戻っ
てくるのですが、こういったものを作るには、どのような設定をすればいい？

いまでは libSendBack.pl ってのにまとまってます。
/usr/ucb/vacation ってのはこれとほぼ同じですね。
＃もっともあれは unix from をみるんですが

理屈は コードをけずっただけ（笑）というだけですが、

０．いつもの通り仕掛ける
１．ロック
２．メンバーチェックをしないで
３．送り返す
	&SendFile($to, "", 目的のFILE);
４．ロックをはずす

in fml.pl MAIN PART

(!$USE_FLOCK) ? &Lock : &Flock;	# Locking 

#---------------- CHANGE -------------------------

$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$INFO_FILE	= "$DIR/INFO";

$LOGFILE	= "$DIR/fmlinfo-log";		# activity log file

$to             = $Reply_to ? $Reply_to : $From_address;

&SendFile($to, "Info $ML_FN", $INFO_FILE);
&Logging("Info request from $From_address");

#---------------- CHANGE ENDS --------------------

(!$USE_FLOCK) ? &Unlock : &Funlock;# UnLocking 
exit 0;				# the main ends.


.S	X-Stardate: をつける（mh-e）

lib/Utilities/stardate.el を load してください
＃ emacs 19 でなきゃかきかえないとだめ

たとえば、.emacs に
(load-libaray "stardate")
(setq startrek-stardate-process "/some-directory-path/libStardate.pl")

とすると mh-comp の draft buffer をつくるときに 
X-Stardate: をつけてくれます。


.S	POP3

まだカスタマイズまで考えてないから、
	bin/inc_via_pop.pl
で、

$POP_EXEC = "|/どっかにおいて/fml_local.pl -user yamazaki";

を、ファイルの先頭辺りに書いて

	bin/inc_via_pop.pl -host popする先のホスト名

ってのを起動してみてください。

pop のパスワードは ~/.netrc のエントリをみるようにしてあります。

$POP_EXEC のデフォールトは mh のスプールへおとすやつをさがすので、
ただコマンドラインで

	bin/inc_via_pop.pl -host popする先のホスト名

とすると、

	/usr/local/mh/inc -noapop -norpop -host popする先のホスト名

とおなじ（まず、これがうごかなきゃだめだね〜）
＃もっともmhがいんすとーるしてなきゃ意味ないけど…


.S	たとえば、Received: のようなヘッダを残すには？

Current(1.6以降) では、すべての変数は 

	$Envelope{"field名を小文字にした単語:"}
	＃ いまのばあい、$Envelope{'received:'}

に、はいってるので、 これを どっかの hook で Add するとかでＯＫでしょう。
もっとも、

	$Envelope{'received:'} =~ s/(\w)Received:/$1\nReceived:/g;

とかして、（つながってますんで、）複数行にもどさないと あきまへん…

古いやつだと、直接 next if /^Received:/ をけずって、addするしかありま
せんが
.q
--- fml.pl	Tue Nov 14 16:49:28 1995
+++ fml.pl.new	Tue Nov 14 16:49:02 1995
@@ -173,6 +173,11 @@
 
 	# Fields to skip. Please custumize below.
 	next if /^Received:/io;
+
+	if (/^Received:/io) {
+	    $ReceivedHeaders .= "X-Received: $contents\n"; #?
+	}
+
 	next if /^In-Reply-To:/io && (! $SUPERFLUOUS_HEADER);
 	next if /^Return-Path:/io;
 	next if /^X-M\S+:/io;
@@ -518,6 +523,8 @@
     $body .= $_cf{'MIME', 'header'} if (!$PREVENT_MIME) && $_cf{'MIME', 'header'};
     $body .= $SuperfluousHeaders    if $SUPERFLUOUS_HEADERS;
 
+    $body .= $ReceivedHeaders;
+
     # Additional hook;
     $body .= "Message-Id: $Message_Id\n" if $USE_ORIGINAL_MESSAGE_ID;
     $HEADER_ADD_HOOK && &eval($HEADER_ADD_HOOK, 'Header Add Hook');
.~q



.# ##########################################################
.include smtp.wix
.include uip.wix
.include lib.wix
.include perl.wix
.include log.wix


.C	あしたリリースオフ

いや、べつに意味はないんだけど…＃出典のヒントくらいはするかっと(^^;;;

具体例にかかれているものは ほとんどすべて架空のＭＬとかＢＢＳとかを考
えて書き下したもので引用等の問題は関係ありません。

引用等は indent され、From: 等が一緒に付記されています。
引用等の許可をいただいた方々に感謝します _o_ 


.include ref.wix

.# FAQ ENDS


.# Id: README.eng,v 1.1 1995/10/11 11:30:11 fukachan Exp 
.# $Id$
