.C	改造について
.l	hack
.xref	data-structure

改造の話は fml のデータ構造の章は読んでおくとよりわかり易くなります。
.xref	data-structure

.S	HOW TO DEBUG ... ［デバッグのポイント］

   fml-support: 01411 より

…略…

○ 私 printf デバッグがすきなので、$debug = 1; にした時の画面に出るエ
ラー情報から推測するのが多いです。

もしくは

○ perl -d オプションで perl debugger を使う

○ どのファイルか？は目的別なのでそれっぽい名前のことが多いですが…

基本関数	fml.pl
SMTP		libsmtp.pl
その他		lib(それっぽい名前).pl

	ra  = remote administraion
	fop = file operation

とか省略系もあるけど… ちなみに
.ptr{library-lists} にライブラリの説明一覧があります。


.S	消してもいいファイル…

プロセスがない時なら、すべてのファイルは手作業でなにしてもいいです。

結局メールがきた時"だけ" fml.pl が動いているので、それ以外の時は何をし
てもOKです。まとめおくりサーバが動いてる瞬間に var/log/msendrc をいじっ
てはいけないのも同様の理由です。そうでないときなら手動 edit できます。

そりゃさすがに code の debug は今動いているＭＬとは別のところでやった
ほうがいいですけど…

間違って消して一番困りそうなのは seq と var/log/msendrc あたりです :-)
ようするにＭＬの今の記事番号や uniqueness を保存しているログですね

seq ファイルの番号が狂うと 記事を overwrite したりはしないかわりに管理
者にエラーメールがきます。
var/log にメールは保存されるので、復旧は簡単ですが面倒は面倒です。

間違って seq を消してしまった時は 即効で spool の一番大きい番号を調べて
その値を seq へ書き込みます(^^)

msendrc 消しちゃうと log 見て、直すか＃すげぇたいへんそう

次回 msend.pl が起動する時に自動復旧されることを期待するか…
ただ、これは最新のメールしか送らないから↑、たまっていた分はログみない
と不明のままになります。


.S	MIME文字列を日本語へ変換すること
.seealso	MIME-1, MIME-2

$MailBody でもなんでも任意の変数の中の ISO-2022-JP で始まる部分を
Decodeしてしまうなら(こんな邪悪なことは普通しません、これをしなくては
いけないのはとてつもなください通信サービス業者が…の場合です)、

例：	$MailBody をMIME逆変換して日本語にする場合
	$MailBody = &DecodeMimeStrings($MailBody);

こんな感じのコードを適当な場所に書けばいいわけですね。
＃例えば HOOK でしかければよい


.S	改造事例:  sitedef.ph

# Subject の [ML 数字] や (ML 数字) は切り落とし
# Subject のオリジナルは X-Original-Subject に保存して
# みやすい Subject を提供する
# 
# Subject Hack
$Envelope{'h:X-Original-Subject:'} = $Envelope{'h:Subject:'};
$Envelope{'h:Subject:'} =~ s/\[\S+\s+\d+\]//g;
$Envelope{'h:Subject:'} =~ s/\(\S+\s+\d+\)//g;
$Envelope{'h:Subject:'} =~ s/Re:\s+Re:\s+/Re: /g;

if ($Envelope{'h:X-Original-Subject:'} eq $Envelope{'h:Subject:'}) {
    undef $Envelope{'h:X-Original-Subject:'};
}

!;

# received 行を保存
@HdrFieldsOrder = 
('received',
 'Return-Path', 'Date', 'From', 'Subject',
 'X-Original-Subject',
 'Sender',
 'To', 'Reply-To', 'Errors-To', 'Cc', 'Posted',
 ':body:', 'Message-Id', ':any:', ':XMLNAME:', 
 'X-Cache',	
 ':XMLCOUNT:', 'X-MLServer',
 'mime-version', 'content-type', 'content-transfer-encoding',
 'XRef', 'X-Stardate', 'X-Ml-Info', 
 'References', 'In-Reply-To', 'Precedence', 'Lines');

# 念のため最後に記事を 644 にして誰でも読めるようにする
$DISTRIBUTE_CLOSE_HOOK = q#
	chmod 0644, "$FP_SPOOL_DIR/$ID";
#;


.S	改造事例:  axion.phys.titech.ac.jp

.q	

このマシンのすべてのＭＬサーバで共通の設定(sitedef.ph)
別に config.ph でいいんだけど、
ＭＬが多いもんで、共通の設定はここでいっきにしてしまう。	

#!/usr/local/bin/perl --    # -*-Perl-*-
# コマンド実行時の返答の時のフェイスマーク(^^)
$FACE_MARK = '(o)^^)';

# ish の時は SJIS自動変換
$USE_SJIS_IN_ISH = 1;

# host_map_lookup での DNS 遅延情報を トレースする、
# １０秒かかるホストはログに残す
$TRACE_SMTP_DELAY = 10;		# 10 sec.

# インターネットプロバイダ (or.jp のアドレスを持つユーザ)に対しては 
# addrのチェックを厳しく

%SEVERE_ADDR_CHECK_DOMAINS = ('or.jp', 1);

1;
.~q	


.S	改造事例:  mnews-ml

.q

# コマンドメールの返送に付くフッタのフェースマーク
$FACE_MARK     = '(^_^)/~';

# たとえ空メールでも配布する
$AUTO_REGISTRATION_LINES_LIMIT = -1;

# ヘッダの「X-何たら: 」を素通しにする
$SUPERFLUOUS_HEADERS = 1;	# preserve more header fields

# MIME に対応する
$USE_LIBMIME   = 1;		# when use MIME Extension in libMIME.pl

# spool に MIME デコードしてから書き込む
$MIME_DECODED_ARTICLE = 1;	# do MIME decoding, then spool

# コマンドメールであるかどうかを確認する行数
$COMMAND_CHECK_LIMIT = 1;	# the first 3 lines is checked for
 				# mistakes whether the command mode or not?
 				# at &Parsing in fml.pl, 
 
# コマンドで単なるシンタックスエラーの警告
$USE_WARNING = 1;		# コマンドで単なるシンタックスエラーの警告

# まとめ送りのとき mh/burst 用にする
$USE_RFC934    = 1;		# inMatomeokuri, use mh/burst for the split
 
# パス名を変更(更新のとき =* をコピーすれば良い)
$OBJECTIVE_FILE = "$DIR/=objective"; 	# objective file
$GUIDE_FILE    = "$DIR/=guide";		# the guide file of our Mailing List 
$HELP_FILE     = "$DIR/=help";		# the help file for useful commands
$DENY_FILE     = "$DIR/=deny";		# attention to illegal access
$FAIL_FILE     = "$DIR/=fail";		# attention to illegal access
$WELCOME_FILE  = "$DIR/=welcome";	# could be "$DIR/welcome"

# 気分的に log とは分離した
$MGET_LOGFILE  = "$DIR/log_mget";	# log file for mget routine

# ちょっとした変更(特に効果はない)
$Subject       = '(No Subject in original)';	# Subject field

# SMTP コネクションを張って HELO のときに localhost と名乗る
$Envelope{'macro:s'} = 'localhost';

# 配送レベルを bulk にする
$PRECEDENCE     = 'bulk';

# ローテーションするログの指定
@NEWSYSLOG_FILES = ("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak",
                    "${LOGFILE}_archive", "${LOGFILE}_matome");

# スキップする「X-何たら: 」フィールド
$SKIP_FIELDS = '|X-Nsubject|X-Confirm-Reading-To';

# スタートフック
$START_HOOK = q#
     # コントロールメールアドレスか?
    if ($CONTROL_ADDRESS && ($Envelope{'mode:chk'} =~ /$CONTROL_ADDRESS/i)) {
         # 新規登録か?
        if ($Envelope{'Body'} =~ /subscribe/io
              && $Envelope{'Body'} !~ /unsubscribe/io) {
            &use('utils');
            &AutoRegist(*Envelope);
            $DO_NOTHING = 1;
        }
        $Envelope{'mode:uip'} = 'on'
     # コマンドモードか?
     # (この ML では本体の方でコマンドメールを受け付けていないため)
    } elsif ($Envelope{'mode:uip'}) {
        &Logging("Unsupport Command Mail");
        &SendFile($From_address, 
                  "Unsupport Command Mail this Address $ML_FN", $FAIL_FILE);
        $DO_NOTHING = 1;
     # 普通に配送する
    } else {
        &Distribute;
        $DO_NOTHING = 1;
    }
#;

# SMTP 開始時のフック
$SMTP_OPEN_HOOK = q#
     # 元メールの To: フィールドを保存
    $Envelope{'h:To:'}       = $Envelope{'h:to:'}
          || $Envelope{'h:apparently-to:'} || "$MAIL_LIST $ML_FN";
     # Reply-To: を強制的に書き換える
    $Envelope{'h:Reply-To:'} = $Envelope{'h:reply-to:'} = $MAIL_LIST;
     # MIME なら Subject: をデコードする
    if ($USE_LIBMIME && $Envelope{'MIME'}) {
        &use('MIME');
        $Envelope{'h:Subject:'} = &DecodeMimeStrings($Envelope{'h:Subject:'});
    }
#;
 
# ヘッダに追加するフック
$HEADER_ADD_HOOK = q#
     # X-Nsubject: フィールドの処理
     # (この ML では X-Nsubject: も Subject: と同じ処理を受ける)
    if ($Envelope{'x-nsubject:'}) {
        if ($STRIP_BRACKETS) {
            $_ = $Envelope{'x-nsubject:'};
            local($r)  = 10;

            s/\[$BRACKET:\d+\]\s*//g;

            while (s/Re:\s*Re:\s*/Re: /gi && $r-- > 0) { ;}

            $Envelope{'x-nsubject:'} = $_;
        }
        if ($USE_LIBMIME && $Envelope{'MIME'}) {
            &use('MIME');
            $Envelope{'x-nsubject:'} =
                  &DecodeMimeStrings($Envelope{'x-nsubject:'});
        }
        $body .= "X-Nsubject: [$BRACKET:$ID] $Envelope{'x-nsubject:'}\n";
    }
#;
 
# libtraffic のフック(試験的設定)
$TRF_NAME_HOOK = q#
    $name =~ s/umura@solan\.chu/umura@nn.solan./oi;
#;

.~q



.S	改造事例: Reply-To == MLで必要な時にはReply-Toを設定するコマンド
.key	# replyto コマンド

.q
From:    Yuao Tanigawa <yuao@infonia.or.jp>
X-ML-Name: fml-support
X-Mail-Count: 01249

メール本文の最初に、
	# replyto myaddr@mydomain 

と書いて、次の行から通常の文章を書いて投稿すれば、
Reply-To にそのアドレスをセットして記事を配送します。

  うちのMLでは、今まで、Reply-Toのアドレスを強制的にはMLの
アドレスに書き換えないようにしていたのですが、最近、いつも
Reply-Toに自分のアドレスを書いて投稿する人とかいて、Reply-To
にはアドレスを書かないようにと言うと、メールソフトの使い方
とかよく知らなくて、Reply-Toのアドレスの設定方法とかも知ら
ない人とかいたりして（学校とかでも周りの人とかも知らないら
しい）、どうしようもなくなったので、Reply-Toには、強制的に
MLのアドレスを書くようにしました。
  でも、必要なときにはReply-Toにアドレスが設定できると便利
なので、以下のようにして、# replyto コマンドを使えるように
してみました。

  config.phで、$SMTP_OPEN_HOOK には、

    $Envelope{'h:reply-to:'} = $Reply_to
            = $Envelope{'command:reply-to:'} || $MAIL_LIST;

として、$COMMAND_HOOK には、

    if(/replyto/io) {
        &Log("Set Reply-To: $Fld[2]");
        $e{'command:reply-to:'} = $Fld[2];
        $e{'Body'} =~ s/#\s*replyto\s+\S+\n//io;
        &Distribute;
        last GivenCommands;
    }

としました。ただし、この場合、$COMMAND_HOOK のクォートに、
`#'記号が使えないです。

.~q


.S	From と 配送先が一致した時に、配送を止めたい(dynamical skip?)
.k	%SKIP
.key	$SKIP{'mail-address'}
.key	skip
.key	skip-but-determined-dynamically
.key	$START_HOOK

こういう処理を config.ph にかいてください。

$START_HOOK = q#
	$SKIP{'fukachan@phys.titech.ac.jp'} = 1
		if &AddressMatch($From_address, 'fukachan@phys.titech.ac.jp');
#;

こうすると fukachan@phys.titech.ac.jp あてのメールは skip します。
↑ここは actives とかに現れるものと同じにして下さい。

複数あるなら 全部を うえのフックに加えて下さい。


.S	古典の printf debug の例

.q
From: fukachan@phys.titech.ac.jp
X-Mail-Count: 00702 

じゃ、
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
を、

&InitConfig;			# initialize date etc..
&Parsing;			# Phase 1(1st pass), pre-parsing here
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers

のあいだにはさんで、

	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&InitConfig;			# initialize date etc..
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&Parsing;			# Phase 1(1st pass), pre-parsing here
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";

とかしておいて、

% perl sbin/localtest.pl |sed 's/test/#guide/' | perl fml.pl $PWD -d 

とかして、この REQ:GUIDE の値の変化をみるというのはどうでしょう？

ただしいばあいは &Parsing のあと １になって そのままのはずですよね

.~q


.S	fmlのコマンドが送れるページの例 [http://www.j-is.or.jp/fml/]

.q
in fml-support: Count: 01585
From: Yuao Tanigawa <yuao@infonia.or.jp>
>   fmlのコマンドが送れるページを作ってみました。URLは
> http://www.j-is.or.jp/fml/ です。

…
.~q


.S	$ProcedureException{"bye", "ignore_list"} (将来もあるかは未定)

   $ProcedureException{"bye", "ignore_list"} = $MEMBER_LIST;

とかすると、member list に operation したふりだけして何もしないという 
exception code いれたけど、裏技なのでdocumentにはかかず状態
このコードはSNMPなMIB的になってしまふのかしらん… あななやまし


.S	新しく『特定のファイルを送り返す』コマンドを作る
.l	my-file-sendback-command

例: コマンド # news でニュースというファイルを送り返す。

config.ph に

%LocalProcedure = (
		    # help for usage of commands
		    'news',	'ProcFileSendBack',
		    '#news',	"$DIR/news",

		);

と書けば news という新しいコマンドのでき上がりです。


.S	メンバーを問わずファイル news を送り返す例

$START_HOOK = q#
    $UJA_FILE = "$DIR/uja";

    if ($Envelope{'Body'} =~ /^[\n\s]*\#\s*uja/) {
	&SendFile($Envelope{'Addr2Reply:'}, "UJA $ML_FN", $UJA_FILE);
	&Log("UJA");
	$DO_NOTHING = 1;
    }
#;


.S	自動送り返しサーバってどう実装してるんですか？ その１
.key	自動送り返しサーバっ実装例１

なんのことはない。ガイドファイルに適当なファイルを設定して、config.ph 
で強制的にガイド送り返ししかしないようにしてしまえば終わりですね。
＃いままで、きづかなかった…

ポイントは、“$START_HOOK にしかける”ってところですね。

例：
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$FML            = '/home/axion/fukachan/work/spool/EXP';
$GUIDE_FILE	= "$FML/doc/INFO";
$LOGFILE	= "$FML/var/log/fmlinfo-log"; # activity log file

$START_HOOK     = q# $Envelope{'req:guide'} = 1;#;

1;
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿


.S	自動送り返しサーバってどう実装してるんですか？ その２
.key	自動送り返しサーバっ実装例２

設問：fml-current@phys.titech.ac.jp 宛に送ったメールは自動返送されて戻っ
てくるのですが、こういったものを作るには、どのような設定をすればいい？

いまでは libSendBack.pl ってのにまとまってます。
/usr/ucb/vacation ってのはこれとほぼ同じですね。
＃もっともあれは unix from をみるんですが

理屈は コードをけずっただけ（笑）というだけですが、

０．いつもの通り仕掛ける
１．ロック
２．メンバーチェックをしないで
３．送り返す
	&SendFile($to, "", 目的のFILE);
４．ロックをはずす

in fml.pl MAIN PART

(!$USE_FLOCK) ? &Lock : &Flock;	# Locking 

#---------------- CHANGE -------------------------

$MAIL_LIST	= 'fml@phys.titech.ac.jp';
$ML_FN		= '(fml recent infomation)';
$MAINTAINER	= 'fml-request@phys.titech.ac.jp';

$INFO_FILE	= "$DIR/INFO";

$LOGFILE	= "$DIR/fmlinfo-log";		# activity log file

$to             = $Reply_to ? $Reply_to : $From_address;

&SendFile($to, "Info $ML_FN", $INFO_FILE);
&Log("Info request from $From_address");

#---------------- CHANGE ENDS --------------------

(!$USE_FLOCK) ? &Unlock : &Funlock;# UnLocking 
exit 0;				# the main ends.



.S	たとえば、Received: のようなヘッダを残すには？

2.1 では

    unshift(@HdrFieldsOrder, 'received');

とすればいいでしょう。もっともこの場合一行だけ Received ではなく 
received になってしまってちょっと情けないかも知れませんが…
＃RFC822 としては大文字小文字は関係ないので問題はない。カッコ悪いだけ;-)


.S	今すでにスプールにあるファイルをMIME逆変換する

lib/MIME/rmime を使って、/bin/sh なら

	for file in *
	do
	   mv   $file     $file.org
	   perl rmime $file.org > $file
	done

くらいでＯＫでしょう
＃とりあえず .org つきのをバックアップに残すコードつき:-)


.S	mget でえた spool の下のファイルを mh 以外で読む時
.key	lib/Utilitites/packmbox.pl
.key	packmbox.pl

lib/Utilitites/packmbox.pl を使って、

	(cd spool; packmbox.pl ) > ~/mbox

として、mbox をつくれば、これにたいして、/bin/Mail なり Rmail なりを使
うことができて便利でしょう。


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996-1997 fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
