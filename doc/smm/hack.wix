.C	改造について
=E.C	Hack Tips
.l	hack

改造の話はFMLのデータ構造の章は読んでおくとよりわかり易くなります。
.xref	data-structure

.S	HOW TO DEBUG ... ［デバッグのポイント］
=E.S	How to debug
.k	debug

   fml-support: 01411 より

…略…

○ 私 printf デバッグがすきなので $debug = 1; にした時の画面に出るエラー
情報から推測するのが多いです。
=E
* printf debug is fundamental. FML uses $debug variable. If you know
the details of processing, set $debug = 1, which helps your debug.

もしくは

○ perl -d オプションで perl debugger を使う
=E
* perl -d enables perl debugger.

○ どのファイルか？は目的別なのでそれっぽい名前のことが多いですが…
=E
* which file is libraries for an object?
  A lib"NAME".pl library corresponds to functions on "NAME".
  e.g. libsmtp.pl is SMTP (Simple Mail Tranfer Protocol) routines.

基本関数	fml.pl
SMTP		libsmtp.pl
その他		lib(それっぽい名前).pl

	ra  = remote administration
	fop = file operation

とか省略系もあるけど… ちなみに
.ptr{library-lists} にライブラリの説明一覧があります。


.S	消してもいいファイル…
=E.S	I can remove this file or not?

プロセスがない時なら、すべてのファイルは手作業でなにしてもいいです。
=E
If no process runs, you can edit any files :-). Howerver in general
you require "LOCK FML" to edit files though FML runs when a mail comes
in but I don't know when a mail comes. "makefml" locks before the
operations.

結局メールがきた時"だけ" fml.pl が動いているので、それ以外の時は何をし
てもOKです。まとめおくりサーバが動いてる瞬間に var/log/msendrc をいじっ
てはいけないのも同様の理由です。そうでないときなら手動 edit できます。

そりゃさすがに code の debug は今動いているMLとは別のところでやったほ
うがいいですけど…
=E
I reccomends the debug of codes apart from the current working ML :D

間違って消して一番困りそうなのは seq と var/log/msendrc あたりです :-)
もちろんメンバーリストも消すとやっかいです。
ようするにＭＬの今の記事番号や uniqueness を保存しているログですね。
=E
Removing $DIR/seq, $DIR/actives, $DIR/members and $DIR/var/log/msendrc
must be critical where actives and members are the member list of ML.
seq is the current article number and msendrc is the log file of msend
(digest) which log saves the number of msend'ed articles.

seq ファイルの番号が狂うと記事を上書きしたりはしないかわりに管理者にエ
ラーメールがきます。var/log にメールは保存されるので、復旧は簡単ですが
面倒は面倒です。

間違って seq を消してしまった時は 即効で spool の一番大きい番号を調べて
その値を seq へ書き込めばよいです。
=E
If you remove seq in accident, you should write the largest article
number in the spool as soon as possible. In the case of msendrc, you
have to write msendrc by reading log file ;_; If msendrc is lack,
msend.pl reconfigures the msendrc. But this msendrc must be not
continuous to msend'ed users since msendrc creates a new msendrc with
the latest article number.

msendrc 消しちゃうと log 見て、直すか＃すげぇたいへんそう

次回 msend.pl が起動する時に自動復旧されることを期待するか…ただ、これ
は最新のメールしか送らないから↑、たまっていた分はログみないと不明のま
まになります。


.S	MIME文字列を日本語へ変換すること
=E.S	Convert MIME strings to Japanese
.xref	MIME-1, MIME-2

$MailBody でもなんでも任意の変数の中の ISO-2022-JP で始まる部分を
Decodeしてしまうなら(こんな邪悪なことは普通しません、これをしなくては
いけないのはとてつもなください通信サービス業者が…の場合です)、

例：	$MailBody をMIME逆変換して日本語にする場合
	$MailBody = &DecodeMimeStrings($MailBody);

こんな感じのコードを適当な場所に書けばいいわけですね。
＃例えば HOOK でしかければよい
=E
To convert MIME strings to Japanese, you can use codes like
=S
	$MailBody = &DecodeMimeStrings($MailBody);


.S	改造事例:  sitedef.ph
=E.S	example: sitedef.ph
.k	sitedef.ph

# Subject の [ML 数字] や (ML 数字) は切り落とし
# Subject のオリジナルは X-Original-Subject に保存して
# みやすい Subject を提供する
# 
=E
# To provide a subject for your eys, 
# cut [ML number] or (ML number) in subjects and 
# preserve the original subject to X-Original-Subject.
# 

# Subject Hack
$Envelope{'h:X-Original-Subject:'} = $Envelope{'h:Subject:'};
$Envelope{'h:Subject:'} =~ s/\[\S+\s+\d+\]//g;
$Envelope{'h:Subject:'} =~ s/\(\S+\s+\d+\)//g;
$Envelope{'h:Subject:'} =~ s/Re:\s+Re:\s+/Re: /g;

if ($Envelope{'h:X-Original-Subject:'} eq $Envelope{'h:Subject:'}) {
    undef $Envelope{'h:X-Original-Subject:'};
}

!;

# received 行を保存
=E
# save received: lines

@HdrFieldsOrder = 
('received',
 'Return-Path', 'Date', 'From', 'Subject',
 'X-Original-Subject',
 'Sender',
 'To', 'Reply-To', 'Errors-To', 'Cc', 'Posted',
 ':body:', 'Message-Id', ':any:', ':XMLNAME:', 
 'X-Cache',	
 ':XMLCOUNT:', 'X-MLServer',
 'mime-version', 'content-type', 'content-transfer-encoding',
 'XRef', 'X-Stardate', 'X-Ml-Info', 
 'References', 'In-Reply-To', 'Precedence', 'Lines');

# 念のため最後に記事を 644 にして誰でも読めるようにする
=#
# chmod 644 articles in the spool

$DISTRIBUTE_CLOSE_HOOK = q#
	chmod 0644, "$FP_SPOOL_DIR/$ID";
#;


.S	改造事例: axion.phys.titech.ac.jp
=E.S	example:  axion.phys.titech.ac.jp

.q	

このマシンのすべてのＭＬサーバで共通の設定(sitedef.ph)
別に config.ph でいいんだけど、
ＭＬが多いもんで、共通の設定はここでいっきにしてしまう。

#!/usr/local/bin/perl --    # -*-Perl-*-

# コマンド実行時の返答の時のフェイスマーク(^^)
=E
# face marks

$FACE_MARK = '(o)^^)';

# ish の時は SJIS自動変換
=#
# SJIS auto conversion when ish

$USE_SJIS_IN_ISH = 1;

# host_map_lookup での DNS 遅延情報を トレースする、
# １０秒かかるホストはログに残す
=E
# trace slow smtp session infomation

$TRACE_SMTP_DELAY = 10;		# 10 sec.

# インターネットプロバイダ (or.jp のアドレスを持つユーザ)に対しては 
# addrのチェックを厳しく
=E
# check ISP users severely

%SEVERE_ADDR_CHECK_DOMAINS = ('or.jp', 1);

1;
.~q	


.S	改造事例:  mnews-ml
=E.S	example: mnews-ml

=E
* not translate 

.q

# コマンドメールの返送に付くフッタのフェースマーク
$FACE_MARK     = '(^_^)/~';

# たとえ空メールでも配布する
$AUTO_REGISTRATION_LINES_LIMIT = -1;

# ヘッダの「X-何たら: 」を素通しにする
$SUPERFLUOUS_HEADERS = 1;	# preserve more header fields

# MIME に対応する
$USE_LIBMIME   = 1;		# when use MIME Extension in libMIME.pl

# spool に MIME デコードしてから書き込む
$MIME_DECODED_ARTICLE = 1;	# do MIME decoding, then spool

# コマンドメールであるかどうかを確認する行数
$COMMAND_CHECK_LIMIT = 1;	# the first 3 lines is checked for
 				# mistakes whether the command mode or not?
 				# at &Parsing in fml.pl, 
 
# コマンドで単なるシンタックスエラーの警告
$USE_WARNING = 1;		# コマンドで単なるシンタックスエラーの警告

# まとめ送りのとき mh/burst 用にする
$USE_RFC934    = 1;		# inMatomeokuri, use mh/burst for the split
 
# パス名を変更(更新のとき =* をコピーすれば良い)
$OBJECTIVE_FILE = "$DIR/=objective"; 	# objective file
$GUIDE_FILE    = "$DIR/=guide";		# the guide file of our Mailing List 
$HELP_FILE     = "$DIR/=help";		# the help file for useful commands
$DENY_FILE     = "$DIR/=deny";		# attention to illegal access
$FAIL_FILE     = "$DIR/=fail";		# attention to illegal access
$WELCOME_FILE  = "$DIR/=welcome";	# could be "$DIR/welcome"

# 気分的に log とは分離した
$MGET_LOGFILE  = "$DIR/log_mget";	# log file for mget routine

# ちょっとした変更(特に効果はない)
$Subject       = '(No Subject in original)';	# Subject field

# SMTP コネクションを張って HELO のときに localhost と名乗る
$Envelope{'macro:s'} = 'localhost';

# 配送レベルを bulk にする
$PRECEDENCE     = 'bulk';

# ローテーションするログの指定
@NEWSYSLOG_FILES = ("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak",
                    "${LOGFILE}_archive", "${LOGFILE}_matome");

# スキップする「X-何たら: 」フィールド
$SKIP_FIELDS = '|X-Nsubject|X-Confirm-Reading-To';

# スタートフック
$START_HOOK = q#
     # コントロールメールアドレスか?
    if ($CONTROL_ADDRESS && ($Envelope{'mode:chk'} =~ /$CONTROL_ADDRESS/i)) {
         # 新規登録か?
        if ($Envelope{'Body'} =~ /subscribe/io
              && $Envelope{'Body'} !~ /unsubscribe/io) {
            &use('utils');
            &AutoRegist(*Envelope);
            $DO_NOTHING = 1;
        }
        $Envelope{'mode:uip'} = 'on'
     # コマンドモードか?
     # (この ML では本体の方でコマンドメールを受け付けていないため)
    } elsif ($Envelope{'mode:uip'}) {
        &Logging("Unsupport Command Mail");
        &SendFile($From_address, 
                  "Unsupport Command Mail this Address $ML_FN", $FAIL_FILE);
        $DO_NOTHING = 1;
     # 普通に配送する
    } else {
        &Distribute;
        $DO_NOTHING = 1;
    }
#;

# SMTP 開始時のフック
$SMTP_OPEN_HOOK = q#
     # 元メールの To: フィールドを保存
    $Envelope{'h:To:'}       = $Envelope{'h:to:'}
          || $Envelope{'h:apparently-to:'} || "$MAIL_LIST $ML_FN";
     # Reply-To: を強制的に書き換える
    $Envelope{'h:Reply-To:'} = $Envelope{'h:reply-to:'} = $MAIL_LIST;
     # MIME なら Subject: をデコードする
    if ($USE_LIBMIME && $Envelope{'MIME'}) {
        &use('MIME');
        $Envelope{'h:Subject:'} = &DecodeMimeStrings($Envelope{'h:Subject:'});
    }
#;
 
# ヘッダに追加するフック
$HEADER_ADD_HOOK = q#
     # X-Nsubject: フィールドの処理
     # (この ML では X-Nsubject: も Subject: と同じ処理を受ける)
    if ($Envelope{'x-nsubject:'}) {
        if ($STRIP_BRACKETS) {
            $_ = $Envelope{'x-nsubject:'};
            local($r)  = 10;

            s/\[$BRACKET:\d+\]\s*//g;

            while (s/Re:\s*Re:\s*/Re: /gi && $r-- > 0) { ;}

            $Envelope{'x-nsubject:'} = $_;
        }
        if ($USE_LIBMIME && $Envelope{'MIME'}) {
            &use('MIME');
            $Envelope{'x-nsubject:'} =
                  &DecodeMimeStrings($Envelope{'x-nsubject:'});
        }
        $body .= "X-Nsubject: [$BRACKET:$ID] $Envelope{'x-nsubject:'}\n";
    }
#;
 
# libtraffic のフック(試験的設定)
$TRF_NAME_HOOK = q#
    $name =~ s/umura@solan\.chu/umura@nn.solan./oi;
#;

.~q


.S	改造事例: Reply-To == MLで必要な時にはReply-Toを設定するコマンド
.key	# replyto コマンド

=E
* not translate 

.q
From:    Yuao Tanigawa <yuao@infonia.or.jp>
X-ML-Name: fml-support
X-Mail-Count: 01249

メール本文の最初に、
	# replyto myaddr@mydomain 

と書いて、次の行から通常の文章を書いて投稿すれば、
Reply-To にそのアドレスをセットして記事を配送します。

  うちのMLでは、今まで、Reply-Toのアドレスを強制的にはMLの
アドレスに書き換えないようにしていたのですが、最近、いつも
Reply-Toに自分のアドレスを書いて投稿する人とかいて、Reply-To
にはアドレスを書かないようにと言うと、メールソフトの使い方
とかよく知らなくて、Reply-Toのアドレスの設定方法とかも知ら
ない人とかいたりして（学校とかでも周りの人とかも知らないら
しい）、どうしようもなくなったので、Reply-Toには、強制的に
MLのアドレスを書くようにしました。
  でも、必要なときにはReply-Toにアドレスが設定できると便利
なので、以下のようにして、# replyto コマンドを使えるように
してみました。

  config.phで、$SMTP_OPEN_HOOK には、

    $Envelope{'h:reply-to:'} = $Reply_to
            = $Envelope{'command:reply-to:'} || $MAIL_LIST;

として、$COMMAND_HOOK には、

    if(/replyto/io) {
        &Log("Set Reply-To: $Fld[2]");
        $e{'command:reply-to:'} = $Fld[2];
        $e{'Body'} =~ s/#\s*replyto\s+\S+\n//io;
        &Distribute;
        last GivenCommands;
    }

としました。ただし、この場合、$COMMAND_HOOK のクォートに、
`#'記号が使えないです。

.~q


.S	From と 配送先が一致した時に、配送を止めたい(dynamical skip?)
=E.S	not deliver From: field address of in-coming mail. 
.k	%SKIP
.k	$SKIP{アドレス}
.k	skip
.k	$START_HOOK

こういう処理を config.ph にかいてください。

$START_HOOK = q#
	$SKIP{'fukachan@phys.titech.ac.jp'} = 1
		if &AddressMatch($From_address, 'fukachan@phys.titech.ac.jp');
#;

こうすると fukachan@phys.titech.ac.jp あてのメールは skip します。
↑ここは actives とかに現れるものと同じにして下さい。

複数あるなら 全部を うえのフックに加えて下さい。


.S	古典の printf debug の例
=E.S	printf debug
.k	debug: printf
 
.q
From: fukachan@phys.titech.ac.jp
X-Mail-Count: 00702 

じゃ、

	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";

を、

&InitConfig;			# initialize date etc..
&Parsing;			# Phase 1(1st pass), pre-parsing here
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers

のあいだにはさんで、

	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&InitConfig;			# initialize date etc..
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&Parsing;			# Phase 1(1st pass), pre-parsing here
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";
&GetFieldsFromHeader;		# Phase 2(2nd pass), extract headers
	print STDERR "REQ:GUIDE $Envelope{'req:guide'}";

とかしておいて、

% perl sbin/localtest.pl |sed 's/test/#guide/' | perl fml.pl $PWD -d 

とかして、この REQ:GUIDE の値の変化をみるというのはどうでしょう？

ただしいばあいは &Parsing のあと １になって そのままのはずですよね

.~q


.S	fmlのコマンドが送れるページの例
=E.S	URL where you can send FML commands
.url	http://www.j-is.or.jp/fml/

.q
in fml-support: Count: 01585
From: Yuao Tanigawa <yuao@infonia.or.jp>
>   fmlのコマンドが送れるページを作ってみました。URLは
> http://www.j-is.or.jp/fml/ です。

…
.~q
=E
http://www.j-is.or.jp/fml/

.S	$ProcedureException{"bye", "ignore_list"} (将来もあるかは未定)
=E.S	$ProcedureException{"bye", "ignore_list"} 

   $ProcedureException{"bye", "ignore_list"} = $MEMBER_LIST;

とかすると、member list に operation したふりだけして何もしないという 
exception code いれたけど、裏技なのでdocumentにはかかず状態
このコードはSNMPなMIB的になってしまふのかしらん… あななやまし
=E
fake operation to a member list. I cannot ensure this code exists in
the future.

.S	新しく『特定のファイルを送り返す』コマンドを作る
=E.S	make a new command what send back a file
.l	my-file-sendback-command

例: コマンド # news でニュースというファイルを送り返す。
=E
E.g. "# news" command is to send back $DIR/news file.

config.ph に
=E
In config.ph

%LocalProcedure = (
		    # help for usage of commands
		    'news',	'ProcFileSendBack',
		    '#news',	"$DIR/news",

		);

と書けば news という新しいコマンドのでき上がりです。


.S	メンバーを問わずファイル uja を送り返す例
=E.S	to send back $DIR/uja for anyone

例:
１	誰からのリクエストでもOK
２	本文にキーワード uja とかくこと
=E
1	requests from anyone are O.K.
2	keyword "# uja" in the mail body to send back "uja"

$START_HOOK = q#
    $UJA_FILE = "$DIR/uja";

    if ($Envelope{'Body'} =~ /^[\n\s]*\#\s*uja/) {
	&SendFile($Envelope{'Addr2Reply:'}, "UJA $ML_FN", $UJA_FILE);
	&Log("UJA");
	$DO_NOTHING = 1;
    }
#;


.S	自動送り返しサーバの実装例
=E.S	Automatic Replay Server
.key	自動送り返しサーバの実装例

なんのことはない。ガイドファイルに適当なファイルを設定して、config.ph 
で強制的にガイド送り返ししかしないようにしてしまえば終わりですね。
=E
Please set a file to $GUIDE_FILE in config.ph and set up $START_HOOK
in the following hook:

ポイントは、“$START_HOOK にしかける”ってところです。

例：

1	適当なＭＬ(guide ML)を作成する (makefml newml guide)
2	普通に aliases を設定する
3	config.ph に $GUIDE_FILE (guide) の内容をを送り返すなら

	$START_HOOK = q#
		&SendFile($From_address, "Guide $ML_FN", $GUIDE_FILE);
		&Log("Guide request from $From_address");
		$DO_NOTHING = 1;
	#;

を guide ML の config.ph に付け加える。(おわり)


.S	たとえば、Received: のようなヘッダを残すには？
=E.S	Preserve Received: lines

FML 2.1 では
=E
After FML 2.1, set

    unshift(@HdrFieldsOrder, 'received');

とすればいいでしょう。もっともこの場合一行だけ Received ではなく 
received になってしまってちょっと情けないかも知れませんが…
＃RFC822 としては大文字小文字は関係ないので問題はない。カッコ悪いだけ;-)
=E
to preserve Received: fields in the header. A capital is important.


.S	スプールにあるファイルをMIME逆変換する
=E.S	reconvert MIME characters in the spool
.k	スプールにあるファイルをMIME逆変換

lib/MIME/rmime を使って、/bin/sh なら
=E
use lib/MIME/rmime and runs shell scripts like 

	for file in *
	do
	   mv   $file     $file.org
	   perl rmime $file.org > $file
	done

くらいでＯＫでしょう
＃とりあえず .org つきのをバックアップに残すコードつき:-)


.S	mget でえた spool の下のファイルを mh 以外で読む時
=E.S	read not MH in the spool which is sent back by "mget".
.l	lib/Utilitites/packmbox.pl
.k	packmbox.pl

lib/Utilitites/packmbox.pl を使って、
=E
To create "mbox", you use lib/Utilitites/packmbox.pl and runs 

	(cd spool; packmbox.pl ) > ~/mbox

として、mbox をつくれば、これにたいして、/bin/Mail なり Rmail なりを使
うことができて便利でしょう。


.S	配送するメールのMIME部分はDecodeしてしまいたい
=E.S	MIME-Decode MIME parts of a mail to distribute
.xref	MIME-1

では、配送するメールのMIME部分はDecodeしてしまいたい時はどうするか？
例えば、fml.pl の sub GetFieldsFromHeaderで
=E
To MIME-Decode MIME parts of a mail to distribute is to change

    if ($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
    }

を
=E
to

    if ($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
	$MailBody = &DecodeMimeStrings($MailBody);
    }

で本文の任意の ISO-2022-JP で始まる部分だけをMIME decodeします


.S	認証する際のドメインのALIAS %DOMAIN_ALIASES
=E.S	%DOMAIN_ALIASES when autentication

認証する時には ujauja.or.jp  => ujauja.ne.jp に書き換えてTRYしてみる
=E
When FML authenticates From: address as a member or not, FML tries
both who@ujauja.or.jp and who@ujauja.ne.jp.

%DOMAIN_ALIASES = (
	'ujauja.or.jp', 'ujauja.ne.jp',
	);

＃ fml.pl 2.0.24.47 へのパッチの例
=E
An example of a patch for fml.pl 2.0.24.47

--- fml.pl.org	Fri Nov 21 08:11:10 1997
+++ fml.pl	Sat Nov 22 12:51:33 1997
@@ -571,6 +571,19 @@
     &Log("Gecos [$e{'macro:x'}]") if $debug;
     $e{'Addr2Reply:'}    = &Conv2mailbox($e{'h:reply-to:'},*e)||$From_address;
 
+    if (%DOMAIN_ALIASES) {
+	if (&MailListMemberP($From_address)) {
+	    ; # not rewrite
+	}
+	else {
+	    for (keys %DOMAIN_ALIASES) {
+		if ($From_address =~ /$_$/i) {
+		    $From_address =~ s/$_$/$DOMAIN_ALIASES{$_}/i;
+		}
+	    }
+	}
+    }
+
     # To: $MAIL_LIST for readability;
     # &RewriteField(*e, 'Cc') unless $NOT_REWRITE_CC;
     if ($REWRITE_TO < 0) { 



.# $Id$
.# Copyright (C) 1993-1997 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1997 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
