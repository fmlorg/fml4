.C	改造について
=E.C	Tips on Hack
.n	hacks
.l	hack

改造の話はFMLのデータ構造の章は読んでおくとよりわかり易くなります。
.xref	data-structure
=E
To hack FML, it is better to read chapter on data structure.
.xref	data-structure

.S	MIME文字列を日本語へ変換すること
=E.S	Convert MIME strings to Japanese
.xref	MIME-1, MIME-2

$MailBody でもなんでも任意の変数の中の ISO-2022-JP で始まる部分を
Decodeしてしまうなら(こんな邪悪なことは普通しません、これをしなくては
いけないのはとてつもなください通信サービス業者が…などの場合です)、

例:	$MailBody という変数をMIME逆変換して日本語にする場合
	$MailBody = &DecodeMimeStrings($MailBody);

こんな感じのコードを適当な場所に書けばいいわけですね。
＃例えば HOOK でしかければよい
=E
To convert MIME strings to Japanese, you can use codes like
=S
	e.g. variable $MailBody
	$MailBody = &DecodeMimeStrings($MailBody);

.S	改造事例: sitedef.ph
=E.S	example: sitedef.ph
.k	sitedef.ph

# Subject の [ML 数字] や (ML 数字) は切り落とし
# Subject のオリジナルは X-Original-Subject に保存して
# みやすい Subject を提供する
# 
=E
# To provide a subject for your eyes, 
# cut [ML number] or (ML number) in subjects and 
# preserve the original subject to X-Original-Subject.
# 

# Subject Hack
$Envelope{'h:X-Original-Subject:'} = $Envelope{'h:Subject:'};
$Envelope{'h:Subject:'} =~ s/\[\S+\s+\d+\]//g;
$Envelope{'h:Subject:'} =~ s/\(\S+\s+\d+\)//g;
$Envelope{'h:Subject:'} =~ s/Re:\s+Re:\s+/Re: /g;

if ($Envelope{'h:X-Original-Subject:'} eq $Envelope{'h:Subject:'}) {
    undef $Envelope{'h:X-Original-Subject:'};
}

!;

# received 行を保存
=E
# save received: lines

@HdrFieldsOrder = 
('received',
 'Return-Path', 'Date', 'From', 'Subject',
 'X-Original-Subject',
 'Sender',
 'To', 'Reply-To', 'Errors-To', 'Cc', 'Posted',
 ':body:', 'Message-Id', ':any:', ':XMLNAME:', 
 'X-Cache',	
 ':XMLCOUNT:', 'X-MLServer',
 'mime-version', 'content-type', 'content-transfer-encoding',
 'XRef', 'X-Stardate', 'X-Ml-Info', 
 'References', 'In-Reply-To', 'Precedence', 'Lines');

# 念のため最後に記事を 644 にして誰でも読めるようにする
=E
# chmod 644 articles in the spool

$DISTRIBUTE_CLOSE_HOOK = q#
	chmod 0644, "$FP_SPOOL_DIR/$ID";
#;

.S	改造事例: axion.phys.titech.ac.jp
=E.S	example:  axion.phys.titech.ac.jp

.q	

このマシンのすべてのＭＬサーバで共通の設定(sitedef.ph)
別に config.ph でいいんだけど、
ＭＬが多いもんで、共通の設定はここでいっきにしてしまう。

#!/usr/local/bin/perl --    # -*-Perl-*-

# コマンド実行時の返答の時のフェイスマーク(^^)
=E
# face marks

$FACE_MARK = '(o)^^)';

# ish の時は SJIS自動変換
=E
# SJIS auto conversion when ish

$USE_SJIS_IN_ISH = 1;

# host_map_lookup での DNS 遅延情報を トレースする、
# １０秒かかるホストはログに残す
=E
# trace slow smtp session information

$TRACE_SMTP_DELAY = 10;		# 10 sec.

# インターネットプロバイダ (or.jp のアドレスを持つユーザ)に対しては 
# addrのチェックを厳しく
=E
# check ISP users severely

%SEVERE_ADDR_CHECK_DOMAINS = ('or.jp', 1);

1;
.~q	

.S	改造事例:  mnews-ml
=E.S	example: mnews-ml

=E
* not translate. Sorry 

.q

# コマンドメールの返送に付くフッタのフェースマーク
$FACE_MARK     = '(^_^)/~';

# たとえ空メールでも配布する
$AUTO_REGISTRATION_LINES_LIMIT = -1;

# ヘッダの「X-何たら: 」を素通しにする
$SUPERFLUOUS_HEADERS = 1;	# preserve more header fields

# MIME に対応する
$USE_LIBMIME   = 1;		# when use MIME Extension in libMIME.pl

# spool に MIME デコードしてから書き込む
$MIME_DECODED_ARTICLE = 1;	# do MIME decoding, then spool

# コマンドメールであるかどうかを確認する行数
$COMMAND_CHECK_LIMIT = 1;	# the first 3 lines is checked for
 				# mistakes whether the command mode or not?
 				# at &Parsing in fml.pl, 
 
# コマンドで単なるシンタックスエラーの警告
$USE_WARNING = 1;		# コマンドで単なるシンタックスエラーの警告

# まとめ送りのとき mh/burst 用にする
$USE_RFC934    = 1;		# inMatomeokuri, use mh/burst for the split
 
# パス名を変更(更新のとき =* をコピーすれば良い)
$OBJECTIVE_FILE = "$DIR/=objective"; 	# objective file
$GUIDE_FILE    = "$DIR/=guide";		# the guide file of our Mailing List 
$HELP_FILE     = "$DIR/=help";		# the help file for useful commands
$DENY_FILE     = "$DIR/=deny";		# attention to illegal access
$FAIL_FILE     = "$DIR/=fail";		# attention to illegal access
$WELCOME_FILE  = "$DIR/=welcome";	# could be "$DIR/welcome"

# 気分的に log とは分離した
$MGET_LOGFILE  = "$DIR/log_mget";	# log file for mget routine

# ちょっとした変更(特に効果はない)
$Subject       = '(No Subject in original)';	# Subject field

# SMTP コネクションを張って HELO のときに localhost と名乗る
$Envelope{'macro:s'} = 'localhost';

# 配送レベルを bulk にする
$PRECEDENCE     = 'bulk';

# ローテーションするログの指定
@NEWSYSLOG_FILES = ("$MSEND_RC.bak", "$MEMBER_LIST.bak", "$ACTIVE_LIST.bak",
                    "${LOGFILE}_archive", "${LOGFILE}_matome");

# スキップする「X-何たら: 」フィールド
$SKIP_FIELDS = '|X-Nsubject|X-Confirm-Reading-To';

# スタートフック
$START_HOOK = q#
     # コントロールメールアドレスか?
    if ($CONTROL_ADDRESS && ($Envelope{'mode:chk'} =~ /$CONTROL_ADDRESS/i)) {
         # 新規登録か?
        if ($Envelope{'Body'} =~ /subscribe/io
              && $Envelope{'Body'} !~ /unsubscribe/io) {
            &use('utils');
            &AutoRegist(*Envelope);
            $DO_NOTHING = 1;
        }
        $Envelope{'mode:uip'} = 'on'
     # コマンドモードか?
     # (この ML では本体の方でコマンドメールを受け付けていないため)
    } elsif ($Envelope{'mode:uip'}) {
        &Logging("Unsupport Command Mail");
        &SendFile($From_address, 
                  "Unsupport Command Mail this Address $ML_FN", $FAIL_FILE);
        $DO_NOTHING = 1;
     # 普通に配送する
    } else {
        &Distribute;
        $DO_NOTHING = 1;
    }
#;

# SMTP 開始時のフック
$SMTP_OPEN_HOOK = q#
     # 元メールの To: フィールドを保存
    $Envelope{'h:To:'}       = $Envelope{'h:to:'}
          || $Envelope{'h:apparently-to:'} || "$MAIL_LIST $ML_FN";
     # Reply-To: を強制的に書き換える
    $Envelope{'h:Reply-To:'} = $Envelope{'h:reply-to:'} = $MAIL_LIST;
     # MIME なら Subject: をデコードする
    if ($USE_LIBMIME && $Envelope{'MIME'}) {
        &use('MIME');
        $Envelope{'h:Subject:'} = &DecodeMimeStrings($Envelope{'h:Subject:'});
    }
#;
 
# ヘッダに追加するフック
$HEADER_ADD_HOOK = q#
     # X-Nsubject: フィールドの処理
     # (この ML では X-Nsubject: も Subject: と同じ処理を受ける)
    if ($Envelope{'x-nsubject:'}) {
        if ($STRIP_BRACKETS) {
            $_ = $Envelope{'x-nsubject:'};
            local($r)  = 10;

            s/\[$BRACKET:\d+\]\s*//g;

            while (s/Re:\s*Re:\s*/Re: /gi && $r-- > 0) { ;}

            $Envelope{'x-nsubject:'} = $_;
        }
        if ($USE_LIBMIME && $Envelope{'MIME'}) {
            &use('MIME');
            $Envelope{'x-nsubject:'} =
                  &DecodeMimeStrings($Envelope{'x-nsubject:'});
        }
        $body .= "X-Nsubject: [$BRACKET:$ID] $Envelope{'x-nsubject:'}\n";
    }
#;
 
# libtraffic のフック(試験的設定)
$TRF_NAME_HOOK = q#
    $name =~ s/umura@solan\.chu/umura@nn.solan./oi;
#;

.~q

.S	改造事例: Reply-To == MLで必要な時にはReply-Toを設定するコマンド
=E.S	Example: set up Reply-To if required when Reply-To == $MAIL_LIST
.key	replyto コマンド

.if LANG == ENGLISH
*** NOT TRANSLATE THIS CHAPTER FOR AN ADDITIONAL BONUS PROGRAM ***
.fi
.if LANG == JAPANESE
fml 2.x ではこのままではうごきません。参考までに収録しています。

.q
From:    Yuao Tanigawa <yuao@infonia.or.jp>
X-ML-Name: fml-support
X-Mail-Count: 01249

メール本文の最初に、
	# replyto myaddr@mydomain 

と書いて、次の行から通常の文章を書いて投稿すれば、
Reply-To にそのアドレスをセットして記事を配送します。

  うちのMLでは、今まで、Reply-Toのアドレスを強制的にはMLの
アドレスに書き換えないようにしていたのですが、最近、いつも
Reply-Toに自分のアドレスを書いて投稿する人とかいて、Reply-To
にはアドレスを書かないようにと言うと、メールソフトの使い方
とかよく知らなくて、Reply-Toのアドレスの設定方法とかも知ら
ない人とかいたりして（学校とかでも周りの人とかも知らないら
しい）、どうしようもなくなったので、Reply-Toには、強制的に
MLのアドレスを書くようにしました。
  でも、必要なときにはReply-Toにアドレスが設定できると便利
なので、以下のようにして、# replyto コマンドを使えるように
してみました。

  config.phで、$SMTP_OPEN_HOOK には、

    $Envelope{'h:reply-to:'} = $Reply_to
            = $Envelope{'command:reply-to:'} || $MAIL_LIST;

として、$COMMAND_HOOK には、

    if(/replyto/io) {
        &Log("Set Reply-To: $Fld[2]");
        $e{'command:reply-to:'} = $Fld[2];
        $e{'Body'} =~ s/#\s*replyto\s+\S+\n//io;
        &Distribute;
        last GivenCommands;
    }

としました。ただし、この場合、$COMMAND_HOOK のクォートに、
`#'記号が使えないです。

.~q
.fi

でもコマンドで実装しなくてもええやんか？メール本文の先頭に
Reply-To: address があったらそれを設定する。

$START_HOOK = q!
    local($pat) = '.*\s*reply-to:\s*';
    local($s);
    if ($Envelope{'Body'} =~ /^$pat(\S+)/i) {
	&DEFINE_FIELD_FORCED('reply-to', $s=$1);
        &Log("reply-to: <$s>");
	$Envelope{'Body'} =~ s/^$pat\S+\n//io;
    }
!;

.S	From と 配送先が一致した時に、配送を止めたい(dynamical skip?)
=E.S	Not Deliver From: Field Address Of In-Coming Mail. 
.k	%SKIP
.k	$SKIP{アドレス}
.k	skip
.k	$START_HOOK

こういう処理を config.ph にかいてください。
=E
If you do not deliver an article when you yourself post it, set

$START_HOOK = q#
	$SKIP{'fukachan@phys.titech.ac.jp'} = 1
		if &AddressMatch($From_address, 'fukachan@phys.titech.ac.jp');
#;

こうすると fukachan@phys.titech.ac.jp あてのメールは skip します。
↑ここは actives とかに現れるものと同じにして下さい。

複数あるなら 全部を うえのフックに加えて下さい。


.S	fmlのコマンドが送れるページの例
=E.S	URL where you can send FML commands
.url	http://www.j-is.or.jp/fml/

.q
in fml-support: Count: 01585
From: Yuao Tanigawa <yuao@infonia.or.jp>
>   fmlのコマンドが送れるページを作ってみました。URLは
> http://www.j-is.or.jp/fml/ です。

…
.~q
=E
http://www.j-is.or.jp/fml/

.S	$ProcedureException{"bye", "ignore_list"} (将来もあるかは未定)
=E.S	$ProcedureException{"bye", "ignore_list"} 

   $ProcedureException{"bye", "ignore_list"} = $MEMBER_LIST;

とかすると、member list に operation したふりだけして何もしないという 
exception code いれたけど、裏技なのでdocumentにはかかず状態
このコードはSNMPなMIB的になってしまふのかしらん… あななやまし
=E
fake operation to a member list. I cannot ensure this code exists in
the future. This code enforces FML to ignore $MEMBER_LIST check in
"unsubscribe" operation.

.S	新しく『特定のファイルを送り返す』コマンドを作る
=E.S	make a new command what send back a file
.l	my-file-sendback-command
.xref	%Procedure-special-key

例: コマンド news でニュースというファイルを送り返す。
=E
E.g. "news" command is to send back $DIR/news file.

config.ph に
=E
In config.ph

%LocalProcedure = (
		    # help for usage of commands
		    'news',	'ProcFileSendBack',
		    '#news',	"$DIR/news",

		);

と書けば news という新しいコマンドのでき上がりです。

.S	メンバーを問わずファイル uja を送り返す例
=E.S	Send back $DIR/uja for anyone

例:
１	誰からのリクエストでもOK
２	本文にキーワード uja とかくこと
=E
1	requests from anyone are O.K.
2	keyword "uja" in the mail body to send back the file "uja".

$START_HOOK = q#
    $UJA_FILE = "$DIR/uja";

    if ($Envelope{'Body'} =~ /^[\n\s]*\#\s*uja/) {
	&SendFile($Envelope{'Addr2Reply:'}, "UJA $ML_FN", $UJA_FILE);
	&Log("UJA");
	$DO_NOTHING = 1;
    }
#;

.S	自動送り返しサーバの実装例
=E.S	Automatic Replay Server
.key	自動送り返しサーバの実装例

なんのことはない。ガイドファイルに適当なファイルを設定して、config.ph 
で強制的にガイド送り返ししかしないようにしてしまえば終わりですね。
=E
Please set a file to $GUIDE_FILE in config.ph and set up $START_HOOK
in the following hook:

ポイントは、“$START_HOOK にしかける”ってところです。

例:

1	適当なＭＬ(guide ML)を作成する (makefml newml guide)
2	普通に aliases を設定する
3	config.ph に $GUIDE_FILE (guide) の内容をを送り返すなら

	$START_HOOK = q#
		&SendFile($From_address, "Guide $ML_FN", $GUIDE_FILE);
		&Log("Guide request from $From_address");
		$DO_NOTHING = 1;
	#;

を guide ML の config.ph に付け加える。(おわり)

.S	たとえば、Received: のようなヘッダを残すには？
=E.S	Preserve Received: lines

FML 2.2 以降では
=E
After FML 2.2, set

    $SKIP_FIELDS  = 'Return-Receipt-To';

です。makefml configのメニューにあります(中身はこれ)。
＃2.1 では子文字じゃないとだめかも unshift(@HdrFieldsOrder, 'received');
＃この場合一行だけ Received ではなく received になってしまってちょっ
＃と情けないかも知れませんが…
＃RFC822 としては大文字小文字は関係ないので問題はない。カッコ悪いだけ;-)
=E
to preserve Received: fields in the header. A capital is important.

FML 2.1 ではたぶんこれでいいはず。
=E
FML 2.1 Example:

    unshift(@HdrFieldsOrder, 'received');
    $SKIP_FIELDS  = 'Return-Receipt-To';
 

.S	スプールにあるファイルをMIME逆変換する
=E.S	reconvert MIME characters in the spool
.k	スプールにあるファイルをMIME逆変換

lib/MIME/rmime を使って、/bin/sh なら
=E
use lib/MIME/rmime and runs shell scripts like 

	for file in *
	do
	   mv   $file     $file.org
	   perl rmime $file.org > $file
	done

くらいでＯＫでしょう
＃とりあえず .org つきのをバックアップに残すコードつき:-)

nkf -m でもいいだろう
=E
nkf -m must be also useful if nkf is not too old.

.S	mget でえた spool の下のファイルを mh 以外で読む時
=E.S	read not MH in the spool which is sent back by "mget".
.l	lib/Utilities/packmbox.pl
.k	packmbox.pl
 
lib/Utilities/packmbox.pl を使って、
=E
To create "mbox", you use lib/Utilities/packmbox.pl and runs 

	(cd spool; packmbox.pl ) > ~/mbox

として、mbox をつくれば、これにたいして、/bin/Mail なり Rmail なりを使
うことができて便利でしょう。

.S	配送するメールのMIME部分はDecodeしてしまいたい
=E.S	MIME-Decode MIME parts of mail to distribute
.xref	MIME-1

では、配送するメールのMIME部分はDecodeしてしまいたい時はどうするか？
例えば、fml.pl の sub GetFieldsFromHeaderで
=E
To MIME-Decode MIME parts of mail to distribute is to change

    if ($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
    }

を
=E
to

    if ($USE_LIBMIME && ($MailHeaders =~ /ISO\-2022\-JP/o)) {
        require 'libMIME.pl';
	$Summary_Subject = &DecodeMimeStrings($Summary_Subject);
	$MailBody = &DecodeMimeStrings($MailBody);
    }

で本文の任意の ISO-2022-JP で始まる部分だけをMIME decodeします

.S	認証する際のドメインのALIAS %DOMAIN_ALIASES
=E.S	%DOMAIN_ALIASES when authentication

認証する時には ujauja.or.jp  => ujauja.ne.jp に書き換えてTRYしてみる
=E
When FML authenticates From: address as a member or not, FML tries
both who@ujauja.or.jp and who@ujauja.ne.jp.

%DOMAIN_ALIASES = (
	'ujauja.or.jp', 'ujauja.ne.jp',
	);

＃ fml.pl 2.0.24.47 へのパッチの例
=E
An example of a patch for fml.pl 2.0.24.47

--- fml.pl.org	Fri Nov 21 08:11:10 1997
+++ fml.pl	Sat Nov 22 12:51:33 1997
@@ -571,6 +571,19 @@
     &Log("Gecos [$e{'macro:x'}]") if $debug;
     $e{'Addr2Reply:'}    = &Conv2mailbox($e{'h:reply-to:'},*e)||$From_address;
 
+    if (%DOMAIN_ALIASES) {
+       local($addr);
+	if (&MailListMemberP($From_address)) {
+	    ; # not rewrite
+	}
+	else {
+	    for (keys %DOMAIN_ALIASES) {
+		if ($From_address =~ /$_$/i) {
+                   $addr = $From_address;
+		    $addr =~ s/$_$/$DOMAIN_ALIASES{$_}/i;
+                   &MailListMemberP($addr) && ($From_address = $addr);
+		}
+	    }
+	}
+    }
+
     # To: $MAIL_LIST for readability;
     # &RewriteField(*e, 'Cc') unless $NOT_REWRITE_CC;
     if ($REWRITE_TO < 0) { 

.S	メーリングリストに参加可能なユーザのドメインを絞る
=E.S	Restrict domains of user which joins a mailing list

自動登録やリモートでの登録の際の制限については 
$REGISTRATION_ACCEPT_ADDR という変数で制限できます。
.xref auto-$REGISTRATION_ACCEPT_ADDR $REGISTRATION_ACCEPT_ADDR 
=E
$REGISTRATION_ACCEPT_ADDR can restrict registration to e.g. we permit
only persons in some domains can join this mailing list.
Please see it (this section may be of no use after this).
.xref auto-$REGISTRATION_ACCEPT_ADDR $REGISTRATION_ACCEPT_ADDR 

直接そういう変数があるわけじゃないですが、特殊な処理をするために HOOK 
がいっぱいあります。ありうる可能性をすべて変数にしてるといくらあっても
追いつかないので
=E
Several hooks are available to enable a lot of exceptional functions.
To permit only users on permit_domain.co.jp can join this list, you
can use $START_HOOK.

$START_HOOK = q#
   if ($From_address !~ /permit_domain\.co\.jp$/i) {
	&Mesg(*Envelope, 
	   "We permit user@*permit_domain.co.jp can join this list.");
	$DO_NOTHING = 1;
   }
#;

とかすれば、permit_domain.co.jp 以外のユーザには「permit_domainのゆー
ざだけしか参加できないよん」とメールが返って終りにできます。
$DO_NOTHING = 1 にすれば配送、自動登録などほとんど全ての処理が行なわれ
ません。これら全ての場合に共通の設定として利用できます。

	$DO_NOTHING = 1		メインの処理をしない
				配送、自動登録などほとんど全ての処理が
				行なわれないことになる
=E
	$DO_NOTHING = 1		do not run the main routine
				* distribute
				* automatic registration
				and other almost all functions

で、メインを呼ばなければ自動登録ルーチンも動きません。

   if ($From_address !~ /permit_domain\.co\.jp$/i) {

が From: が permit_domain 以外のユーザの表現です。後例えば
=E
is "addresses(From: address) which do not match permit_domain.co.jp".

   if ($Envelope{'h:sender:'} !~ /permit_domain\.co\.jp/i) {

なら Sender: が permit_domain.co.jp 以外の人は参加できないことになりま
す。(が Sender: なんて From: == Sender: なら普通つけないからよくない例
だな)。
=E
is "Sender: does not contains permit_domain.co.jp string".

.S	『自動登録』かつ『ポストできる人を制限する』設定例その２
=E.S	Example: "automatic registration" and "restrict members who can post"
.xref auto_asymmetric_regist

$REJECT_COMMAND_HANDLER には特殊な auto_asymmetric_regist という値があ
ります。これは配送と認証のリストを非対称に使う時に使います。
.xref auto_asymmetric_regist
=E
$REJECT_COMMAND_HANDLER can have a value 'auto_asymmetric_regist'. If
defined, FML uses delivery list controlled by automatic registration
and authentication list edited by hand (or makefml).
.xref auto_asymmetric_regist

これは別の考え方です。elena と elena-regist という２つのＭＬを作る。
=E
make "elena" and "elena-regist" ML.

	elena		投稿専用(手動登録)
	elena-regist	コマンド専用(自動登録に設定しておく)
=E
	elena		only for post (by hand or makefml)
	elena-regist	only for commands

アドレスを書くファイル

	elena-regist/members	MLの配送のリスト(自動登録)
	elena/members		MLの認証に使うリスト(手動登録)
				(MLに投稿できる人のリスト)
=E
	elena-regist/members	distribution list (automatic registration)
	elena/members		authentication list (by hand or makefml)

という２つのＭＬを作り設定する。登録用に elena-registを作り elena/cf 
の ACTIVE_LIST を /var/spool/ml/elena-regist/members にする。
=E
We use "elena-regist" for automatic registration to add
"elena-regist/members". "elena" ML uses plural distribution lists,
"elena/actives", "elena-regist/members".

   [作業の流れ]
=E
   [Example of flow]

	% makefml newml elena
	% makefml newml elena-regist
	% cd /var/spool/ml/elena-regist
	% cp include-ctl include

	*** /etc/aliases を適宜設定する
=E
	*** edit /etc/aliases

	% cd /var/spool/ml/elena
	% makefml edit elena cf

	*** edit cf ふぁいる (ACTIVE_LISTを設定する)
	elena/cf に
=E
	*** edit cf file to append "elena-regist/members" to @ACTIVE_LIST.
 
	ACTIVE_LIST	/var/spool/ml/elena-regist/members

	を加え config.ph を再生成する。
=E
	recreate config.ph

	% make config.ph
	% makefml add elena postable-member-address-1
	% makefml add elena postable-member-address-2
	.....

[Discussion]
elena が elena-regist/members を open する時に elena-regist をロックし
てない。が、大丈夫だらう:)
=E
[Discussion]
FML cannot lock elena-regist ML in default but works well I believe:)

.S	たわけたHTMLメール対策
=E.S	Cut off except the first multipart block

	$HTML_MAIL_DEFAULT_HANDLER = 'strip'; (default "")

ユーザからのメールでMIME/Multipartは中身を問わず一番最初のマルチパート
ブロックだけを残して後はぶったぎる。つまり中身が一緒のplainとHTML部分
を持つメールが来たらplain部分だけを残そうとする。でも常に正しい処理か
どうかは不明(大抵正しそうだが)。
=E
Cut off except the first multipart block if
1.	Content-Type: mime/multipart

	$HTML_MAIL_DEFAULT_HANDLER = 'strip'; (default strip)

値は strip か reject で、デフォールトはstrip。
strip はHTML部分を切りとってMLに流す。
rejectはMLには流さずHTMLメールは拒否すると送り主にメールを送る。
=E
where the value is 'strip' or 'reject'. If "strip", fml cuts off the
second and after multipart blocks and distributes the mail to ML. If
"reject", fml does not distribute it but tells "denies your html mail"
to the sender.

[互換性] $AGAINST_HTML_MAIL が古い変数名。この変数を設定していても互換
性の保証のために'strip'モードで動く。cf/MANFESTでは未定義。


.S	In-Reply-To: や References: をつけないREPLYメールを返すMUA対策
=E.S	Against replied mails without In-Reply-To: nor References:

	$AGAINST_MAIL_WITHOUT_REFERENCE = 1; (default 0)

.if LANG == JAPANESE
非常〜〜に後ろ向きなオプション
Eudora 等の In-Reply-To: References: をつけてくれないMUA対策
0. Subject: にTAGをつけることは前提(not default)
1. Message-ID: はＭＬ独自のものをつける
2. Subject: Re: [elena 00100] のようなTAGを解析する
ことでＭＬ全体のスレッドの一貫性を疑似的に強制する。
オリジナルのMessage-ID:はX-Original-Message-ID:に移動される
(2.2A#28はbugでつけてない, fixed in 2.2A#29)
.fi
.if LANG == ENGLISH
0. you require to set up 'fml puts the subject tag'.
1. add ML specific Message-ID: 
2. analyze the subject tag e.g. Subject: Re: [elena 00100]
In this mode, fml emulates Message-ID: always based on rule 2. 
Hence fml can ensure the consistency of ML threads against
some MUA's e.g. Eudora...
.fi

.S	Reply-To: を From: + $MAIL_LIST に設定する   
=E.S	Set Reply-To: be From: adress + $MAIL_LIST

$START_HOOK = q#
      &DEFINE_FIELD_FORCED("reply-to", "$From_address, $MAIL_LIST");
#;

You need to use a hook since From: address is dynamic variable, so
cannot define static setting in config.ph.

.S	Reply-To: を From: + $MAIL_LIST に設定する(2)   
=E.S	Set Reply-To: be From: adress + $MAIL_LIST (2)

fml-support: 06240

○ やりたいこと
=E
* What do you do ?

   if メンバー以外からの投稿
	Reply-To: From:のアドレス, メーリングリスト
   else
	Reply-To: メーリングリスト	
=E
   if post from not member
	Reply-To: From:'s address and mailing list
   else
	Reply-To: mailing list

○ config.phの書き換えだけでうまくいくのでしょうか？
=E
* How do you config?

変数のon/offという意味なら no です。
HOOKを書いていいなら yes です。

config.ph は単なるperlのプログラムです。fmlのあちこちには hook をはし
らせることができます。複雑な操作を全部変数にしているときりがないので
ある程度以上はHOOKでおこなうことで、設定ファイルをfml本体とは分けて保
守するというというデザインになっています。
＃Emacs みたいなもんだとおもってくれればOK
=E
config.ph is a perl script. The design of fml is so that you can write
hooks in config.ph if the configuration you want is not just switch
(on/off) of some variables. So you maintain configuration apart from
fml upgrade.

$START_HOOK =q%
   if (&MailListMemberP($From_address)) {
	&DEFINE_FIELD_FORCED("reply-to", $MAIL_LIST);
   }
   else {
	&DEFINE_FIELD_FORCED("reply-to", "$From_address, $MAIL_LIST");
   }
%;

.# $Id$
.# Copyright (C) 1993-1999 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1999 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
