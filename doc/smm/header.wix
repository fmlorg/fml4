.C	ヘッダのカスタマイズ
=E.C	Customize Fields of the Mail Header 
.l	header-custom


.S	ヘッダ・フィールドのフォーマット
.key	ヘッダ・フィールドのフォーマット
.key	@HdrFieldsOrder 
.xref	data-structure

fml はヘッダのフィールドの成形を行います。これは変数配列

	@HdrFieldsOrder 

に従い、その順番に並べかえます。凝る場合:-)は、 @HdrFieldsOrder を 
config.ph 等で定義しなおしてください。

デフォールト(on 97/06/14)は

    @HdrFieldsOrder =	# rfc822; fields = ...; Resent-* are ignored;
	('Return-Path', 'Date', 'Posted', 
	 'From', 'Reply-To', 'Subject', 'Sender', 
	 'To', 'Cc', 'Errors-To', 'Message-Id', 'In-Reply-To', 
	 'References', 'Keywords', 'Comments', 'Encrypted',
	 ':XMLNAME:', ':XMLCOUNT:', 'X-MLServer', 
	 'XRef', 'X-Stardate', 'X-ML-Info', ':body:', ':any:', 
	 'X-Authentication-Warning',
	 'Mime-Version', 'Content-Type', 'Content-Transfer-Encoding',
	 'Content-ID', 'Content-Description', # RFC2045
	 'Precedence', 'Lines');

のように定義されています。X-Authentication-Warning は
PICKY_HELO_CHECK (sendmail) 等で Security の Warning がつくので通すよ
うにしました。

@HdrFieldsOrder で定義された必要なフィールドのみをきりだしますが、
Received: と Return-Receipt-To: を除くすべてのフィールドを使うには

config.ph で

	$SUPERFLUOUS_HEADERS = 1;
or
	&DEFINE_MODE('through'); (config.ph の最後)

.k	$SUPERFLUOUS_HEADERS
.k	&DEFINE_MODE('through')

また @HdrFieldsOrder 中では

	:body:
	:any:
	:XMLNAME:
	:XMLCOUNT:

の特殊な変数が使われています。それぞれ

	:body:		$body を展開する場所
			$STMP_OPEN_HOOK や $HEAD_ADD_HOOK 等で独自ヘッダを
			$body で定義した場合等に使われる(Backward Compatible)

	:any:		$SUPERFLUOUS_HEADERS の時 @HdrFieldsOrder
			に明示的に現れないフィールドを展開する場所

	:XMLNAME:	$XMLNAME を展開する (X-ML-Name: フィールド)
.k	$XMLNAME

	:XMLCOUNT:	$XMLCOUNT を展開する (X-Mail-Count: フィールド)
.k	XMLCOUNT

のような特殊な目的に使われます。
これらは Backward Compatibility という趣が強い例外処理です。


.S	ヘッダフィールドの内容の強制
.l	&DEFINE_FIELD_FORCED
.k	--fh:field

SYNOPSIS:
	&DEFINE_FIELD_FORCED('field', "field-contents");

これは

	$Envelope{'fh:field:'} = "field-contents";
	--fh:field="field-contents" (コマンドライン)

と同じです。フィールドの内容を強制操作します。

例：
	&DEFINE_FIELD_FORCED('x-ml-info', "書きたいこと");

X-Ml-Info: の内容を"書きたいこと"に設定する。


.S	ヘッダフィールドをオリジナルのままにする
.l	&DEFINE_FIELD_ORIGINAL
.k	--oh:field

SYNOPSIS:
	&DEFINE_FIELD_ORIGINAL('field');

これは

	$Envelope{'oh:field:'};
	--oh:field  (コマンドライン)

と同じです。オリジナルの値にしておきたいフィールドを指定します。

例：
	&DEFINE_FIELD_ORIGINAL('to');
	&DEFINE_FIELD_ORIGINAL('cc');

To: Cc: フィールドをオリジナルのままにして配送する。


.S	ヘッダのフィールドを増やす or 減らす
.k	ヘッダのフィールドを増やす or 減らす

例えば、Return-Path: フィールドが要らないなら、@HdrFieldsOrder から
Return-Path の部分を除けばいいし、逆に Received: を付け加えるなら
上述のように @HdrFieldsOrder につけ足せば良いでしょう。
＃配列を直接いじるか、shift や unshift を使うと良いでしょう。

例えば Cc: フィールドを“つけない”なら

	&DELETE_FIELD('Cc');

注意: 96/11/2 $NOT_USE_CC を削除しました。@HdrFieldsOrder を直接いじる
か &DELETE_FIELD('Cc') を使って下さい。
.k	$NOT_USE_CC


.S	Received: ヘッダを残す
.k	Received: ヘッダを残す

歴史的に「サーバで受けたところまではOKなんだから、管理者が責任を持って、
ユーザにはMLサーバからユーザまでの配送分を見せれば十分だろう(余計なも
のは見せてもらわない方が幸せだろう)」という思想に基づき、デフォールト
では Received: はつけていません。またそれは too many hops を避けるため
にも有効です。

念のためログを取るためには

	&DEFINE_MODE("stdinlog");

というモード指定があります。これは入力を日毎にログファイル(var/logの下)
に残しておきます(溜る一方なので注意してね)。

なお Posted: (user が出した時間)と Date: (サーバが配送した時間) の違い
を見るとサーバにたどり着くまでの時間差(Network 的にどのくらい遠いか?)
がわかります。
.k Posted:(user が出した時間)とDate:(サーバが配送した時間)の差

Received: フィールドをつける時は

	unshift(@HdrFieldsOrder, 'Received');

とでもして、@HdrFieldsOrder につけ足せば良いでしょう。


.S	コマンドの結果やユーザへのメッセージのヘッダのカスタマイズ
.k	コマンドのREPLYメールのヘッダ
.xref	data-structure
.k	$Envelope{'GH:field:'} 

コマンドの結果やユーザへのメッセージのメールヘッダは

	$Envelope{'GH:field:'} 

で変更できます。GH というキーワードなのは SMTP Library の 
GenerateHeader() という関数内で使われるためです。
.k	GenerateHeader()
.k	&GenerateHeader()

なお、ヘッダの並び順は @HdrFieldsOrder の順番です。

例：

コマンドの結果のメールの From: を特定のアドレス(および signatureつき等)
に変えたいなら

	$Envelope{'GH:From:'} = "uja@aoi.chan.panic (AOICHAN PANIC)";

とでもすればよいわけです。通常は From: は $MAINTAINER です。

From: $MAINTAINER に限っては $MAINTAINER_SIGNATURE で signature をつけ
ることはできますが、まぁ形を気にするなら↑の方法で直接定義した方がより
よいでしょう。
.k	$MAINTAINER
.k	$MAINTAINER_SIGNATURE

Dynamic に補正する必要がある場合は

	$REPORT_HEADER_CONFIG_HOOK
.xref	$REPORT_HEADER_CONFIG_HOOK

で定義するとよい。


.S	コマンドメールの結果のメールの Reply-To: を変更する
.k	$FORCE_COMMAND_REPLY_TO
.k	$Envelope{'GH:Reply-To:'}

	$Envelope{'GH:Reply-To:'} = "Your Reply-To Address";

Backward compatibility で残っている変数が

	$FORCE_COMMAND_REPLY_TO = "address-you-want-to-use";

です。実際には $Envelope{'GH:Reply-To:'} への代入と全く同じです。


.S	Subject: を (Elena 100) とかの任意の形に成形する
.l	$SUBJECT_TAG_TYPE
.k	$SUBJECT_TAG_TYPE
.l	$SUBJECT_FREE_FORM
.k	$SUBJECT_FREE_FORM

fml デフォールトは「Subject: はいじらない。本来メールソフトが好きな形
にフォーマットするものをサーバ側でフォーマットを押付けるべきではない」
「有効に使いもしないのに Subject:の本体の情報を減らすタグはつけるべき
ではない」というものです。
＃注意：この問題は本来はメールインターフェイスプログラムが賢いか？
＃否か？という問題に還元されるべきものです。

Subject: にタグをつける時は$SUBJECT_TAG_TYPE という変数にタイプを設定
します。ちなみに makefml config で設定できます。

  $SUBJECT_TAG_TYPE		Subject: での形
  ____________________________________________________________

	(:)			Subject: (Elena:100)
	[:]			Subject: [Elena:100]
	( )			Subject: (Elena 100)
	[ ]			Subject: [Elena 100]
	[,]			Subject: [Elena,100]
	(,)			Subject: (Elena,100)


[解説]
設定すると config.ph の中では次のような形に設定されています

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '(';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ')';
	$SUBJECT_FREE_FORM_REGEXP = "\\($BRACKET \\d+\\)";

と定義すると (Elena 100) の形になり、Reply のメールの (Elena 99) をは
ずし新しい (Elena 100) をつけるようになります。

他の例： Subject: [Elena 100]

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '[';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ']';
	$SUBJECT_FREE_FORM_REGEXP = "\\[$BRACKET \\d+\\]";

なおこのやりかたは複雑なので次の節のような簡易インターフェイスが用意さ
れています。

[捕捉]
$CFVersion 3 以前にあった $SUBJECT_HML_FORM は config.ph が CFVersion
3 以前のものだと判定された場合は内部で$SUBJECT_TAG_TYPE = "[:]"; へ変
換されます。現在の設定ではすでに無効な変数です。


.S	Subject: の成形 ([Elena:ID] フォーマットを抜く)
.key	Subjectから[Elena:ID]を抜く
.k	[Elena:ID]を抜く
.key	$STRIP_BRACKETS

ほとんど歴史的意味しかないので使うことはないでしょう

	$STRIP_BRACKETS = 1;

とすると Subjectから [ML:fukachan] みたいな部分をカットする。これは 
Subject: [Elena:ID] の形で配送するための前処理です。


.S	TAGの [Elena:00001] の五桁の数字をＮ桁に変更
.k	$HML_FORM_LONG_ID

	$SUBJECT_FORM_LONG_ID
.k	$SUBJECT_FORM_LONG_ID

で、５桁がデフォールトだが $SUBJECT_FORM_LONG_ID 桁にする。
$SUBJECT_FREE_FORM 使用時に有効な変数。

注意:
かつて

	５桁がデフォールトだが $HML_FORM_LONG_ID 桁にする。
	$SUBJECT_HML_FORM = 1; の時にのみ有効。

という設定もありました。現在では $SUBJECT_FORM_LONG_ID を使うべき。
$CFVersion 3 以前にあった $HML_FORM_LONG_ID は config.ph が CFVersion
3 以前のものだと判定された場合は内部で $SUBJECT_FREE_FORM_LONG_ID; へ
代入変換されます。現在の設定ではすでに無効な変数です。



.S	TAGの [Elena:00001] の 0 パディングをなくす
.k	[Elena:ID]の0パディングをしない

	$SUBJECT_FORM_LONG_ID = -1;
.k	$SUBJECT_FORM_LONG_ID

[注意] 昔は

	$HML_FORM_LONG_ID = -1;
.k	$HML_FORM_LONG_ID

も有効でしたが、今はありません。


.S	オリジナルの Message-ID を配送に使う
.key	Message-ID
.l	Uniq_Identifier_of_Message-ID
.key	$USE_ORIGINAL_MESSAGE_ID

	$USE_ORIGINAL_MESSAGE_ID = 1; 

とするとオリジナルの Message-ID を保存してヘッダにつけます。

	&DEFINE_FIELD_ORIGINAL('Message-Id');

と同じです(ヘッダフィールドを扱う関数が汎用でなかった時代の変数の名残)。
オリジナルを使うべきか？サーバでつけるべきか？どっちがいいかという議論
ですが

in fml-support ML's Count: 02687
.q
>| デフォールトは fml がつけます。それはオリジナルを通すより、強制的につ
>| けるとより無限 loop 検出がしやすくなるためです。

っていう doc/op の論理は正しいかな？

original で妙な pattern の Message-ID を使われてて、ちゃんと detect で
きないとかあると嫌ね＃そうそうあるとはおもえないのだが

という可能性もある一方 ＃ばぐってるperlとかね〜

fml 自体がつける場合、キャッシュテーブルの有効な大きさが半分になってし
まふというのがあるので、オリジナルを使う方が有効な大きさは増える。
ループが発生する場合にどのくらい未来まで世界線をたどればいいのかは不明
なので統計的な議論はできない＃マシンスペックやネットワーク構成に依存

自分が自分に送るとかそういうのなら一瞬でループにはいるのでまず間違いな
く detect するはずという場合が多いという仮定が正しいならどちらのやり方
でも大差はない

という論理になるような気がする。
.~q


.S	ML 独自の Message-ID フォーマット
.k	Message-ID の独自フォーマット
.xref	$HEADER_ADD_HOOK

これは

	&DEFINE_FIELD_FORCED('Message-Id', "適当なID");

で解決ですが。HOOKを使うやり方も書いておきます。

Message-ID: uja@aoi.chan.panic とするなら

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: uja@aoi.chan.panic\n";
#;

と config.ph にでも書けば $body の内容が @HdrFieldsOrder 中の :body: 
で展開されます。そのためHOOKを使うなら @HdrFieldsOrder 中の :body: を
切ってはいけません。

他の例：
Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.jp>

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: ".
	sprintf("<%4d%02d%02d.%05d.%s>\n", 1900 + $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.jp");
#;


.S	宇宙歴 (外国TVシリーズMLで使ってます:-)
.l	startrek
.k	STAR TREK
.k	StarDate
.k	$APPEND_STARDATE

.url	http://www.sapporo.iij.ad.jp/staff/fukachan/href/Startrek/

config.ph で

	$APPEND_STARDATE = 1; 

とすると宇宙歴がつきます:-)

	Date: Fri, 19 May 95 22:31:09  JST
	From: "No.6 Fukachan" <fukachan@phys.titech.ac.jp>
	Subject: Re: Nantonaku Leonard Nimoy 
	To: enterprise@phys.titech.ac.jp (Foreign TV Series ML)
	X-ML-Name: Prisoner
	X-Stardate: [-31]5697.8164

	…本文略…

みたいになります。スタートレックFAQ に C program がのっていますが、
libstardate.pl はその perl 版です。
.k	libstardate.pl


.S	一つのメーリングリストに複数の投稿用アドレス
.key	複数の投稿用アドレス

何の意味があるのかは聞かないでください(笑)

例：
Elena@phys.titech.ac.jp というＭＬで

	Elena@phys.titech.ac.jp	と Anna@phys.titech.ac.jp

の両方を投稿可能にする。設定したいアドレスを全部配列の中にずらずら書い
て下さい。

config.ph に次のような設定をしてください
.k	@MAIL_LIST_ALIASES
.k	@PLAY_TO
.l	@MAIL_LIST_ALIASES

  @MAIL_LIST_ALIASES = ('Elena@phys.titech.ac.jp', 
			'Anna@phys.titech.ac.jp'
		    );

なおHOOKの設定はもう必要ありません。&FixHeaders の中で書き換えは行なわ
れます。

その複数のアドレスを(ループチェックに使うために) @MAIL_LIST_ALIASES が
必要です。配列の先頭がオリジナルのアドレス(== $MAIL_LIST)です。

こうすると Elena になげても Anna に投げても同じＭＬと見なし、

	$MAIL_LIST 

をその投げた方のアドレスに設定します。その副作用として

	To: と Reply-To:

がそのアドレスになります。

注意： @PLAY_TO, $Playing_to は昔の変数名です。この変数は 
compatibility のため自動的に @MAIL_LIST_ALIASES に代入されます。
＃ libcompat.pl にBackward compatibility のためのコードがありますが…
.k	$Playing_to


.S	X-ML-Info: の内容を指定する
.k	$X_ML_INFO_MESSAGE
.k	&DEFINE_FIELD_FORCED('x-ml-info', "書きたいこと");

	&DEFINE_FIELD_FORCED('x-ml-info', "書きたいこと");

で強制的に指定すれば良いでしょう。一応昔風に変数

	$X_ML_INFO_MESSAGE

で指定した内容を優先して X-ML-Info: につけて配送できるようにもなってい
ます。そうでない場合はモードによって適当に作られた user friendly な内
容が付け加えられます。



.S	To: の Rewriting 処理
.l	$NOT_REWRITE_TO
.l	$NOT_REWRITE_CC

可読性のため、To: フィールドは $MAIL_LIST が展開され、常にＭＬのアドレ
スが出るようになっています。
original header を通すという設定の場合はそうはならずにオリジナルのままです。

ですが、apparent-to: になっていて、見辛いとか一体どうしてこのＭＬに来
たメールなの？とかよくわからないメールも多いので、それよりは可読性を重
視して、こういう実装になっています。

現在は
	1 To: に   $MAIL_LIST が含まれているなら、そのまま
	2 To: には $MAIL_LIST が含まれていない場合は

	  To: $MAIL_LIST,
		元の To: 

となるように付け加えて、情報を保存しておく

To: Cc: というのは人間がメールを書く時の単なる便宜上のもので、配送手段
の SMTP としてはなんら区別はしていません。ですから、情報を落さず、To: 
は可読性のために $MAIL_LIST としています。

[蛇足] なお、To: Cc: の中に重複して現れるアドレスには普通それらを一つ
にまとめて一通分のみが配送されます。だから複数あっても気にしないでね

＃注意：なお、$NOT_REWRITE_CC は obsolete にしました


.S	NIFTY対策をするか?(参加者にNIFの人もいる, OBSOLETE?)
.label	NIFTY
.label	$AGAINST_NIFTY
.label	against-nifty
.k	$USE_ERRORS_TO

注意: もう必要ないらしい

	$USE_ERRORS_TO = 1;

とすると Errors-To: をつけます。$AGAINST_NIFTY も同じ意味でしたが 
$CFVersion 3 ではなくなりました。

NIFTY は非常識にも、Errors-to という時代おくれの部分しかみてないので;_;、
config.ph あたりで

	$AGAINST_NIFTY = 1

とするとメール本文に

	Errors-To: $MAINTAINER
.k	Errors-To:

がつきます。これで NIFTY からのエラーメールが $MAINTAINER に返るように
なってくれます。後向きな解決法ですが;_;。
前向きなのは、みんなで文句をいって直させることです。
＃でも、僕はアカウントをもってない;_;。アカウントを持ってる人が一年く
らいいいつづけないとだめなんだろうなぁ（はぁ）

なお、$ERRORS_TO で Errors-To: の部分は $MAINTAINER から変更できます。


.S	メールの最後に付加情報をつける設定

注意: 基本的にコマンドの話です。

	$PREAMBLE_MAILBODY	（前）
	$TRAILER_MAILBODY	（後）
	を本文の前後に必ず付けます。

つまり、
	e.g. HELP コマンドにたいして、

	$PREAMBLE_MAILBODY	（前）
	HELPファイル本文
	$TRAILER_MAILBODY	（後）

のようになります。昔のやり方は

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= $PREAMBLE_BODY.$e{'Body'}; #;
   ＃注：普通のＭＬのメールに $PREAMBLE_BODY がついて配送

ですが今は汎用性のためSMTPライブラリ中で処理されます。

これと同様にすれば、本文にメールカウントを埋め込むことも可能になります。

注意： 配送されるメール本体につける方法。これは倫理的な問題があるので
変数などで容易にできるように実装されていません。

   $SMTP_OPEN_HOOK = q# $e{'Body'} .= "Mail Count: $ID\n\n".$e{'Body'}; #;
   注意：このHOOKが走る関数中では %e == %Envelope 

例： メール本文にヘルプを常につけたす
   $SMTP_OPEN_HOOK = 
       q% $e{'Body'} .= 
       "\nTo need help, please send '# help' to elena-ctl\@fml.org."; %;

.# $Id$
.# Copyright (C) 1993-1998 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1998 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
