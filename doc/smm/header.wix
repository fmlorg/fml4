.C	ヘッダのカスタマイズ
.l	header-customizing
.l	header-custom


.S	ヘッダのフィールドの順番(フォーマット)
.key	ヘッダのフィールドの順番(フォーマット)
.key	@HdrFieldsOrder 
.key	--through
.xref	data-structure

fml はヘッダのフィールドの成形を行います。これは変数配列

	@HdrFieldsOrder 

に従い、その順番に並べかえます。凝る場合:-)は、 @HdrFieldsOrder を 
config.ph 等で定義しなおしてください。

デフォールトは

    @HdrFieldsOrder = 
	('Return-Path', 'Date', 'From', 'Subject', 'Sender',
	 'To', 'Reply-To', 'Errors-To', 'Cc', 'Posted',
	 ':body:', 'Message-Id', ':any:', ':XMLNAME:', 
	 ':XMLCOUNT:', 'X-MLServer',
	 'Mime-Version', 'Content-Type', 'Content-Transfer-Encoding',
	 'XRef', 'X-Stardate', 'X-ML-Info', 
	 'References', 'In-Reply-To', 'Precedence', 'Lines');

のように定義されています。

@HdrFieldsOrder で定義された必要なフィールドのみをきりだしますが、
Received: と Return-Receipt-To: を除くすべてのフィールドを使うには

config.ph で

	$SUPERFLUOUS_HEADERS = 1;
	&DEFINE_MODE('through');

とするかコマンドラインで --through と定義してください。
.k	$SUPERFLUOUS_HEADERS
.k	DEFINE_MODE('through')
.k	&DEFINE_MODE('through')

例：
	fml.pl $DIR --through 


また @HdrFieldsOrder 中では

	:body:
	:any:
	:XMLNAME:
	:XMLCOUNT:

の特殊な変数が使われています。それぞれ

	:body:		$body を展開する場所
			$STMP_OPEN_HOOK や $HEAD_ADD_HOOK 等で独自ヘッダを
			$body で定義した場合等に使われる(Backward Compatible)

	:any:		$SUPERFLUOUS_HEADERS の時 @HdrFieldsOrder
			に明示的に現れないフィールドを展開する場所

	:XMLNAME:	$XMLNAME を展開する (X-ML-Name: フィールド)
.k	$XMLNAME

	:XMLCOUNT:	$XMLCOUNT を展開する (X-Mail-Count: フィールド)
.k	XMLCOUNT

のような特殊な目的に使われます。
これらは Backward Compatibility という趣が強い例外処理です。


.S	ヘッダフィールドの内容の強制
.k	&DEFINE_FIELD_FORCED
.k	--fh:field

SYNOPSIS:
	&DEFINE_FIELD_FORCED('field') = "field-contents";

これは

	$Envelope{'fh:field:'} = "field-contents";
	--fh:field="field-contents" (コマンドライン)

と同じです。フィールドの内容を強制操作します。

例：
	&DEFINE_FIELD_FORCED('x-ml-info') = "書きたいこと";

X-Ml-Info: の内容を"書きたいこと"に設定する。


.S	ヘッダフィールドをオリジナルのままにする
.k	&DEFINE_FIELD_ORIGINAL
.k	--oh:field


SYNOPSIS:
	&DEFINE_FIELD_ORIGINAL('field');

これは

	$Envelope{'oh:field:'};
	--oh:field  (コマンドライン)

と同じです。オリジナルの値にしておきたいフィールドを指定します。

例：
	&DEFINE_FIELD_ORIGINAL('to');
	&DEFINE_FIELD_ORIGINAL('cc');

To: Cc: フィールドをオリジナルのままにして配送する。


.S	Received: もヘッダにつける
.k	Received: もヘッダにつける

歴史的に「サーバで受けたところまではＯＫなんだから、管理者が責任を持っ
て、ユーザにはＭＬサーバからユーザまでの配送分を見せれば十分だろう(余
計なものは見せてもらわない方が幸せだろう)」という思想に基づき、デフォー
ルトでは Received: はつけていません。

なお、Posted: (user が出した時間)と Date: (サーバが配送した時間) の違
いを見るとサーバにたどり着くまでの時間差(Network 的にどのくらい遠いか？)
がわかります。
.k	Posted:(user が出した時間)とDate:(サーバが配送した時間)の差

Received: フィールドをつける時は

	unshift(@HdrFieldsOrder, 'Received');

とでもして、@HdrFieldsOrder につけ足せば良いでしょう。


.S	ヘッダのフィールドを増やす or 減らす
.k	ヘッダのフィールドを増やす or 減らす

例えば、Return-Path: フィールドが要らないなら、@HdrFieldsOrder から
Return-Path の部分を除けばいいし、逆に Received: を付け加えるなら
上述のように @HdrFieldsOrder につけ足せば良いでしょう。
＃配列を直接いじるか、shift や unshift を使うと良いでしょう。


.S	Cc: フィールドを“つけない”
.k	$NOT_USE_CC

96/11/2 $NOT_USE_CC を削除しました。@HdrFieldsOrder を直接いじるか 
&DELETE_FIELD('Cc') を使って下さい。

今では単に @HdrFieldsOrder から Cc を落せばＯＫです。
デフォールトではつけますので、切り落とすときは $NOT_USE_CC = 1; でも落
せます。


.S	コマンドの結果やユーザへのメッセージのヘッダをカスタマイズする
.k	コマンドの結果やユーザへのメッセージのヘッダをカスタマイズ
.xref	data-structure
.k	$Envelope{'GH:field:'} 

コマンドの結果やユーザへのメッセージのメールヘッダは

	$Envelope{'GH:field:'} 

で変更できます。GH というキーワードなのは SMTP Library の 
GenerateHeader() という関数内で使われるためです。
.k	GenerateHeader()
.k	&GenerateHeader()

なお、ヘッダの並び順は @HdrFieldsOrder の順番です。

例：

コマンドの結果のメールの From: を特定のアドレス(および signatureつき等)
に変えたいなら

	$Envelope{'GH:From:'} = "uja@aoi.chan.panic (AOICHAN PANIC)";

とでもすればよいわけです。通常は From: は $MAINTAINER です。

From: $MAINTAINER に限っては $MAINTAINER_SIGNATURE で signature をつけ
ることはできますが、まぁ形を気にするなら↑の方法で直接定義した方がより
よいでしょう。
.k	$MAINTAINER
.k	$MAINTAINER_SIGNATURE


.S	Subject: を (Elena 100) とかの任意の形に成形する
.l	$SUBJECT_FREE_FORM

	fml 	Subject: はいじらない
	hml	Subject: [Elena:100]

なんですが、他のフォーマットを使うために 
例えば、

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '(';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ')';
	$SUBJECT_FREE_FORM_REGEXP = "\\($BRACKET \\d+\\)";

と定義すると (Elena 100) の形になり、Reply のメールの (Elena 99) をは
ずし新しい (Elena 100) をつけるようになります。

他の例： Subject: [Elena 100]

	$SUBJECT_FREE_FORM = 1;
	$BEGIN_BRACKET     = '[';
	$BRACKET           = 'Elena';
	$BRACKET_SEPARATOR = ' ';
	$END_BRACKET       = ']';
	$SUBJECT_FREE_FORM_REGEXP = "\\[$BRACKET \\d+\\]";

なお、このやりかたは複雑なので次の節のような簡易インターフェイスが用意
されています。


.S	SubjectのTAGの定義 &DEFINE_SUBJECT_TAG("(:)");
.l	&DEFINE_SUBJECT_TAG
.k	&DEFINE_SUBJECT_TAG
.xref	--mode

Subject のTAGを定義する。fml のデフォールトは「有効に使いもしないのに、
Subject:の本体の情報を減らすタグはつけるべきではない」です。
＃注意：この問題は本来はメールインターフェイスプログラムが賢いか？
＃否か？という問題に還元されるべきものです。


	(:)

		Subject: (Elena:100)

	[:]

		Subject: [Elena:100]	(HMLタイプ)

	( )

		Subject: (Elena:100)

	[ ]

		Subject: [Elena:100]

	[,]

		Subject: [Elena,100]

	(,)

		Subject: (Elena,100)


なお、モード指定中でTAGを定義している場合は後で評価された内容が優先さ
れるので注意。例： HML Emulation mode  (--hml)

これらのTAGは $SUBJECT_FREE_FORM の変数を定義すれば自由にカスタマイズ
できるのですが、それをあらかじめ定義しておくことで便利なユーザインター
フェイスになるようにしたものです。

config.ph では

	&DEFINE_SUBJECT_TAG("(:)");

コマンドラインでは 

	--tag="(:)"
	--subjecttag="(:)"

のように呼び出してあげて下さい。
	


.S	hml 1.6 の Subject フォーマット
.S	Subject: [Elena:ID] という形にする
.key	$SUBJECT_HML_FORM
.key	$BRACKET
.key	hml形のSubject

オリジナルの hml 1.6 は
……
From:	エレナさんＭＬ
Subject: [3:fukachan] フリーキックはやっぱりエレナさんが最高さ
……

こんな形のヘッダですね。で、私が嫌いなので:-)、
＃無駄に多いヘッダは嫌いなんですよぉ。To: 見りゃわかるのにX-ML-Nameと
＃か…X-ML-Count は違う種類の情報（Reference）だからいいんですが…

デフォールトは[]ものはなしで、オプショナルで次のようなSubject形になる
ようにしました。

	$SUBJECT_HML_FORM = 1;
	$BRACKET	  = 'Elena';

形にしようと思います。

しかし Fromの 処理が hml 1.6 と違うので
＃From が ML名 じゃなくて ユーザー名 を使っている

最近よく見られる形の [MLの名前:articleのID] という形を採用しました。
つまり（今の場合だと）

	Subject: [Elena:ID] サブジェクト

の形になります。この場合

	$SUBJECT_HML_FORM = 1; なら $STRIP_BRACKETS = 1;

にしてます（config.phの中で）
＃必要な処理なので自動的に設定しています。


.S	TAGの [Elena:00001] の五桁の数字をＮ桁に変更
.k	$HML_FORM_LONG_ID

５桁がデフォールトだが $HML_FORM_LONG_ID 桁にする。
$SUBJECT_HML_FORM = 1; の時にのみ有効。

一般には

	$SUBJECT_FORM_LONG_ID
.k	$SUBJECT_FORM_LONG_ID

で、５桁がデフォールトだが $SUBJECT_FORM_LONG_ID 桁にする。
$SUBJECT_FREE_FORM 使用時に有効な変数。


.S	オリジナルの Message-ID
.key	Message-ID
.key	Uniq_Identifier_of_Message-ID
.key	$USE_ORIGINAL_MESSAGE_ID

$USE_ORIGINAL_MESSAGE_ID = 1; とすると、オリジナルの Message-ID を保存
してヘッダにつけます。

デフォールトは fml がつけます。それはオリジナルを通すより、強制的につ
けるとより無限 loop 検出がしやすくなるためです。


.S	Message-IDを個人の趣味でカスタム化する
.key	Message-IDのカスタム化
.key	$HEADER_ADD_HOOK

Message-ID: uja@aoi.chan.panic とするなら

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: uja@aoi.chan.panic\n";
#;

と、config.ph にでも書けば $body の内容が @HdrFieldsOrder 中の :body: 
で展開されます。そのためHOOKを使うなら :body: を切ってはいけません。


他の例：
Message-ID: <19950518.01905.Elena.Lolobrigita@Baycity.jp>

$HEADER_ADD_HOOK = q#
   $body .= "Message-ID: ".
	sprintf("<19%2d%02d%02d.%05d.%s>\n", $year, $mon + 1, $mday, $ID, 
	"Elena.Lolobrigita@Baycity.jp");
#;


.S	宇宙歴(外国TVシリーズMLで使ってます:-)
.k	StarDate
.k	$APPEND_STARDATE

   http://www.sapporo.iij.ad.jp/staff/fukachan/href/Startrek/

config.ph で

	$APPEND_STARDATE = 1; 

とすると宇宙歴がつきます:-)

	Date: Fri, 19 May 95 22:31:09  JST
	From: "No.6 Fukachan" <fukachan@phys.titech.ac.jp>
	Subject: Re: Nantonaku Leonard Nimoy 
	To: enterprise@phys.titech.ac.jp (Foreign TV Series ML)
	X-ML-Name: Prisoner
	X-Stardate: [-31]5697.8164

	…本文略…

みたいになります。スタートレックFAQに C progarm がのっていますが、
libstardate.pl はその perl 版です。
.k	libstardate.pl
.k	スタートレックFAQ


.S	メールヘッダとMIME
.l	メールヘッダとMIME
.l	MIME-in-Header
.key	$PREVENT_MIME

デフォールトでは MIME 関係の次の３つのフィールドを通しています。
＃ @HdrFieldsOrder で定められています。

	MIME-Version:
	Content-Type:
	Content-Transfer-Encoding:

	$PREVENT_MIME = 1; 

MIME反対派の方は $PREVENT_MIME をセットしてください。
そうするとこれらのフィールドを切り落として配送します。

@HdrFieldsOrder をいじって、上のフィールドをけずっても同じことができま
す。


.S	ヘッダと MIME Decoding してログをとること
.key	MIME
.label	MIME-header
.l	MIME-1
.key	$USE_MIME
.xref	MIME-hack

本来 MIME をクライアントプログラムが処理すればいいことなので、サーバと
しては素通しでいいはずです。が、ログを日本語変換してから保存したいとい
う要求があるらしいので、これらの機能が実装されています。


まず、各種の MIME Decoding を行うためには、

	$USE_MIME	= 1;

を定義します。これがないと必要なライブラリをロードしません。


.S	summary に書くsubjectをMIME decodeをしてから書き込む
.k	summary に書くsubjectをMIME decodeをしてから書き込む

	$USE_MIME	= 1;  

だけでこれは実行します。

例：
	……
	Subject: Re: TELEPHONE 
	   =?ISO-2022-JP?B?GyRCJD0kcyRKJCEhQRsoQg==?=

	……
というメールが来たとすると、summary ファイルには

	94/04/03 20:47:47 [1:fukachan@phys.t] Re: TELEPHONE そんなぁ〜

と記録されます

注意：subject をちょんぎったりはしませんが、一行にしてからdecodeして全
部書いてます。summaryは１行１メールがわかりやすくていいでしょ？


.S	記事をMIME Decoding してから保存する場合
.k	$MIME_DECODED_ARTICLE

	$MIME_DECODED_ARTICLE          = 1;

と定義して下さい。$DIR/spool/数字 というファイルにＭＬの記事の保存する
時に日本語へ逆変換した内容を書き込みます。


.S	MIME Decoding を行なうに関するメモ…
.l	MIME-Memo

ISO-2022-JP の文字がない限りは require しません(ま、たいして軽くはなら
んが…)。

.key RFC1522
RFC1522	2. Syntax of encoded-words

   encoded-word = "=?" charset "?" encoding "?" encoded-text "?="
   charset = token    ; see section 3
   encoding = token   ; see section 4
   token = 1*<Any CHAR except SPACE, CTLs, and especials>


.S	MIME処理に関するカスタマイズ変数
.k	MIME処理に関するカスタマイズ変数
.label	MIME-customizing
.label	MIME-2
.key	$MIME_VERSION
.key	$MIME_CONTENT_TYPE
.key	$MIME_MULTIPART_BOUNDARY
.key	$MIME_MULTIPART_PREAMBLE
.key	$MIME_MULTIPART_TRAILER

以下はＭＬ本来の配送には普通関係ないですね。

右辺はデフォールトの値（Built-in）です。
ファイルの取り寄せ等のモードにMIME関係もありますが、その時に使われてい
ます。

   Mime-Version:
   Content-Type:


	$MIME_VERSION = '1.0';
	$MIME_CONTENT_TYPE = 'multipart/mixed;';

以下は MIME/Multipart で使う変数です。

	$MIME_MULTIPART_BOUNDARY = "--Thu_18_May_95_02:36:26--"

な形で日付を設定します。

そのあと、これら↓の変数を設定してます。

	$MIME_MULTIPART_DELIMITER  = $MIME_MULTIPART_BOUNDARY;
	$MIME_MULTIPART_DELIMITER .= "\nContent-Type: message/rfc822\n";
	$MIME_MULTIPART_CLOSE_DELIMITER = $MIME_MULTIPART_BOUNDARY;

くぎり

	$MIME_MULTIPART_BOUNDARY = "--日付--"

本文の前口上

	$MIME_MULTIPART_PREAMBLE = なし

本文の後につく部分

	$MIME_MULTIPART_TRAILER = なし


.S	Subject: の成形 ([Elena:ID] を抜く)
.key	Subjectから[Elena:ID]を抜く
.key	$STRIP_BRACKETS

	$STRIP_BRACKETS = 1;

とすると、Subjectから [ML:fukachan] みたいな部分をカットする。
これは Subject: [Elena:ID] の形で配送するための前処理です。


.S	1つのMLに複数の投稿用アドレスとヘッダ
.key	1つのMLに複数の投稿用アドレスとヘッダ

何の意味があるのかは聞かないでください(笑)

例：
Elena@phys.titech.ac.jp というＭＬで

	Elena@phys.titech.ac.jp	と Anna@phys.titech.ac.jp

の両方を投稿可能にする(いくつあっても全部配列にして ずらずらかけば同じ)

config.ph に次のような設定をしてください
.k	@PLAY_TO
.l	@PLAY_TO

	@PLAY_TO = (	'Elena@phys.titech.ac.jp', 
			'Anna@phys.titech.ac.jp'
		    );

そして、次のフックを仕掛けます。

# Here is a playing of "To addresses change"; string to eval
$SMTP_OPEN_HOOK .= q#
    local($a);
    foreach (@PLAY_TO) {
        $a = (split(/\@/, $_))[0];
        if ($Envelope{"to:"} =~ /$a/) {
            $MAIL_LIST = $_;
        }
    }
#;

その複数のアドレスを(ループチェックに使うために) @PLAY_TO が必要です。
配列の先頭がオリジナルのアドレス(==$MAIL_LIST)です。

こうすると Elena になげても Anna に投げても どっちでもＯＫで、
To: と Reply-To:を変更します。
＃名前の変更 in 1.5delta. Playing_to  -> SMTP_OPEN_HOOK
.k	$Playing_to

注意： Playing_to は削除しました。
libcompat.pl にBackward compatibility のためのコードがあります。


.S	コマンドメールの結果のメールの Reply-To: を変更する
.k	$FORCE_COMMAND_REPLY_TO
.k	$Envelope{'GH:Reply-To:'}

	$Envelope{'GH:Reply-To:'} = "Your Reply-To Address";

Backward compatibility で残っている変数が

	$FORCE_COMMAND_REPLY_TO = "address-you-want-to-use";

です。実際には $Envelope{'GH:Reply-To:'} への代入と全く同じです。


.S	X-ML-Info: の内容を指定する
.k	$X_ML_INFO_MESSAGE
.k	&DEFINE_FIELD_FORCED('x-ml-info') = "書きたいこと";

	&DEFINE_FIELD_FORCED('x-ml-info') = "書きたいこと";

で強制的に指定すれば良いでしょう。一応昔風に変数

	$X_ML_INFO_MESSAGE

で指定した内容を優先して X-ML-Info: につけて配送できるようにもなってい
ます。そうでない場合はモードによって適当に作られた user friendly な内
容が付け加えられます。



.S	To: と Cc: の Rewriting 処理
.l	$NOT_REWRITE_CC


可読性のため、To: フィールドは $MAIL_LIST が展開され、常にＭＬのアドレ
スが出るようになっています。
original header を通すという設定の場合はそうはならずオリジナルのままです。

ですが、apparent-to: になっていて、見辛いとか一体どうしてこのＭＬに来
たメールなの？とかよくわからないメールも多いので、それよりは可読性を重
視して、こういう実装になっています。

現在は
	1 To: に   $MAIL_LIST が含まれているなら、そのまま
	2 To: には $MAIL_LIST が含まれていない場合は

	  To: $MAIL_LIST
          Cc: に元の To: を付け加えて、情報を保存しておく

To: Cc: というのは人間がメールを書く時の単なる便宜上のもので、配送手段
の SMTP としてはなんら区別はしていません。ですから、情報を落さず、To: 
は可読性のために $MAIL_LIST としています。

[蛇足] なお、To: Cc: の中に重複して現れるアドレスには普通それらを一つ
にまとめて一通分のみが配送されます。だから複数あっても気にしないでね


.S	NIFTY対策をするか?(参加者にNIFの人もいる, OBSOLETE?)
.label	NIFTY
.label	$AGAINST_NIFTY
.label	against-nifty
.k	$USE_ERRORS_TO

注意：もう必要ないらしい

	$USE_ERRORS_TO = 1;

とすると Errors-To: をつけます。もしくは

	$AGAINST_NIFTY = 1;（対策をする）

でも同じこと意味です。

NIFTY は非常識にも、Errors-to という時代おくれの部分しかみてないので;_;、
config.ph あたりで

	$AGAINST_NIFTY = 1

とするとメール本文に

.key	Errors-To: $MAINTAINER
	Errors-To: $MAINTAINER

がつきます。これで NIFTY からのエラーメールが $MAINTAINER に返るように
なってくれます。後向きな解決法ですが;_;。
前向きなのは、みんなで文句をいって直させることです。
＃でも、僕はアカウントをもってない;_;。アカウントを持ってる人が一年く
らいいいつづけないとだめなんだろうなぁ（はぁ）

なお、$ERRORS_TO で Errors-To: の部分は $MAINTAINER から変更できます。
.k	$ERRORS_TO


.# $Id$
.# Copyright (C) 1993-1996 fukachan@phys.titech.ac.jp
.# Copyright (C) 1996      fukachan@sapporo.iij.ad.jp
.# fml is free software distributed under the terms of the GNU General
.# Public License. see the file COPYING for more details.
