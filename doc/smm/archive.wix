.C	アーカイブ, Archive
.l	archive
.k	archive

.S	Introduction
.l	archive-and-expire-conflicts

記事は溜ってくるとかなり場所をとります。古い記事は tar で100個くらい固
めて gzip かけると 1/4 くらいになります。100 というマジックナンバーの
目安は 100 個固めると 50K 前後になるので好都合な値にうまくなるという経
験論から来ています。効率がいいのはヘッダとか同じようなものが繰り返し出
てくるからです。

$USE_EXPIRE と $USE_ARCHIVE を同時に使う場合は要注意です。

「絶対に記事はうしなわれてはいけない」という強い要求がある場合に 
「expire しつつアーカイブも作ることを全自動で行なう」ことは推奨できま
せん。というのはだれかがOSのtarやgzipを間違えて入れ換えたとかいう場合
を想定してみると危険性がわかります。expire はそういうものに依存してい
ないの普通に動いて記事を消していきますが、アーカイブは作成されなくなっ
てしまいます。よって

	うちのOSはそんなことはしない、大丈夫
	まぁこのＭＬの記事は失われてもいいかぁ

などの条件が必要です。

アーカイブかExpireのどちらかを自動でどちらかを手動でやるのが理想なのか
もしれません。安全性からいえばやはり自動アーカイブ＋手動expireですね。

ファイルの取り寄せ等に影響があるため必ず $EXPIRE_LIMIT が日数ではなく"
記事の数"(残したい記事の数)で指定されていて、

	$EXPIRE_LIMIT > $ARCHIVE_UNIT 
.k	$EXPIRE_LIMIT > $ARCHIVE_UNIT 
.k	$EXPIRE_LIMIT
.k	$ARCHIVE_UNIT 

でなくてはいけません。念のため

	$EXPIRE_LIMIT = $ARCHIVE_UNIT * 2;

くらいにしておくのが良いでしょう。そうでない場合整合性が保証されないの
でエラーとなります。もちろん毎回ファイルを全て調べる等の莫大な 
overhead をかければ実現はできますが、コストが見合うとは思えないので実
装されていません。


.S	config.ph の設定
.l	$USE_ARCHIVE

現在ではHOOKをかけなくてすむように 

	$USE_ARCHIVE = 1;
.k	$USE_ARCHIVE

をセットすれば呼べるようになっています。
アーカイブが作られる場所は $ARCHIVE_DIR で、

	$ARCHIVE_DIR = 'var/archive';
.k	$ARCHIVE_DIR

です。ここでは 'var/archive' です。

この内容はアーカイブの場所のリストである配列 @ARCHIVE_DIR の先頭に代入
されます。アーカイブの場所は複数あってもいいですがそれは get, mget の
時に探す対象にはなりますが、自動的に作る場所は $ARCHIVE_DIR ==
$ARCHIVE_DIR[0] です。

何個ずつ単位でまとめるかは

	$ARCHIVE_UNIT 
.k	$ARCHIVE_UNIT 

で決まります。この値がないと

	$DEFAULT_ARCHIVE_UNIT
.k	$DEFAULT_ARCHIVE_UNIT

が使われます。デフォールトは 100 です。backward compatibility のためこ
の変数がなくても 100 になります。
＃ @StoredSpool_DIR = ('var/archive'); は Obsolete な書き方です。
＃ Backward Compatibility として
＃ 内部で @ARCHIVE_DIR に代入してるので、どちらでも動きます
.k	@StoredSpool_DIR


.S	"# get 1 " と archive

例えば、"# get 1 " というコマンドを送り込んだ時

	$SPOOL_DIR (MLのHOME/spool/)

を探索し、

	もしファイル spool/1 が見つかればＯＫ、
	見つからない時は

	@ARCHIV_DIR (e.g. MLのHOME/var/archive/)

という場所も探し、1-100 までがtar + gzipされている 

	var/archive/100.tar.gz 

があれば、ファイル １ を取り出して１だけを送り返します。


.S	"# mget 1 " と archive

上と同じです。


.S	"# mget 1-10 " と archive

これも同様で、もし見つからない時はアーカイブ(100.tar.gz)から1〜10
の記事を取り出してその10個だけを送り返します。


.S	"# get 100.tar.gz" と archive

これは "# mget 100.tar.gz" と再解釈され

	var/archive/100.tar.gz 

を送り返します。デフォールトはこれを uuencode したものです


.S	"# mget 100.tar.gz" と archive

上述のようになります。


.S	gzip file にする(アーカイブへの変換)
.l	Archive.pl
.k	Archive.pl

$USE_ARCHIVE の自動操作にまかせずに時々手で もしくは cron 等でこのプロ
グラムを動かしても良いです。
.xref	cron

	Archive.pl [-dh] [-A ARCHIVE_DIR][-u unit] MAX
	-d	debug mode
	-h	help 
	-A	アーカイブを作る場所を指定
		config.ph より強い
	-u	固める単位。デフォールトは記事１００個ずつ

	MAX	これで最大どの記事までをアーカイブするか強制指定
		デフォールトでは今の記事番号の直前の”１００の倍数”
		までをアーカイブの対象の記事としてアーカイブを作る。

注意:このプログラムはMLのホームで実行されることを前提にしています。つ
まり

	chdir /var/spool/ml/Elena; perl bin/Archive.pl 

のように使うことを期待されています。

これは Archive.pl 2000 とかすると、2000 までのファイルを 100 個ずつの
塊にして、archiveに作ります。変数は Archive.pl の先頭でセットしてくだ
さい。スプールのオリジナルは消さないので、注意を払って消して下さい
(とりかえしがききませんから、それは)
＃自分じゃ、念のため ある程度まとまったところでこうやって手動でつくっ
＃てます。

例えば、

	spool/1-100	を tar+gzip して var/archive/100.tar.gz
	spool/101-200	を tar+gzip して var/archive/200.tar.gz

のようなファイルをarchiveの下に作るプログラムが bin/Archive.pl です。

目的のＭＬの場所にまでいって

% ls 

MSendrc		actives		config.ph	deny
guide		help		list		log
members		objective	seq		spool
summary		welcome

% test -d var || mkdir var
% test -d var/archive || mkdir var/archive

% perl Archive.pl 3800

	…たくさんメッセージが出るが省略…

% ls archive

100.tar.gz   200.tar.gz 
	…たくさんメッセージが出るが省略…


spoolの 3800 までの 100 個ずつのパッケージを作りました。spoolの方の元
メールを自動的に消しはしない(安全のため)ので、自分で消して下さい。


.S	アーカイブ作成を cron で自動処理
.k	archive by cron

cronで自動的(例えば週一日曜の朝とか)に次の形で

   (chdir "MLサーバのdirectory名"; /usr/local/bin/perl bin/Archive.pl)

とでもすれば良いでしょう。
＃見本として bin/Archive.sh があるので見てみてね。

いくつかＭＬがあるなら、シェルスクリプトにまとめて呼べば楽ですね。
ようするに まとめ送りと一緒とかでもよいですね

例：
crontab が
例：

	0 * * * * /bin/sh /usr/libexec/fml/archive.sh

/usr/libexec/fml/archive.sh は
例：
	#!/bin/sh

	(chdir /var/spool/ml/Elena;    /usr/local/bin/perl bin/Archive.pl)
	(chdir /var/spool/ml/Freekick; /usr/local/bin/perl bin/Archive.pl)


.S	何故、まとめてgzip化したいのか?

1. 一個一個gzipかけると、約半分にしかなりませんが、100個まとめて書ける
と、ヘッダとかの重なりがあるので約25%にまで圧縮できるようになります。

2. Mail-Countが万を越える頃になるとi-nodeの計算に時間がかかるようにな
るのでファイル数を減らす or ほかの場所に移すことに意味があるようになり
ます。そこでspoolの中身をうつし、100分の一のファイル数にすると効果が非
常にあります。また、kernel 内の directory cache が大きくなるのも避けた
いところですから、そのためにもよいです。


.# $Id$
.# Copyright (C) 1993-1997 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1997 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
