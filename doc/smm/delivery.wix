.C	記事の配送について
=E.C	Mail Delivery

.S	フィルタリング
=E.S	Filtering
.xref	EnvelopeFilter

ＭＬにながれるメールの中には好ましくないものがあります。例えば

	○ 本文が何もないメール
	○ help や unsubscribe などの英語一行メール
	○ %echo ふがほげ の行
	   1999/02/24からはこの行がひっかかった時点で拒否
	   これ以前はあるパラグラフがこの行そのものの時のみ拒否
	   つまり『空行＋%echoなんとか行＋空行』の時だけだった
	○ Message-Id: が朗かに addr-spec でないのは SPAM メール
=E
	* reject null body
	* reject one line English words mail
	  e.g. "help", "unsubscribe"
	* reject invalid Message-Id mails (may be SPAM mails)
	* other strange syntaxes

などです。FMLはヘッダや本文の内容によってこれらを弾くフィルターを内蔵
しています。詳細と仕組みについては .ptr{EnvelopeFilter} を見て下さい。

オプションとしては次のようなものがあります。

	$FILTER_ATTR_REJECT_COMMAND (default 0)
.k	$FILTER_ATTR_REJECT_COMMAND

○ #unsubscribe などのコマンドをはじく
=E
* reject '#unsubscribe' like commands

	$FILTER_ATTR_REJECT_2BYTES_COMMAND (default 0)
.k	$FILTER_ATTR_REJECT_2BYTES_COMMAND

○ ２バイト英文字ではじまる行を拒否
	   例: ＵＮＳＵＢＳＣＲＩＢＥ ほえほえ
=E
* reject a line begining with Japanese 2-byte English Characters
	  e.g. 2-byte "unsubscribe"

○ ヘッダに特別なキーワードを見つけたら弾く
.xref &DEFINE_FIELD_PAT_TO_REJECT

happy99 virusのメールを弾く。
=E
reject "happy99 virus" mail

	&DEFINE_FIELD_PAT_TO_REJECT("X-Spanska", ".*Yes.*");


○ これ以外の高度なチェックは
=E
You can use a hook to write your own more complicated filtering rules.
Attention: in this hook you can refer %Envelope as %e.

	$DISTRIBUTE_FILTER_HOOK (for post)
.k	$DISTRIBUTE_FILTER_HOOK
.k	$REJECT_DISTRIBUTE_FILTER_HOOK
.if LANG == JAPANESE
＃ $REJECT_DISTRIBUTE_FILTER_HOOK でも可能です(obsolete)。
＃ 同様に $REJECT_COMMAND_FILTER_HOOK もありますが obsolete
.k	$REJECT_COMMAND_FILTER_HOOK
.fi

	$COMMAND_FILTER_HOOK (for command)
.k	$COMMAND_FILTER_HOOK

で直接 perl の構文で %e (%Envelope) ハッシュの変数を使って記述して下さ
い。HOOK 内部では $e{'h:from:'} などでハッシュにアクセスして下さい。
＃このために独自の言語とかをまた新たに導入するのは面倒だとおもうので
＃perl で生書きです。


.S	PGPを使って暗号化したメーリングリストにする
=E.S	Pgp Encrypted Distribution (Mailing List)
.l	$USE_ENCRYPTED_DISTRIBUTION
.k	$USE_ENCRYPTED_DISTRIBUTION

	$USE_ENCRYPTED_DISTRIBUTION (default 0)

makefml のメニューの『セキュリティ』で USE_ENCRYPTED_DISTRIBUTION を設
定します。PGPの鍵を作る、メンバーに配るの作業が別途必要です。以下で述
べます。
=E
You can set PGP Encrypted ML by "makefml config" menu. When
$USE_ENCRYPTED_DISTRIBUTION is set, your ML becomes a PGP encrypted
ML. You need to set up ML PGP keys and the distribution other than
to enable this option. Please see below on it.

暗号化とかファイアウォールとかは中途半端が一番危ないです。詳しく説明し
ませんが、これで意味の分からない人は使わない方がいいかもしれません。

secure か否かはすべて「サーバが破られない」にかかっています:)
これはもともとパスフレーズなどを人間が覚えていないといけないので全自動っ
て原理的にだめだということの必然の結果なんですがね。
というわけで意味があるようなないような暗号化ＭＬ実装例です。
=E
Fundamental theory requires some not-written password for security
e.g. in a human brain. So encryption by a ML server is theoretically
vulnerable when a cracker can penetrate the ML server machine. 
Our theory requires an assumption that the ML server machine is enough
secure to save password files (RSA keys with empty pass phrase) on it.

1	サーバのマシンの上で makefml で(PGPPATH を変えて)
	メーリングリストの秘密鍵を作る。
	全自動で実行するためにこの時パスフレーズは設定しない。
=E
1	makefml pgp -kg to make the mailing list secret key
	with empty pass phrase. 

	なおパスフレーズを設定しても結局それをどこにか平文で書いておか
	なければならないのでセキュリティの度合いは同程度だと考えられる。

2	メーリングリストの公開鍵をメンバーに配る。
=E
2	distribute the server public key to members of ML

3	メーリングリストのメンバーの公開鍵をメーリングリストの
	鍵リングに登録する(makefml を使う)。
=E
3	add public keys of members to the ML's PGP key ring.

4	メンバーはメーリングリストの公開鍵を使って暗号化しサーバへ送る
=E
4	each member encrypts the mail with the server public key
	to send it to the ML server.

5	サーバはメンバーの公開鍵と自分の秘密鍵を使って
	復号とメンバー全体に対して暗号化する
=E
5	the server decrypts the mail with its secret key and
	encrypts the mail with members public keys.

6	普通のメーリングリストサーバの動きに従い配送する。
=E
6	send it in usual procedures.



.C	メール配送システムについて
=E.C	Mail Delivery System Tuning

.S	SMTPライブラリについて
=E.S	SMTP library
.l	smtp
.k	SMTP (Simple Mail Transfer Protocol)
.k	MTA (Mail Transport Agent)

SMTP ライブラリは SMTP(プロセス間通信)で sendmail 等のMTA(Mail
Transport Agent)と通信するライブラリです。
=E
FML can connect MTA (Mail Transport Agent) via SMTP (IPC).
libsmtp*.pl are SMTP libraries. The default port is 25/tcp.
You can control the port as $PORT. 

$PORT = 25 (25/tcp) で通信しますが、

	$PORT 
.k	$PORT 

を変えることで別のポートで通信することもできます。また通常
=E
FML logs a session details in $SMTP_LOG.

	$SMTP_LOG (default "var/log/_smtplog")
.k	$SMTP_LOG
.l	$SMTP_LOG

というファイルに通信のログを残します。このログはデバッグに非常に役立ち
ます。
=E
If you do not need th session log, set 

	$NOT_TRACE_SMTP 
.k	$NOT_TRACE_SMTP 

をセットすると、このログは残りません。

また、どのマシンの sendmail を使うかも自由に設定できます。デフォールト
はそのマシンです。もしMLサーバのマシン(受けるマシン)が貧弱ならそのマシ
ンが何十通もメールを送り出すのは酷です。
=E
Which MTA in which hosts FML uses as a distributor? In default, $HOST
is "localhost" (ML server itself). You can use another host by
configuring $HOST.
.l	$HOST

	$HOST         = 'localhost'; (default)
.key	$HOST

そういう場合変数 $HOST を書き換えて別のマシンに配送を任すこともできま
す。その時は

	$HOST         = 'beth.foo.bar.ac.jp'; (another host)

のようにそのマシン名を書いて下さい。もちろんアクセスできないマシンとか
ではできません(あったりする)し勝手にそのマシンのパワーを使うことになる
のでそのマシンを使う許可を得るべきです。
=E
You requires permission that you can use $HOST as a distributor since
you use the machine resources. 

HOSTではポート番号が25でないMTAへのアクセスも可能です。例えば port
10025/tcp を使うこともできます。
=E
You can use MTA with another port (not 25/tcp). For example, 10025/tcp

	$HOST         = 'beth.foo.bar.ac.jp:10025'; 

.S	予備のSMTPサーバ
=E.S	Secondary SMTP Servers
.k	予備のSMTPサーバ
.k	@HOSTS

もし SMTP サーバに何かあった時のために @HOSTS に複数台の予備の 
sendmail の走っているマシンを定義することが出来ます。
=E
If you can use several machines as delivery, you can set

   @HOSTS = (machine-1.domain, machine-2.domain, machine-3.domain, ...);

この場合、もし $HOST に connect() できない時は、machine-1 に、
もし machine-1 に connect() できない時は machine-2 へ…とい
う風に予備のサーバを使い何とか配送をしようと試みます。
全部だめだった場合は sendmail コマンドを使って配送を試みます。
sendmail がないシステムでは qmail-smtpd, exim なdも試します。
=E
to use machine-* parallelly. FML breaks out recipients up to
$MCI_SMTP_HOSTS groups. Mail to deliver is injected to each MTA on
$HOST and @HOSTS. If all connections to hosts fail, FML tries to send
mail with "sendmail" called as a command.

.S	リレー(RFC821)
=E.S	Relaying based on RFC821
.k	%リレー (obsolete)

リレーなんか禁止というサイトもあることにちゅういしましょう(昔のはなし)。
最近では SPAM があるのでリレーは基本的に禁止ですからあまり意味がありま
せん。もちろんお互いに合意の上でIPアドレスベースでチェックしてリレーを
するなどは考えられます。
=E
Today we cannot permit relaying against spam mails. If sendmail is not
found, FML tries to use qmail-smtpd, exim.

.S	activesファイルによるリレー制御
=E.S	Relay Configurations In Actives File

actives には
=E
When you can use relay server (here axion.phys.titech.ac.jp), You can
write how to relay in "actives" file, 

	アドレス			リレーサーバー
	fukachan@phys.titech.ac.jp	r=axion.phys.titech.ac.jp
=E
	address				relay server
	fukachan@phys.titech.ac.jp	r=axion.phys.titech.ac.jp

のような書き方ができます。これをすると sendmail には
=E
FML interprets, rewrite and injects this to sendmail as:

	@axion.phys.titech.ac.jp:fukachan@phys.titech.ac.jp

のように渡されます。actives ファイルに
=E
If "actives" file has the following entries

	fukachan@phys.titech.ac.jp	r=axion.phys.titech.ac.jp
	Elena@phys.titech.ac.jp		r=axion.phys.titech.ac.jp
	cocoa@phys.titech.ac.jp		r=axion.phys.titech.ac.jp

なものがあると
=E
FML injects 

	@axion.phys.titech.ac.jp:fukachan@phys.titech.ac.jp
	@axion.phys.titech.ac.jp:Elena@phys.titech.ac.jp
	@axion.phys.titech.ac.jp:cocoa@phys.titech.ac.jp

のように渡されます。sendmail 8.x での配送は axion.phys.titech.ac.jp ま
で一通にまとめられて来てaxion.phys.titech.ac.jp で3通にばらけます。
=E
sendmail 8.x delivery aggregates SMTP sessions to axion.
On axion, MTA segregates it to three mails.

パケットの数もサーバの負担も軽くなるのでもしリレーしていいという許可が
得られればどこかでリレーサーバを使えるといいですね。

.if	LANG == JAPANESE
[捕捉]

fml 1.3.2 からは actives 等の表現が拡張性のため違う形になっています。
古いフォーマットで書いた場合は、自動的にNEW FORMAT に自動変換して解釈
しています。
.xref	fml-file-structure

OLD FORMATでは

	fukachan@phys.titech.ac.jp	axion.phys.titech.ac.jp

NEW FORMATでは

	fukachan@phys.titech.ac.jp	r=axion.phys.titech.ac.jp
.fi

.S	全てのメールをリレーサーバに投げる
=E.S	Default relay server	

$DEFAULT_RELAY_SERVER が定義されている場合は強制的に全てのメールを
=E
You can set up $DEFAULT_RELAY_SERVER. it is used as a default relay
server. FML recognizes all recipients should be delivered via the
relay server. FML interprets entries in "actives" has
r=$DEFAULT_RELAY_SERVER.

	$DEFAULT_RELAY_SERVER
.k	$DEFAULT_RELAY_SERVER
.l	$DEFAULT_RELAY_SERVER

で定義されたリレーサーバへ投げそのサーバに配送します。

.S	activesファイルによるリレー (sendmail 5.x)
=E.S	Relay Based On Actives File (Sendmail 5.X)

	fukachan@phys.titech.ac.jp	r=axion.phys.titech.ac.jp
	Elena@phys.titech.ac.jp		r=axion.phys.titech.ac.jp
	cocoa@phys.titech.ac.jp		r=axion.phys.titech.ac.jp

↑このように順番に並んでいないと一通になってくれませんので注意。
それ以外は8.xの時と一緒です。
=E
In Sendmail 5.x, you require additional orderings by relay server in
"actives". 

.S	CF (by motonori@wide.ad.jp) 形式による relay 
=E.S	Cf (By motonori@wide.ad.jp) Style Relay Configurations
.k	relay hack based on CF (by motonori@wide.ad.jp)
.k	$CF_DEF
.k	%RELAY_NGW
.k	%RELAY_GW
.k	%RELAY_NGW_DOM
.k	$RELAY_HACK

$RELAY_HACK = 1; がセットされ、$CF_DEF で STATIC_ROUTE_FILE で定義する
static 配送ルールを記したファイルが設定された場合、それに従ってリレー
サーバの設定がされます。
=E
When $RELAY_HACK = 1; is defined and $CF_DEF (CF style static delivery
rule file) exists, FML controls relaying based on it.

CF 形式の例1:
or.jp ドメイン宛のメールは mlrelay0.domain0 へ全部送る。それ以外は 
$HOST (通常自分のマシン) で定義されるマシンで配送を行なう。
=E
CF style example: 
	send e-mail for or.jp domain to mlrelay0.domain0.

	GW smtp-ignmx:  mlrelay0.domain0
	DOM or.jp

CF 形式の例2:
co.jp にマッチしないドメイン宛のメールはすべて mlrelay.domain というマ
シンへ送る。しかし or.jp ドメイン宛のものは mlrelay0.domain0 へ送る。
=E
CF style example2:
	send mails not for co.jp to mlrelay.domain.
	send e-mail for or.jp domain to mlrelay0.domain0.	 

	NGW smtp-ignmx: mlrelay.domain
	DOM co.jp
	GW smtp-ignmx:  mlrelay0.domain0
	DOM or.jp

リレー情報はハッシュテーブル %RELAY_NGW %RELAY_GW %RELAY_NGW_DOM に入
れられ、smtp library で利用されます。
=E
SMTP library uses hashes %RELAY_NGW, %RELAY_GW, %RELAY_NGW_DOM for
control of this relay routings.

.S	同じmxについて
=E.S	On The Same Mx
.key	mx

sendmail 8.xではCHANGES-R5-R8にあるとおり↓
=E
In CHANGES-R5-R8 of Sendmail R8:

   For example, if two sites ``foo.com'' and ``bar.com'' are both
   served by UUNET, they will have the same set of MX hosts and will
   be sent in one transaction.  UUNET will then split the message

一通で送られます。ばらばらの順番でも大丈夫。

sendmail 5.xでは@.*の部分が厳密に同じで、さらにちゃんと並んで書いてあ
れば
=E
Sendmail 5.x requires ordering by domain:

	fukachan@phys.titech.ac.jp	
	Elena@phys.titech.ac.jp	
	cocoa@phys.titech.ac.jp	

一通にまとめられます。

qmail 1.0 はそうことをせず相手の負荷も回線の太さも考えず、ひたすら一通
ずつ投げつけます(だ〜っ)。

.S	MCI Cache
=E.S	MCI Cache
.k	MCI

.if LANG == ENGLISH
Today sendmail 8.x has parallel connections and re-uses sockets. 
Delivery acceleration codes is called MCI.
Please see deliver() in /usr/src/usr.sbin/sendmail/src/deliver.c.

WIDE-patched sendmail and smtpfeed has more and more elaborate
parallelism of resolver and SMTP connections.
.fi
.if LANG == JAPANESE
TCP Connection Cache の基本的なアイデアは TCP Connection 自体のコスト
の高さです。

もともとの sendmail は

	for (…おくるべきホストのリスト…) {
		ソケット、コネクト、通信、おしまひ
	}

を一つ一つおこないます。これだと 通信が遅いだろうが、なんだろうが、
TIMEOUT か error が起こるまで長い間無駄な配送がありえます。

sendmail 8.7 では標準装備ですが、いまは
#旧もとのりさんのWIDEぱっち ってやつです

	for (…おくるべきホストのリスト…) {
		ソケット1
		ソケット2
		…

		じゅんぐりにまわしていって、
		通信がしやすい connection へ優先的に
		通信、(…おしまひ)

		………
	}
	#ちょっと、簡単化し過ぎかな↑

のように、さっさと送ることが可能なホストへどんどん送って、駄目なところ
は駄目なままです。どうしてもだめなら、最後は queue up されて、次回30分
後とかに retry です。

そういう意味で、MCI CACHE は多いと だめなホストが2、3個ならかなり理想
的な速度で配送できるでしょう。もし、MCI_CACHE が2個で、2個だめなホスト
があると、そこでしばらくつかえてしまうので、遅くなってしまい R5 のよ
うになってしまうと。

そういう意味で MCI CACHE は多ければ多いほどよさそうに見えますが、やり
すぎると 今度はカーネルと折り合いがつかなくなるので、まぁ数個が妥当な
数字なのでしょうね。

○ 1つのメールは常に1か所づつ配送されるのでしょうか?

これは (multi thread kernel でないのなら) kernel がある時点ではかならず 
CurrentProcess を実行しているのだから、YES です。ただ 通信はしていなく
ても Connection 自体は OkN の N 個(MAX) ACTIVE なままです(netstat で
みえるもの)。

これにさらに MX Cache 等が組合わさって、R8はR5にくらべ非常に高速化さ
れましたね。
.fi

.S	配送プログラム(e.g. sendmail)との通信のログ
=E.S	SMTP logfile
.k	var/log/_smtplog
.k	_smtplog
.k	$NOT_TRACE_SMTP
.k	$SMTP_LOG

sendmailとのやりとりの記録(もっとも最近のものだけ)デバッグに便利です。
(デバッグとか終わっちゃって)必要ないなら
=E
For debug, FML logs SMTP session log in $SMTP_LOG. If you do not want
the logging, please set

	$NOT_TRACE_SMTP = 1; 

と config.ph にかいてください。ログをとらなくなります。

.S	ドメインをソートしてから配送
=E.S	Delivery After Sorting

bulkmailer の用にドメインをソートしてから配送プログラムに突っ込む。
でも現代ではほとんど意味がないだろう。
=E
If

	$SMTP_SORT_DOMAIN
.k	$SMTP_SORT_DOMAIN

を設定するとソートを行なう。
=E
is defined, delivery routine works after sorting recipients by domain.

.# [MEMO] (against variable consistency check)
.# %WMD is not a user defined variable.
.#


.S	$OUTGOING_ADDRESS: perl の生存時間を短くする 
=E.S	$OUTGOING_ADDRESS: shorten perl life time

.if LANG == JAPANESE
貧弱なCPUのマシンに貧弱なメモリしかない場合(486で8M,16Mみたいな…)には、
fmlが直接MTAへSMTP配送する時間すら惜しんで perl の生存時間を短くしたい
という需要があります。そのための機能を提供します。
$USE_OUTGOING_ADDRESS が non zero の時に次のように動きます。

まず $OUTGOING_ADDRESS は:include:するだけの単純なMLです。例えば
/etc/aliasesで

	list-going: :include:/some/where/list

のようにかきます。/some/where/list は actives などから生成されたＭＬの
配送リストです。MTAはこのlistの人に配送を試みます。

   if ($USE_OUTGOING_ADDRESS) {
	1. fml は一つのアドレス $OUTGOING_ADDRESS だけに送り終了
	   perl はこの時点で終了します。
	2. MTAが前述の :include: 先の配送リストを展開しそのメンバーに配送
   }

XXX: minmin 様にささぐっす(謎)
.fi
.if LANG == ENGLISH
$OUTGOING_ADDRESS is a simple :include: style ML. The member is
recipients of this ML. Fml generates the file from recipient lists,
@ACTIVE_LISTS files. 

   if ($USE_OUTGOING_ADDRESS) {
	1. fml sends article to $OUTGOING_ADDRESS.
	   Hence perl dies here!
	2. MTA expands the include and delivers the article to ML members.
   }
.fi

[設定の手順]
=E
[How to configure]

0.	elena MLを例にとります。
=E
0.	Consider elena ML

1.	include の見本を作る(include-outgoing)
=E
1.	make include examles

   % cd /var/spool/ml/elena
   % make outgoing 

include-outgoing という見本のファイルが生成されます。 
=E
You can see elena/include-outgoing file.

2.	/etc/aliases に書いて newaliases
=E
2.	add elena-outgogin to /etc/aliases and run newaliases

   elena-outgoing: :include:/var/spool/ml/elena/include-outgoing

3. 	makefml config でこの機能を有効にする。
=E
3.	run 'makefml config' to enable this function

	-> OPTIONS -> SMTP -> USE_OUTGOING_ADDREESS -> "y"

$USE_OUTGOING_ADDDRESS を1にします。
=E
$USE_OUTGOING_ADDDRESS changes from zero/null to 1.


.S	PIPELININGを使わなくする
=E.S	Disable PIPELINING

	$NOT_USE_ESMTP_PIPELINING = 1;

PIPELINE が可能な場合でも使わない

.# $Id$
.# Copyright (C) 1993-1999 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1999 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
