.C	FML のプロセス
=E.C	Fml Processes
.k	fml process
.l	fml-process

ＭＬサーバの基本動作を知っておくとカスタマイズの時役にたちます。
=E
It is useful to customize FML if you know the fundamentals of ML
servers. In this chapter we describe fml internals.

.S	ＭＬサーバの動作 (fml と sendmail の役割分担)
=E.S	Functions as  ML Server
.key	ＭＬサーバの動作
.l	ml-process

.if LANG == JAPANESE
   メールが SMTP で送られてくる

             ↓

   SMTP で待ち構えているプログラムがうけとる (例: sendmail)

             ↓

   /etc/aliases から何をすれば良いのかを理解して、
   setuid 操作等を行なった後 fml.pl の STDIN にメールが送り込まれる。

             ↓

   (sendmail -> fml.pl へ引き渡される。ここからが FML の担当)
   config.ph による設定に従い、ヘッダの解析、ＭＬメンバーのリストに従い
   配送 or コマンド要求を処理した結果のメールを配送リストと共に
   sendmail 等のSMTPサーバへ引き渡す

             ↓

   (ここから再び sendmail の担当)
   sendmail 等のSMTPサーバがメールの配送を行なう。
.fi
.if LANG == ENGLISH
	mail comes via SMTP.
		|
	MTA e.g. sendmail receives it.
	Here after we suppose MTA is sendmail. 
		|
	sendmail scans /etc/aliases and runs programs after setuid().
	sendmail runs and injects an in coming mail into the program.
		|
	sendmail -> fml.pl
	Fml.pl reads and evaluates config.ph and runs.
	It analyses the header, 
	authenticate the sender is a member or not.
	Fml distributes a ML article by passing it to MTA.
		|
	MTA delivers a passed mail to ML members.
.fi

フィルタだけなら sed でも十分だし"配るだけ"なら Sendmail 8.x でも十分
でしょう。しかし、+αでログをとり、スプールし、必要なら取り寄せられる
ようにちょこっとだけ複雑なことをしようとするならこのサーバ まで必要と
なるというわけです。
=E
It is enough to use "sed" for a filter and "sendmail" for delivery.
If you expect a mailing list driver works for logging, spooling and a
lot of commands to retrieve articles and so on, you need more
elaborate programs. Fml provides a lot of functions described below.

なおこの図でわかるとおり、まとめおくりはこれとは"全く別の"プロセスです。
まとめおくりは自動的に作動するわけではありません。
まとめおくりとは、一定時間ごとにスプールされたＭＬの記事を送ってあげる
"別のプロセス"です。このプロセスは別の仕掛けで定期的に実行されなければ
なりません。
.xref msend
=E
Fml provides, delivery, functions for a lot of commands, digest
delivery and so on. fml.pl is a delivery program and also provides
command functions.  Digest delivery (matome okuri) is another process. 
You must set up that cron executes msend.pl (digest delivery system)
periodically. 
.xref msend

.S	Sendmail -> fml.pl 時の動作
=E.S	How "sendmail -> fml.pl" works
.k	sendmail -> fml 時の動作
.l	sendmail2fml

sendmail から fml.pl へメールが渡される時は次のように動作します。
=E
How sendmail passes an in-coming mail to fml.pl? Here it is. Consider
Elena Mailing list as one example below.

○ まず /etc/aliases にある
=E
Firstly sendmail scans /etc/aliases to find

	Elena: :include:/usr/local/list/Elena
	owner-Elena:fukachan

のような部分から /usr/local/list/Elena を実行すればよいことがわかるの
で sendmail はこのファイルを実行します。/usr/local/list/Elena の中身は
=E
For Elena ML, sendmail executes the content of /usr/local/list/Elena.
The content of /usr/local/list/Elena is 

	"|/usr/local/fml/fml.pl /var/spool/ml/elena"

のようになっています。
=E
This implies that sendmail passes mail to fml.pl via PIPE (pipe(2)).
fml.pl receives mail via STDIN. fml.pl works with this input.

次に fml が上の引数は /var/spool/ml/elena を Elena ML の HOME だと見な
し /var/spool/ml/elena/config.ph に従い fml の設定を行います。
=E
fml.pl recognizes the first argument /var/spool/ml/elena as HOME
directory of Elena ML. fml.pl reads /var/spool/ml/elena/config.ph and
sets up Elena ML configurations.

そのあと設定に従いメールを処理します。 コマンドラインオプションを指定
するときは /usr/local/list/Elena の中で
=E
If you use command line options for fml.pl, please use like this.

	"|/usr/local/fml/fml.pl /var/spool/ml/elena --ctladdr "

のように書きます(コマンドラインオプションについては Chapter .ptr{clo})。
引数の書き方の順番は任意ですが、引数の中の最初の directory を ML の 
HOME (config.phのある場所 もしくは spool やメンバーファイルのある場所) 
と見なします。
=E
Arbitrary order is available. fml.pl regards the first argument of
directory as ML's HOME (e.g. location of config.ph).

.S	ライブラリのファイルを探す順番 (fml.pl と ARGV)
=E.S	Order to search library files
.k	fml.plと引数
.k	$DIR
.k	$LIBDIR

=E
Consider elena ML again. fml.pl is kicked off like 

	/usr/local/fml/fml.pl /var/spool/ml/elena

のように起動されるわけですが、この場合/usr/local/fml/fml.pl の 
/usr/local/fml 部分をとりだし /usr/local/fml を実行ファイルやライブラ
リのパスとみなします。
=E
fml.pl extracts the directory path (/usr/local/fml) of fml.pl absolute
path. It searches OS for executable and libraries in the following
order

	1   /var/spool/ml/elena 
	2   /usr/local/fml 

この順番で dynamic loading するファイルを探します。例えば config.ph や 
libsmtp.pl をこの順番で探します。もし、この後に directory 名がさらに付
け加えられていた(複数可能)場合、例えば
=E
If the following arguments are given,  

   "|/usr/local/fml/fml.pl /var/spool/ml/elena /usr/lib/uja /lib/aja"

の時は
=E
fml.pl searches OS for executable and libraries like this:

	1   /var/spool/ml/elena 
	2   /var/spool/ml/etc/fml/
	3   /usr/local/fml 
	4   /usr/lib/uja
	5   /lib/uja

のような順番でファイルを探します。

.S	設定ファイルのサーチ順番
=E.S	Priority of configuration file search
.l	order-of-option-efficiency
.l	設定ファイルのサーチ順番
.l	site_init.ph
.l	sitedef.ph
.n	sitedef.ph
.k	site_init.ph
.k	sitedef.ph

オプション設定の強い順番に並べると
=E
The evaluation order of configuration files is like this. 
"1" is most directive.

	1 コマンドラインオプション (fml.pl -d や fml.pl --ctladdr 等)
	  なおコマンドラインオプションについては Chapter .ptr{clo}。
	2 sitedef.ph による設定のoverwrite(サイト共通の設定等が望ましい)
	3 各MLごとの config.ph による設定
	4 site_init.ph によるデフォールト設定	
	5 fml デフォールト設定
=E
	1 command line options (e.g. fml.pl --ctladdr)
	2 sitedef.ph
	3 config.ph
	3 site_init.ph
	5 fml defaults

普通の program と同様ですね。ＭＬごとではなくそのマシン共通の設定にな
るもの
=E
sitedef.ph and site_init.ph may be useful to be used as a common
configuration file over mailing lists e.g. to set up command search
path ,tar, gzip, ...

	tar や gzip はどこにある？

等を sitedef.ph に書くと便利でしょう。

site_init.ph は各MLの config.ph の前に評価されデフォールトを決めます。
sitedef.ph は各MLの config.ph の評価後に適用され、各ＭＬの設定を強制的
に書き換えることもできます。それぞれ使いわけると良いでしょう。いずれに
しろ config.ph にない変数であればどちらを使っても同じことです。

sitedef.ph site_init.ph のサーチは
=E
fml (after 2.2.1) searchs sitedef.ph and site_init.ph in the following
order:

				Example
	-----------------------------------------------
	$DIR			/var/spool/ml/elena/
	$ML_DIR/etc/fml/	/var/spool/ml/etc/fml/
	$EXEC_DIR		/usr/local/fml/
	perl standard path	@INC

の順にサーチされます。共通の場所なので
=E
It shoule exist in common directory.

	$ML_DIR/etc/fml/	/var/spool/ml/etc/fml/
	$EXEC_DIR		/usr/local/fml/

のいづれかでしょう。fml 2.2.1 で $ML_DIR/etc/fml/ が先頭になりました。
これはversion up時に/usr/local/fmlの下をいじらなくてもよいようにという
配慮からです。
=E
So it will be either of them. To avoid recnstructuing under
/usr/local/fml in version up, the first location in fml 2.2.1 search
path is $ML_DIR/etc/fml/.

.S	fmlのプロセス(STDINからの読み込みの第一段階)
=E.S	fml.pl process (first stage) 
.l	STDIN->fml

STDIN からの読み込みは第壱段階でハッシュテーブル %Envelope
.k	$Envelope{'Header'}
.k	$Envelope{'Body'}
.k	メールのヘッダ
.k	メールのボディ

=E
fml.pl scans the input mail and splits up it and save them in

	ヘッダ	$Envelope{'Header'}
	ボディ	$Envelope{'Body'}
.xref	%Envelope
=E
	Header	$Envelope{'Header'}
	Body	$Envelope{'Body'}
.xref	%Envelope

に保存されます。この時ボディ(メールの本文)に対しては次のようなチェック
がなされます。

○ 最初の $GUIDE_CHECK_LIMIT 行に対して $GUIDE_KEYWORD のキーワードが
現れるか否か？
メンバー以外からのメールでこのキーワードをキャッチした場合は、ガイドを
送り返してそれ以外のことはしない。
.k	$GUIDE_CHECK_LIMIT
.k	$GUIDE_KEYWORD
.if LANG == ENGLISH
In default fml.pl is not compatible with hml 1.6 (which is a mailing
list server may be used only in Japanese). The following descriptions
are of no means.

If the mode is compatible with hml 1.6, fml.pl checks the body.  Even
though fml.pl is not in the compatible mode, the check routine works
but the result is not used.

* checks the first $GUIDE_CHECK_LIMIT lines to find $GUIDE_KEYWORD.
  If found, FML sends back guide and do nothing except it.
.k	$GUIDE_CHECK_LIMIT
.k	$GUIDE_KEYWORD
.fi

○ 最初の $COMMAND_CHECK_LIMIT 行に対して
.k	$COMMAND_CHECK_LIMIT
.k	$CHADDR_KEYWORD
=E
* fml.pl scans the first $COMMAND_CHECK_LIMIT to change the mode from
distribution to command mode. The trap keyword is 
==
	^#(\s*\w+\s|^\#\s*\w+)
	^#$CHADDR_KEYWORD

	# で始まり、英文字が続く行 (\s*\w+\s|^\#\s*\w+)

	# で始まり、$CHADDR_KEYWORD のキーワード
	が現れる行があるか否か？あった場合はコマンドモードへ移行。

の2つのチェックをしています。それぞれの LIMIT を調節すると、つまり 
LIMIT を 0にすればチェックをしないということになるし、全文すべてをコマ
ンドの対象にすることもできます。デフォールトではそれぞれ最初の3行のみ
を対象にしています。

なお、それぞれのキーワードデフォールトは次のように設定されています。
=E
In default

	$GUIDE_KEYWORD  = "guide";
	$CHADDR_KEYWORD = "chaddr|change-address|change";

.S	fmlのプロセス(第２段階, %Envelopeの処理)
=E.S	fml process (second stage) 

%Envelope にヘッダとボディを読み込んだ後はヘッダの解析プロセスが続きま
す。詳細については次の章を見て下さい。
.xref	%Envelope
.xref	header-custom
=E
After parsing, fml.pl sets up %Envelope, locks into critical region.
Under locked state, fml.pl main part works.
.xref	%Envelope
.xref	header-custom

この後ロックして、メインのプロセスが続くことになります。

.S	fml process の lock と signal handling 
=E.S	fml process, lock and signal handling
.k	$Sigarlm
.k	$TimeOut{'flock'}
.k	$FLOCK_TIMEOUT(Obsolete)
.k	$MAX_TIMEOUT

現在の flock を使うロックアルゴリズムは次のように設定されています。
flock(2) と alarm(3) によるTIMEOUT処理による一般的な方法です。 
sendmail のような alarm(3) ベースの event 駆動をするようにプロセス管理
をしています。

NT4 上では Activestate ntperl を使っています。この ntperl では 
flock(2) は動きます(かなり怪しいという話も聞くが詳細は不明)が alarm(3) 
がないので Win32::Process による wrapper で alarm(3) を emulate してい
ます。emulation といってもTIMEOUTしたら強制終了するだけですが。
=E
fml.pl uses flock(2) and alarm(3). It is standard technique on
UNIX. On Micro$oft Windows NT4 with activestate perl, flock(2) works
but alarm(3) does not work. We emulate it by Win32::Process. Under our
NT4 alarm emulation, timeout equals to "end of process".

sub Flock {

    &SetEvent($TimeOut{'flock'} || 3600, 'TimeOut') if $HAS_ALARM;
	...

TIMEOUTを待つ時間は $TimeOut{'flock'} で決まります。(flock でない場合
は 3秒+α 程度の sleep を $MAX_TIMEOUT 回して待ってみる)

    # signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'}  = $SIG{'QUIT'} = 'SignalLog';

$TimeOut{'flock'} (デフォールトは3600秒)後 $SIG{'ALRM'} で定義された関
数(TimeOut)を実行します。
=E
Flock timeout is defined by $TimeOut{'flock'}, default is 3600 seconds.

関数 TimeOut は管理者へ TIMEOUT を知らせ、ログを残しfmlを終了します。
これがないとずっとロック(flock)がかかったままになるからです。
=E
When timeout occurs, fml.pl notifies it to the maintainer, logs it and
exits. 

なお flock を使わない時はTIMEOUTしたメールを保存し管理者へ TIMEOUT を
知らせます。詳細は liblock.pl を見るとわかるでしょう。
.xref	books
=E
When flock(2) is not used, fml.pl uses link(2) based lock
algorithm. If timeout, fml.pl notifies it and exits. Please see
liblock.pl for more details.
.xref	books

.S	イベント・スケジューラ
=E.S	Event Scheduler
.k	SetEvent
.k	ClearEvent
.k	Tick

TIMEOUT 等は現在実行している処理内容によらず特定の時間が来たら(割り込
んで) 実行する必要がありますがそれは伝統の味 alarm(3) を使って実装しま
す。なお Windows NT 4.0 Version では alarm(3) が使えないのこの処理は実
行されません。
=E
fml.pl uses flock(2) and alarm(3). It is standard technique on
UNIX. Software trap by alarm(3) maintains event scheduling inside FML.
On Micro$oft Windows NT4 with activestate perl, flock(2) works but
alarm(3) does not work. We emulate it by Win32::Process. The emulation
is incomplete for the restriction of ntperl. We only enforce fml.pl
exits if timeout.

.S	ロックの仕方(flock でない場合)
=E.S	Another locking algorithm
.l	how-to-lock
.k	ロックアルゴリズム
.xref	fml-mechanism, seq-file

ロックアルゴリズムは二通り用意されてます。flockがお奨めです。flock(2) 
参照
=E
fml.pl provides two lock algorithms, flock(2) and link(2) based lock
algorithm. In default fml.pl uses flock(2). flock(2) is used if

.key	$USE_FLOCK
	$USE_FLOCK    = 1; (default 1)

で flock system call
=E
link(2) based lock is used if

	$USE_FLOCK    = 0;

で大昔からある link(2) を使う方式を使います。この方式はロックするファ
イルへの link() ができるか否か?を排他制御に使います。このロックするファ
イルは
=E
link(2) style lock is based on whether link(2) works or not. 
The lock file is 

	$LOCK_FILE

という変数で変更できます。デフォールトは $DIR/var/run/lockfile.v7 です。
=E
The default lock file is $DIR/var/run/lockfile.v7

	"$FP_VARRUN_DIR/lockfile.v7"

つまり ML の home の下の var/run/lockfile.v7 です。この方式の問題は OS 
がいきなり落ちた時にこのファイルが残ってしまうので手動でこのファイル群
を消さなければならないという点が最大の問題点です。そのため flock() の
ようなOSが直接ロックを支援する形が望ましいです。
=E
This lock algorithm is not fault tolerant e.g. in sudden death of OS
since the lock file is not removed. After the reboot, maintainer
should remove left lock files.  Just after reboot, remove all files
$FP_VARRUN_DIR/lockfile*. From this view, I recommends you that 
you should use the lock mechanism OS provides.

そういう場合は reboot 直後に

	"$FP_VARRUN_DIR/lockfile.v7"
	"$FP_VARRUN_DIR/lockfile.数字"
.k	$FP_VARRUN_DIR/lockfile.v7

すべてを消して下さい。

fmlの何かプロセスが走っている状態ではどのロックファイルを消していいか
はプロセステーブルを見る必要があります。数字はプロセス番号ですからプロ
セステーブルを見て(ps(1))、該当する数字(fml の process)がなければ、そ
のファイルは消して良いです。

なお link(2) スタイルの場合 $MAX_TIMEOUT 秒後、var/log/ の下にTIMEOUT
したメールは保存され管理者へTIMEOUTが通知されます。
=E
Also in link(2) style, timeout is defined by $MAX_TIMEOUT. The mail is
saved in var/log. fml.pl notifies it to the maintainer.

[捕捉]	flock(2) を見れば分かりますが 
.k	flock(2)
=E
FYI: flock(2)

	$LOCK_SH                       = 1;
	$LOCK_EX                       = 2;
	$LOCK_NB                       = 4;
	$LOCK_UN                       = 8;
.k	$LOCK_SH
.k	$LOCK_EX
.k	$LOCK_NB
.k	$LOCK_UN

.q
     #include <sys/file.h>
     #define   LOCK_SH   1    /* shared lock */
     #define   LOCK_EX   2    /* exclusive lock */
     #define   LOCK_NB   4    /* don't block when locking */
     #define   LOCK_UN   8    /* unlock */

     int
     flock(int fd, int operation)
.~q

排他制御については例えば A. S. Tanenbaum, "Modern Operating Systems" など
=E
See e.g. A. S. Tannenbaum, "Modern Operating Systems" for exclusive locks.


.C	FML 内部におけるデータ構造
=E.C	FML internal data structures
.l	data-structure
.xref	hack

ここでは fml 内部処理におけるデータ構造について解説します。これらの知
識は改造する上で必須の事柄でしょうが、単に変数を 1 or 0 にセットするだ
けしか設定 (config.ph) をいじらないなら読む必要はないでしょう。
=E
Here we describe FML internal data structures. When you hacks FML,
this knowledge is required. However you do not need to read this
chapter if you toggle variables only on/off.

.S	変数名の naming convention
=E.S	Naming convention of variables
.key	変数の Naming Convention

○ 大文字（[A-Z0-9_]+）だけの塊はユーザーのカスタマイズで使う目的の
   Global 変数です。
=E
* ^[A-Z0-9_]+$ name variable is USER DEFINED VARIABLE for customize.
It is a global variable. Fundamentally these variables are defined in
config.ph, sitedef.ph and site_init.ph.

	Example:	$MAIL_LIST

○ "1単語の先頭一文字が大文字、残りは小文字"の塊からなる単語はメー
   ル本体やヘッダをSubroutine間で渡しあうための Global 変数です。
=E
* Capitals are global not for USERS but for systems. In principle
  users should not touch them. If you hacks, it must require to handle
  these variable.

	$MailBody	$Reply_to
	%Envelope	*_cf

	例外： *_cf は システム情報をもっている名前空間です。
	(_cfはほとんど使われていません。将来は消去すべきです)

   %Envelope は最も重要な変数です。
   しかしながら、こういうグローバル変数は本来出来るだけ少なくするべきです。
   また、@Fld にように現在グローバルとして使われていないのに名残として
   残ってしまっているものもあります。
   が、これはもぉこのまま使うしかないようです。
=E
   %Envelope is the most important variable. We should not increase
   the number of global variables. Several variables e.g. @Fld 
   are capital but historically left not as global.

   注意：
	$debug だけは全部小文字でグローバル変数という例外です。
	便利だからというのと、歴史的にそうなっているというだけなので
	今後そういう変数名は作られることはありません。
	また、昔ユーザ定義で今は内部変数扱いになった $ML_MEMBER_CHECK も
	例外です。
=E
  ATTENTION: historically $debug is global for convenience.

○ 小文字は基本的にlocal variableで、大抵はsubroutineの先頭でlocal宣言
   されています。
=E
* Lower case word is local variable. 

○ 補足
なお、Directory を定義する $*_DIR タイプの変数には
=E
[Appendix]
Directory variables consists of two types

	$*_DIR 		$DIR からの相対パス
	$FP_*_DIR 	絶対パス
=E
	$*_DIR 		relative path to $DIR
	$FP_*_DIR 	obsolete path

の２種類があります。 $FP_*_DIR タイプの変数は自動的に変換され定義され
ます。基本的には絶対パスが使われます。$FP_ の変数は fml.pl の初期化で
自動的に補正されつつ設定されます。ほとんど全ての場面で絶対パスを用いま
す。
=E
$FP_*_DIR is automatically defined based on directory variables.
In a lot cases absolute path is used.

	$FP_TMP_DIR
	$FP_VARDB_DIR
	$FP_VARLOG_DIR
	$FP_VARRUN_DIR
	$FP_VAR_DIR
    	$FP_SPOOL_DIR
.k	$FP_TMP_DIR
.k	$FP_VARDB_DIR
.k	$FP_VARLOG_DIR
.k	$FP_VARRUN_DIR
.k	$FP_VAR_DIR
.k    	$FP_SPOOL_DIR

.S	関数名の Naming Convention
=E.S	Naming convention of functions
.k	関数名の Naming Convention

一部の例外を除いて”１単語の先頭一文字が大文字、残りは小文字”の塊から
なる単語です。基本的に subroutine の名前はX11風だったりします。最近の
はlisp風味も混ざってます:-) #おおむねX11風ですね
=E
Except for a few cases, a function name is capitalized. The word after
"_" is also capitalized. It is similar to X11 style:D

○ fml 1.5 以降では若干例外があります。
=E
* Some exceptions remains after fml 1.5.

ファイル操作をする関数で
=E
File operation functions are defined as 

	変換インターフェイスとしての 	f_関数 名
	＃いつか、なくなるだろう
=E
	f_function_name 	conversion interface

		と 

	そのモードのコンストラクタ	Cnstr_関数 名
	そのモードのディストラクタ	Destr_関数 名
=E
	Cnstr_function_name		constructor for this mode
	Destr_function_name		destructor for this mode

が例外です。「将来 replace するべきです」と当時言ったまま replace され
ないままですが:-)
=E
These are exceptional. In that age I should replace these naming
convention but still remains ;D

.S	%Envelope (ハッシュテーブル)
=E.S	%Envelope (hash)
.l	%Envelope
.k	%Envelope
.k	struct envelope e;

%Envelope には今 fml を起動したメールの内容(ヘッダ、ヘッダの各フィール
ド、本文等)が格納されます。また、そのメールに対しどういうMETHODでREPLY
を返すべきか？や、sendmailとの通信等の設定に関しての付加情報も 
%Envelope を通じて渡されます。それはこのメールに対する METHOD の定義と
みなしているからです。
=E
%Envelope is most important variable(hash). %Envelope contains header,
each field of the header, body as a hash table. This hash is passed in
a lot of function calls. It is similar to sendmail's struct ENVELOPE
e;

sendmail の struct envelope e; に対応するものです。
しかし、perl 4 を本来ターゲットにしているため
=E
In the age of FML 1.5, perl 5 does not run. Hence we cannot use
e.g. the following style

	$Envelope->$Header->$From = "uja@domain";

のような使い方はしません(できない)。これと同様のことを意図したシンタッ
クスが
=E
It is represented by

	$Envelope{"h:From:"}  = "uja@domain";

で表現されています。 h = header で From: はわざと Field だとわかりやす
いように : まで含めています。
=E
":" is a separator. From: is a special syntax to identify this key is
a field.

以下 %EnvelopeのKEYについて説明します。
＃ハッシュなので、KEY => VALUE が $Envelope{KEY} の値が VALUE です
=E
Keys of %Envelope:

	h: ではじまるものKEYは「ヘッダの各フィールドのデータ」です。
=E
	KEY beginning with "h:" is a field of a header.

	h:Capital:	補正されたデータ e.g. h:Subject:
	h:lower-case:	オリジナルデータ e.g. h:subject:
=E
	h:Capital:	adjusted field data to use in delivery e.g. h:Subject:
	h:lower-case:	original field data e.g. h:subject:

	それ以外に その Envelope のメールをどういうモードで処理するか？
	や、そのメールへのREPLY、エラーレポート処理をどうするか？
	というMETHODの指定等の付加情報も付け加えることもあります。

	[ヘッダ関係]

	h:field:	上述のヘッダ：フィールド：設定値
=E
	h:field:	header field 
			lower case name is original
			Capital is after changed.

	fh:field:	field(小文字) は fml.pl がある値を強制する
=E
	fh:field:	enforce a field to use this value

			例： fh:to: は To: を $Envelope{'fh:to:'} の値にする

	oh:field:	field は original のヘッダフィールドを使う
=E
	oh:field:	enforce fml.pl to use original field value
			for this field

	GH:field:	コマンドの結果を返すメールは GenerateHeader() という
			ルーチンでメールヘッダを生成する。
			そこでの値を変更したいならこのKEYを使う。
=E
	GH:field:	enforce some value for field of command mail results
			and so on. used in GenerateHeader().

	Addr2Reply:	コマンドの結果の返事を返すアドレス
			reply-to: > From:
=E
	Addr2Reply:	address to send a command result and so on

	[メールが呼び出すべきモードやメソッドのConfig]
=E
	[mode or method configurations]

	macro:x		x は sendmail の $x に対応する内容を保存
=E
	macro:x		corresponds to $x of sendmail

	mode:x		モード設定値 
=E
	mode:x		mode x is enabled.

	mci:mailer	mci は Mail Connection Information (MCI)
			mci:mailer は ipc(SMTP) か prog(exec sendmail)
			のどちらかである
=E
	mci:mailer	Mail Connection Information
			mci:mailer is ipc or prog.

	[内部表現]
=E
	[Internal Data]

	Header		オリジナルのヘッダ
	Body		オリジナルのメール本文
	Hdr		送り出すメールのヘッダ（&Smtpの直前に生成される）
=E
	Header		original header
	Body		original mail body
	Hdr		header of sending mails out in distribute phase	

	message		メールをサーバへ送ったユーザへのメッセージ
	error		管理者への(エラー)メッセージ
=E
	message		message to send back to a sender
			for command results and others
	error		error message to send back to a sender

	MIME		ISO-2022-JP is detected (toggle Flag)
	UnixFrom	Unix From
	Hdr2add		$SUPERFLUOUS_HEADER の時につかうバッファ
	nclines		# command の行数
	nlines		メール本文の行数
	preamble	メール本文の前につける文章
	trailer		メール本文の後につける文章
=E
	MIME		ISO-2022-JP is detected (toggle Flag)
	UnixFrom	Unix From
	Hdr2add		buffer when $SUPERFLUOUS_HEADER is set.
	nclines		number of lines for "# command" style lines
	nlines		lines of mail body
	preamble	preamble to put on mail body
	trailer		trailer to put on mail body

	tmp:x		temporary used


例: Subject:
=E
Example: Subject:

   $Envelope{'h:subject:'} は来たメールそのもの
=E
   $Envelope{'h:subject:'} is 
   an in-coming mail's original Subject: field value. 

   $Envelope{'h:Subject:'} は来たメールの Re: をとり
   必要なら [Elena 100] のようなものを処理したもの
=E
   $Envelope{'h:Subject:'} is after cutting Re:'s and tags e.g. [Elena 100].

のような違いがある。配送されるヘッダと大文字ではじまる単語は次のように
対応する。

配送メールのヘッダ: %Envelope
=E
Example: In a header of distribution, used key of %Envelop is as follow:

        Field           key in %Envelope
	--------------------------------------- 
	Date: 		h:Date:
	From:		h:From:
	To: 		h:To:
	Subject: 	h:Subject:

.S	データ構造の初期化
=E.S	Initialize data structures
.l	init-data-structure
.k	データ構造の初期化

各データの初期化は次の順序で行なわれる。
=E
Initialization of fml.pl is as follows:

	$DIR $LIBDIR @INC の初期化
=E
	initialize $DIR $LIBDIR @INC and so on

	&InitConfig
	   &SetDefaults
		%Envelope
		DNS, @HdrFieldsOrder, and others

	   &LoadConfig
		$DIR/config.ph
		sitedef.ph

   	   &SetOpts
		command line options

	   COMPATIBILITY CODE
   
	&Parse
		%Envelope へ Header Body 等のオリジナルデータをセット
=E
	&Parse
		reset %Envelope
		
	&GetFieldsFromHeader
		%Envelope へ h:field: および h:Field: をセット
=E
	&GetFieldsFromHeader
		analyze %Envelope and set h:field: and h:Field: up.

	&FixHeaderFields
		h:Field: への各種補正を行なう
=E
	&FixHeaderFields
		adjust h:Field:

	&CheckCurrentProc
		%Envelope による設定、動作モードチェック
=E
	&CheckCurrentProc
		adjust fields, check loops, modes and so on

	この後各種フックがそれぞれの場所で評価される。
=E
	After this fml.pl sets in the main routine,
	hooks are evaluated in several locations.

	Example:
		$START_HOOK
		$SMTP_OPEN_HOOK
		$FML_EXIT_HOOK

この後ロックされ、ロック下でクリティカルな作業が行なわれる。作業が終る
まで alarm(3) による割り込み以外ではこのロックははずれない。
=E
After this, the critical section begins. 

.S	ディレクトリ変数
=E.S	Directory variables
.xref	fml-process

起動時の一番最初の段階では $DIR $LIBDIR @INC という変数の設定を筆頭に
各種変数の初期化が行なわれます(上述)。$DIR $LIBDIR @INC が起動時にどう
評価され使われているかは「fml の基本動作と起動オプション…」の章を見る
と分かるでしょう。
.xref	fml-process

以下では DIRECTORY 一覧を示します。
=E
[Directory variable list]
		
	@INC	(参考)
		これは Perl の include file の search path
		$DIR @INC(original) $LIBDIR ...
		の順番に探される。

	$DIR
		config.phのある場所、いわゆるMLのHOME	
		@INC の先頭に設定される
=E
	$DIR
		config.ph location. ML's HOME directory.
		The argument of @INC.

.if LANG == JAPANESE
	$LIBDIR	
		fml.pl や libsmtp.pl 等の置き場所。
		$DIR と同じでも良いし、別の場所で保守されていてもよい。
		もともと複数のＭＬを扱うためにスプールと *.pl ファイル
		群の置き場所をわけるために導入された。@INC の最後に入る。

		なおコマンドラインに出てくるdirectoryはすべて @INC に
		設定されるが、$DIR の直後の directory が $LIBDIR に設
		定される。

		@LIBDIR にも入っている
.fi
.if LANG == ENGLISH
	$LIBDIR	
		library paths. @LIBDIR is a list of $LIBDIR's.
		fml pushes $LIBDIR to @LIBDIR.
		fml searches @LIBDIR for executable and libraries
.fi

    	$SPOOL_DIR		$DIR/spool
		ＭＬの記事を格納する場所
=E
    	$SPOOL_DIR		$DIR/spool
		spool of articles of ML

	[$DIRからの相対パスで設定されるもの]
=E
	[Relative path from $DIR]

.if LANG == JAPANESE
	$TMP_DIR		tmp (temporary)	4.4BSD の /tmp
	$VARDB_DIR		4.4BSD の /var/db (データベース)
	$VARLOG_DIR		4.4BSD の /var/log に対応 ログが置かれる
				backward compat のため
				log 等のデフォールトは $DIR/log のままである
				(本来は $VARLOG_DIR/log が望ましいだろうが)
	$VARRUN_DIR		4.4BSD の /var/run pid-file 等はここ
				なお cache もここにおいている。
	$VAR_DIR		4.4BSD の /var
.fi
.if LANG == ENGLISH
	$TMP_DIR		tmp (temporary)
	$VARDB_DIR		var/db  (database, 4.4BSD like)
	$VARLOG_DIR		var/log (log, 4.4BSD like)
				$DIR/log is exceptional for backward 
				compatibility.
				($VARLOG_DIR/log is preferable)
	$VARRUN_DIR		var/run (4.4BSD like)
				pid's file and several caches
	$VAR_DIR		var (4.4BSD like)
.fi

	[FULL PATH 化された変数]
=E
	[Corresponding fully pathed directory variables]

	$FP_TMP_DIR		$DIR/$TMP_DIR
	$FP_VARDB_DIR		$DIR/$VARDB_DIR
	$FP_VARLOG_DIR		$DIR/$VARLOG_DIR
	$FP_VARRUN_DIR		$DIR/$VARRUN_DIR
	$FP_VAR_DIR		$DIR/$VAR_DIR
    	$FP_SPOOL_DIR		$DIR/$SPOOL_DIR

.S	$TMP_DIR について
=E.S	On temporary directory ($TMP_DIR)
.key	$TMP_DIR

ＭＬサーバの作業エリアにはデフォールトでは $DIR/tmp (つまり $TMP_DIR =
'./tmp';) を使います。変更したい場合は $TMP_DIR を変更して下さい。
=E
$DIR/tmp is temporary working area. It is defined as $TMP_DIR. We
should not use the system's /tmp or /var/tmp if the file is left when
OS crashes.

/tmp とか /usr/tmp とかは万が一ファイルが残ると嫌なので使いません。
private communication のファイルを public な場所にファイルを残すことは
しないためです。

その他にも 4.4BSD 風の directory 構造の中に各種のログやキャッシュが保
存されます。

.S	設定ファイル群
=E.S	Configuration files
.xref	fml-file-structure

[メンバーのリスト関係]
=E
[Member Lists]

	$MEMBER_LIST 	 	$DIR/members
.l	$MEMBER_LIST
.k	$MEMBER_LIST
.xref	fml-file-structure

	メンバーリスト(認証のみに使う)
=E
	the ML member list for authentication. If a given address is
	not in this list, fml.pl does not authenticate the
	address. This is not a delivery list in non automatically
	registration mode. In automatic registration mode, this file
	is both a member and delivery list.

	$ACTIVE_LIST 		$DIR/actives
.l	$ACTIVE_LIST
.k	$ACTIVE_LIST
.xref	fml-file-structure

	ＭＬの配送リスト
=E
	list of distribution in non automatically registration mode.

	$REJECT_ADDR_LIST	$DIR/spamlist
.k	$REJECT_ADDR_LIST
.xref	$REJECT_ADDR_LIST

	投稿/コマンド/自動登録をはじめとして全ての場合について、弾きた
	いアドレスのリスト。自動的に登録する機能もある。
=E
	list to reject as a spammer.

[各種の説明、ご案内関係のファイル]
=E
[files of guides and so on]

	$OBJECTIVE_FILE	 	$DIR/objective
.l	$OBJECTIVE_FILE
.k	$OBJECTIVE_FILE

	ＭＬの目的を書いたファイル
=E
	objective of ML

	$GUIDE_FILE		$DIR/guide
.l	$GUIDE_FILE
.k	$GUIDE_FILE

	ＭＬの一般向けご案内（ガイド）
=E
	guide for general people (for not member)

	$HELP_FILE	 	$DIR/help
.l	$HELP_FILE
.k	$HELP_FILE

	ＭＬのHELP、コマンドの解説等
=E
	help file of ML (for only member)

	$DENY_FILE	 	$DIR/deny
.l	$DENY_FILE
.k	$DENY_FILE

	ＭＬがメンバーチェックをしている時
	メンバー以外からメールが来た時に返す断りの文章
=E
	file to send back when fml.pl rejects mail from a non member.
	This is not used in auto registration mode.
		
	$WELCOME_FILE	 	$DIR/guide
.l	$WELCOME_FILE
.k	$WELCOME_FILE
.xref	auto-regist

	ＭＬが自動登録の時、登録時に送ってあげる文章
=E
	file to send back in auto-registration mode when 
	a user is automatically registered. 

	$CONFIRMATION_FILE       $DIR/confirm
.l	$CONFIRMATION_FILE
.k	$CONFIRMATION_FILE
.xref	confirmation

	自動登録で confirmation モードの際 reply を返す 
	confirmation の説明のファイル
=E
	confirmation file in auto-registration mode.
	Please see confirmation (.ptr{confirmation}).

[ログファイル関係]
=E
[Logfiles]

	$LOGFILE	 	$DIR/log
.l	$LOGFILE
.k	$LOGFILE

	ログ
=E
	log file

	$MGET_LOGFILE    	$DIR/log
.l	$MGET_LOGFILE
.k	$MGET_LOGFILE
.xref	mget

	mgetのログ。デフォールトでは↑ログファイルと同じ
=E
	mget log. In default $MGET_LOGFILE == $LOGFILE.

	$SMTPLOG		$VARLOG_DIR/_smtplog
.l	$SMTPLOG
.k	$SMTPLOG
.l	$VARLOG_DIR/_smtplog
.k	$VARLOG_DIR/_smtplog

	プロセス間通信(SMTP)のログ(デバッグの役に立つ)
=E
	Log of SMTP (for debug).

	$SUMMARY_FILE 	 	$DIR/summary	
.l	$SUMMARY_FILE
.k	$SUMMARY_FILE

	MLの記事のサマリ
=E
	summary of ML

	$SEQUENCE_FILE 	 	$DIR/seq
.l	$SEQUENCE_FILE
.k	$SEQUENCE_FILE

	MLの記事番号
=E
	ML's sequence number

	$MSEND_RC		$VARLOG_DIR/msendrc
.l	$MSEND_RC
.k	$MSEND_RC
.xref	msend

	まとめおくりの制御ファイル
=E
	digest control file.

	$LOCK_FILE	 	$VARRUN_DIR/lockfile.v7
.l	$LOCK_FILE
.k	$LOCK_FILE

	flock() を使わない時のロックで使うファイル
=E
	lock file when not flock(2) lock but link(2) based.

	$LOG_MESSAGE_ID		$VARRUN_DIR/msgidcache
.l	$LOG_MESSAGE_ID
.k	$LOG_MESSAGE_ID

	message-id cache ファイル
	(ML自身での無限ループを防ぐためのキャッシュ)
=E
	Message-Id cache file to prevent loops.

	$MESSAGE_ID_CACHE_BUFSIZE
.l	$MESSAGE_ID_CACHE_BUFSIZE
.k	$MESSAGE_ID_CACHE_BUFSIZE
	
	Message-ID cache ファイルサイズ
=E
	Message-ID cache file size

	$INDEX_FILE		$DIR/index
.l	$INDEX_FILE
.k	$INDEX_FILE

	このファイルはなくても構わない。indexコマンドで表示したい内容
	を書く。このファイルがない場合はその場でMLのHOME内容を調べて返
	す。
=E
	Fml.pl works without this file. If exists, "index" commands
	sends back this file. If not, FML scans $SPOOL_DIR,
	@ARCHIVE_DIR and sends back the summary.

.S	単に便利なためにある変数
=E.S	Other useful variables

	$DO_NOTHING
.l	$DO_NOTHING
.k	$DO_NOTHING

	何もしないという分岐をするための変数。特殊なサーバを作る時や
	特別なHOOKをかけたりする場合に有用である。
=E
	Special flag to declare "do nothing".

	$NULL
.l	$NULL
.k	$NULL

	ダミー:-) ＃ 別にこんな変数いらない 
	#define null (char *)0 みたいなものだと思ってもらえば良い
=E
	dummy:D like "#define null (char *)0".

	$FML	
.l	$FML	
.k	$FML	

	カーネル内のプロセステーブルを書き変える際に使う変数
=E
	process table name

	$FACE_MARK
.l	$FACE_MARK
.k	$FACE_MARK

	(単なる愛敬:-)。各種リクエストの結果を返す時にお別れの文章の腋につける
	e.g. 	P(^^)
		Be seeing you P(^^)
	のようになる。
=E
	appended in the reply message, e.g. command results.

	$INCLUDE_SIM_PATH
.l	$INCLUDE_SIM_PATH
.k	$INCLUDE_SIM_PATH

	Simulation で使う。気にしないで下さい:)
=E
	Please ignore this. This is used in simulation.

	$UNISTD
.l	$UNISTD

	Declare "Unix Standard" flag. undefined on Windows NT4

	$LOCKFILE
.l	$LOCKFILE

	lock file variable in some libraries. It may be uncontrolled
	by a user.

	%MAKE_FML
.l	%MAKE_FML

config.ph に現れるハッシュ %MAKE_FML は makefml で使うためのものです。
makefml 以外では使われません。現在では使われていません、無視して下さい。
.k	%MAKE_FML
=E
Please not touch %MAKE_FML in config.ph which variable "makefml" uses
though it is not used today.

○ 古い変数として他の名前に置き換えられたもの
.k	$GUIDE_REQUEST
.k	$RPG_ML_FORM_FLAG
=E
* obsolete variables (renamed to)

   $GUIDE_REQUEST	-> $GuideRequest
   $RPG_ML_FORM_FLAG	-> $COMMAND_SYNTAX_EXTENSION

○ obsolete なもの
=E
* obsolete

   $NON_PORTABILITY

.S	内部で使われている変数を調べるには？
=E.S	Listing variables list
.k	$DUMPVAR
.k	dumpvar.pl

config.ph で 
=E
To dump variable used in fml.pl (by dumpvar.pl), sets 

	$DUMPVAR = 1;

やコマンドラインで

	fml.pl --DUMPVAR 引数

として fml を呼び出すと全ての変数を dump します。この場合はPerlについ
てくる dumpvar.pl ライブラリを利用し、名前空間から変数リストを引っ張り
出しています。

ちなみに fmlserv.pl は同様のやり方で名前空間の switch を利用して複数の
ＭＬを疑似的に実行しています。
=E
FYI: fmlserv.pl uses the same technique to switch name spaces.


.C	FML 設定ファイルのフォーマットと構造
=E.C	FML configuration files, formats and structures
.l	fml-file-structure
.k	fml 設定ファイルのフォーマットと構造

fml の設定ファイル、メンバーリストは基本的に shell like な構造で記述さ
れていると期待されています。つまり基本的に # ではじまる行はコメント、
空行は飛ばす等の挙動を各ルーチンはしています。
=E
Lists used in FML assumes shell like structures:
	a line with "#" is comment.
	skip null lines.

以下では各設定ファイルのフォーマットについて言及します。

.S	members ファイルのフォーマットと構造
=E.S	members file formats
.k	members ファイルのフォーマットと構造

2.2 では以前と異なり一般ユーザには下のようなフォーマットは見えません。
すでにいなくなったメンバーの情報をだすべきではないからです。管理者には
後述する生のフォーマットが見えてしまいます。一応知っておいて下さい。
=E
Fml 2.2 REL provides the raw format to administrators but not raw
format to general users since general users should not know members
which unsubscribed the ML in the past. Please remember the following
format if you are an administrator.

$MEMBER_LIST (default members) で定義されるファイルは
=E
The format of $MEMBER_LIST (default members) is

.if LANG == JAPANESE
	#.FML
		…fml が自動的につけるコメント…
	#.endFML
	アドレス1
	アドレス2
	# アドレス3
	##BYE アドレス4
	アドレス5
.fi
.if LANG == ENGLISH
	#.FML
		comments put by fml
	#.endFML
	address-1
	address-2
	# address-3
	##BYE address-4
	address-5
.fi

のような形をしています。歴史的理由により現在では

   # の後空白 でコメントアウトされていてもメンバーチェックの対象になる
   ## ではじまるところはコメント
=E
   "# something" syntax is comment out but used for member check. 
   But it is not used for delivery.
   "##something" syntax is real comment out.

となっています。よって上の例では ##BYE の行は無視されますが、それ以外
の アドレス1 〜 アドレス5 (4を除いて) すべてがメンバーチェックの際には
対象となります。
=E
Hence fml.pl ignores "##BYE address-4" line but address-1,2,3,5 is
candidates for ML members. fml.pl compares a sender (From: line's
address) and address-1,2,3,5 for member check.

［歴史］
この動作は 1.2 release version の直後、自動登録を拡張する際に導入され
ました。またこの導入のため # off と # skip はどう違う？という疑問がそ
の後生まれることになりました。

なおメンバーファイルとしては各行のアドレスより後ろの部分は
何にも使われていませんので、勝手に使って構いません。

しかしながら、自動登録の場合は $MEMBER_LIST と $ACTIVE_LIST は同じもの
（$MEMBER_LIST）が使われます。よってそのフォーマットは $ACTIVE_LIST 形
式であると仮定する必要があります。

.S	actives ファイルのフォーマットと構造
=E.S	actives file formats
.k	actives ファイルのフォーマットと構造

$ACTIVE_LIST (default actives) で定義されるファイルは ＄MEMBER_LIST と
同様の構造を持ちます。
=E
$ACTIVE_LIST (default actives) has a format similar to $MEMBER_LIST.

しかし actives ファイルは拡張された表現として各アドレスのオプションを
行の残りの部分に持つことができます。
=E
The format is 
	address		options		# comments

	アドレス	オプション	# コメント

	注意：なお、それぞれの↑ブロックの間には必ず一つ以上の SPACE
	か TAB があると仮定しています。

よって勝手に何かを書いた場合オプションとみなされます。付加情報は # コ
メント として行の最後にでも書いて下さい。この辺は shell と同じです。

.if LANG == JAPANESE
オプションは V1 と V2 フォーマットがあります。

   V1 フォーマットは

	数字(フォーマット)	まとめおくりの指定
	数字以外		リレーサーバ

   V2 フォーマットでは将来の拡張のため

	m=まとめ送り指定
	r=リレーサーバ
	s=1(skip を意味する)

のように alphabet=option-value の形で定義されています。現在のところこ
れ以外のキーワードは将来のために予約されています。
.fi
.if LANG == ENGLISH
* available options:

	m=digest-options
	r=relay-server
	s=1 (skip)
.fi

現在のルーチンは V2 のみを理解します。よって V1 -> V2 に変換する必要が
あります。この変換は

	libfml.pl で ChangeMemberList が呼ばれた時

つまりメンバーリスト等へのなんらかの変更を行なう時に自動的に行なわれま
す。

.S	actives と members の違い
=E.S	Differences between $ACTIVE_LIST and $MEMBER_LIST
.k	actives と members の違い

フォーマット的には上述の通りです。後は自動登録の章で述べられている通り
members はメンバーであるか否か？の認証、 actives は配送リストです。
=E
Please see above on formats. For functions see the chapter on
automatic registration (.ptr{auto-regist}).  $MEMBER_LIST is used to
compare a sender (From: address) and addresses in lists to check the
sender is a member or not.  $ACTIVE_LIST is a list to distribute.
Under automatic registration (not auto_asymmetric_registration),
$MEMBER_LIST == $ACTIVE_LIST internally, fml does not read
$ACTIVE_LIST.

自動登録では members 一つを認証と配送リスト両方に使っています。そのた
め表現の拡張が必要だったわけです。

.S	複数のメンバーリスト、複数の配送リスト
=E.S	Plural member lists and delivery lists
.l	@ACTIVE_LIST
.l	@MEMBER_LIST
.k	@ACTIVE_LIST
.k	@MEMBER_LIST

	@ACTIVE_LIST	複数の配送リスト
	@MEMBER_LIST	複数のメンバーリスト

を定義できます。地方ごととか組織ごとにリストを管理するのに便利かも知れ
ません。
=E
You can define arrays
==
	@ACTIVE_LIST	plural member lists
	@MEMBER_LIST	plural delivery lists

デフォールトでは @ACTIVE_LIST は $ACTIVE_LIST と同じになります。
@MEMBER_LIST は members と members-admin です。
=E
fml automatically put $ACTIVE_LIST to @ACTIVE_LIST and uses
@ACTIVE_LIST as a distribute list. In the same way for MEMBER_LIST.

歴史: 最初に管理者を設定して後はリモートですべてをおこなうという目的の
ために拡張されました。

***
actives members のバックアップについて => .ptr{list-turn-over}
=E
turn over actives/members list => .ptr{list-turn-over}

.##########
.include member_name.wix
.##########

.S	msendrc ファイルのフォーマットと構造
=E.S	$MSEDN_RC format (digest control file msend.pl uses)
.k	msednrc ファイルのフォーマットと構造

msendrc は $MSEND_RC で定められる場所におかれます。そのフォーマットは
=E
$MSEND_RC is used by msend.pl, the digest delivery program. The format
is

	アドレス	次回に送る最初の記事番号
=E
	address		the first sequence number to send in the next digest.

です。msednrc は msend.pl が制御するログファイルです。msend.pl は 
$ACTIVE_LIST を見て、

.if LANG == JAPANESE
	・あるアドレスがまとめ送りになった
		そのアドレスのエントリを msendrc 内に新しく作る

	・あるアドレスがまとめ送りで”なくなった”
		そのアドレスのエントリを消去

	・まとめおくりを配送した
		次回に送る最初の記事番号を msendrc に記録する		
.fi
.if LANG == ENGLISH
	msend.pl 
	* generates new user entries.
	* updates msendrc if digest is sent.
	* removes entry if the mode for a user 
	  is changed to real time delivery.
.fi

ということを msendrc に対して行ないます。msend.pl 以外のプログラムが 
msendrc をいじることはありません。
=E
Only msend.pl control this file. 

.S	パスワードファイルのフォーマットと構造
=E.S	Password file format
.k	パスワードファイルのフォーマットと構造
.l	etc/passwd
.xref	bin/passwd.pl remote
.k	$PASSWD_FILE
.k	$DIR/etc/passwd

リモート管理の時の認証で用いるパスワードを保存しているファイルは
$PASSWD_FILE でデフォールトでは $DIR/etc/passwd です。フォーマットは
.xref	remote
=E
Password file ($PASSWD_FILE, in default $DIR/etc/passwd) format is

	アドレス	cryptされたパスワード
=E
	address		crypted-password

です。つまり UNIX 伝統のパスワードファイル形式の先頭の２つが空白で区切
られたものです。＃crypt(3) についてはマニュアル参照
=E
FML can use MD5 password format file if you set

	$REMOTE_ADMINISTRATION_AUTH_TYPE = "md5";
.xref	$REMOTE_ADMINISTRATION_AUTH_TYPE

と設定されている時は fml.pl の crypt 関数は crypt(3) ではなく MD5 の値
を返すようになります。これは MD5.pm を用いた実装なので perl 5 であるこ
とと MD5-1.7.tar.gz のインストールが必要です。MD5.pm のソースは fml の 
directory に一緒に置いてあります。
=E
This uses MD5.pm, so you must use perl 5. 

admin コマンドには initpass というパスワード初期化コマンドがあります。
あるアドレスをこのファイルへ登録する時などは makefml passwd を使うと良
いでしょう。makefml の使い方については INSTALL ファイルを参照。
=E
To initialize a new password, you can use "makefml passwd ML" and 
"admin initpass" command is available when remote administration.
Please see INSTALL for more details how to use makefml.

.S	FMLインストール後の maintenance と version up に関して
=E.S	Maintenances
.l	fml-maintenance
.k	How to maintain the installed fml source
.k	インストール後のメインテナンスとversion up
.k	version up
.k	maintenance

.if LANG == JAPANESE
install は makefml install を使います。version up も同様にして下さい。
というのはインストールするOSなどに依存することがあるので、makefml
install を使うべきだからです。なにをやっているか知っている人は別に cp 
でも構いません:)

version up の仕方は、例えば次のようになるでしょう。

	% cd /var/tmp
	% tar zxvf fml-current.tar.gz
	% cd fml-version番号他の名前
	% make install

以下では例として
	/usr/local/fml に executable
	/var/spool/ml/elena に elena ML
ということにしましょう。

makefml install はいつでも /usr/local/fml に executable やライブラリを
入れるだけです。version up の際に違うことは既にあるＭＬ群に対してロッ
クをしてからインストール作業を行なうことだけです。/var/spool/ml/elena 
の下つまり config.ph 等は変更を受けません。

fml.pl を筆頭に lib*pl 群は overwrite されますから自分でいじってしまっ
ている場合は一旦バックアップを取っておくことが必要です。

メインテナンスを楽にするにはコマンドのパスやＭＬ全体共通の設定はファイ
ルに全部書いておくべきだし、可能な限りHOOKなどにするべきです。例えば

	$HOME/libexec/fml/sitedef.ph 
.k	sitedef.ph 

で行ない各ＭＬごとの設定は

	$HOME/w/spool/fml-support/config.ph 
.k	config.ph 

で制御するなどの運用ポリシーを立てておくことも大事です。
.fi
.if LANG == ENGLISH
Let the configuration be like this 

	/usr/local/fml		executable and libraries
	/var/spool/ml/elena	elena ML home

"makefml install" installs executables and libraries to /usr/local/fml
and makes directory /var/spool/ml if it does not exist. makefml does
not touch files under /var/spool/ml/elena.  In version up, makefml
locks /var/spool/ml/elena before installing. It is just a difference
between initial installation and version up.

How should we maintenance mailing lists? You should set up all
configurations in files, config.ph, site*ph and uses hooks as could as
possible not hack original libraries. If you hack fml sources, version
up working overwrites them.  It is also useful for common settings in
ML's are /usr/local/fml/sitedef.ph or /usr/local/fml/site_init.ph.
.fi


.C	Security 
.l	security

.S	Security 関係の基本思想
=E.S	On security

基本的に

   1	デフォールトではすべてを認めない
   2	大丈夫と思われるものを通すようにする
   3	疑わしきものははじいて判断をＭＬの管理者へあおぐ

という風に構成されています。
=E
Fundamentally
	1	deny all
	2	permit explicitly things we believe as secure 
	3	ask ambiguous situations to a maintainer
		e.g. insecure syntax commands?

.S	Security Check Routine
.l	SecureP
.l	InSecureP
.k	InSecureP
.k	SecureP

ファイアウォールでも同様ですが、概念的に２種類の考え方が出来ます。

	1 明らかに危ないものを除いていく
	2 安全なものを許可していってそれ以外は拒否する
=E
Two security policy concepts for security are typical.
==
	1 deny all, permit secure conditions
	2 permit all, deny known insecure conditions.

fml は 1 のポリシーを採用しています。fml-support: 00950 でも述べていますが
=E
fml works under policy 1.

	1.x は外掘から埋める方式 (関数 InSecureP)
	2.y は内掘から埋める方式 (関数 SecureP)

といってます(^^)。1.x と 2.y の関係はそのまま 上の 1 と 2 の違いといっ
て間違いありません。

SecureP は以下のように『コマンドとしてうけいれる命令(メールの一行全体
について実行)の形を限定』します。
=E
&SecureP function checks under the policy "1 deny all, permit secure
conditions". It restricts the fml command syntax. The rule is

.if LANG == JAPANESE
    １ 	\w/\w の部分は見逃す。＃ ../ とか .[a.]/ とかはだ〜め
       	/ でOKのところは消去する
	また、まとめ送り等の m=数字 等の特別なシンタックスは消去する。
    
    ２ 	/^[\#\s\w\-\.\,\@\:]+$/

    の形はゆるす。
    ＃注意： \w は [A-Za-z0-9_] なので、 "-" を加えた

    [Extension]
	ユーザの拡張用に %SECURE_REGEXP というハッシュが用意されています。
	このハッシュ(KEYは適当でよい)のいずれかの正規表現
	にマッチしたら、ＯＫになるように動きます。
	これは YOUR OWN RISK で定義して下さい。
.l	%SECURE_REGEXP
.k	%SECURE_REGEXP
.k	SecurePの拡張: %SECURE_REGEXP

	逆に %INSECURE_REGEXP ハッシュはまずいパターンを記述できます。
.l	%INSECURE_REGEXP
.k	%INSECURE_REGEXP
.k	SecurePの拡張: %INSECURE_REGEXP


    ３ 	これ以外を含んでいたらエラー

    ４ 	特殊なケース（admin コマンドの admin addr m=3) は
	事前に例外処理をした後 &SecureP にまわす。

例：	許される例

   summary
   mget 1-20,30,last:20 mp 1
   mget 10? mp 1			(default では許さない)
   mget 1[012]? mp 1			(default では許さない)
   chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp 


例：	許されない例
   mget `domainname`
.fi
.if LANG == ENGLISH
    1 	ignore \w/\w , deny both ../ and .[a.]/
	permit special command syntax m=\d+.

    2   permit /^[\#\s\w\-\.\,\@\:]+$/

    3   A user can use %SECURE_REGEXP hash table.
.l	%SECURE_REGEXP
.k	%SECURE_REGEXP
.k	SecureP Extension: %SECURE_REGEXP

	Example:
	$SECURE_REGEXP{'whois'} = 
	'\s*whois\s+\033\$[\@B][\041-\176]+\033\([BJ]\s*';

	%INSECURE_REGEXP to reject special patterns, 
	which you think as insecure.
.l	%INSECURE_REGEXP
.k	%INSECURE_REGEXP

    4   errors if syntax contains others.

Example: 

   summary				(permit)
   mget 1-20,30,last:20 mp 1		(permit)
   mget 10? mp 1			(denied in default)
   mget 1[012]? mp 1			(denied in default)
   chaddr fukachan@phys.titech.ac.jp fukachan@beth.phys.titech.ac.jp (permit)
.fi

例外処理として:

   whois 日本語

をどうしよう？という問題があります。今のところ”通さない”設定のままで
すが、これはこれで何とかするべき問題なのですが、良い解決策はありません。
.l	whois-security
.k	whoisと日本語の問題

例：	許されるパターンを拡張する例(%SECURE_REGEXPを使う)

   $SECURE_REGEXP{'whois'} = '\s*whois\s+\033\$[\@B][\041-\176]+\033\([BJ]\s*';

   ＃注意:
   ＃このパターンを調べるべき対象の文字列全体にマッチさせるので
   ＃最後のスペース等がありうるのなら、それらも考慮する必要がある


[捕捉] 許されるコマンドのシンタックス
シェルと関係しています。
=E
The pattern is related with UNIX shell.

Quoted from 4.4BSD:/usr/share/man/cat1/sh.0 
.q
       Shell Patterns

       A pattern consists of normal characters, which match them-
       selves, and meta-characters.   The meta-characters are
       ``!'', ``*'', ``?'', and ``[''.  These  characters lose
       there special meanings if they are quoted.  When command
       or variable substitution is performed and the dollar sign
       or back quotes are not double quoted, the value of the
       variable or the output of the command is scanned for these
       characters and they are turned into meta-characters.

       An asterisk (``*'') matches any string of characters.   A
       question mark matches any single character. A left bracket
       (``['') introduces a character class.  The end of the
       character class is indicated by a ``]''; if the ``]'' is
       missing then the ``['' matches a ``['' rather than intro-
       ducing a character class.  A character class matches any
       of the characters between the square brackets.   A range
       of characters may be specified using a minus sign.  The
       character class may be complemented by making an exclama-
       tion point the first character of the character class.

       To include a ``]'' in a character class, make it the first
       character listed (after the ``!'', if any).  To include a
       minus sign, make it the first or last character listed
.~q

NOTE: 1998/11/08 permit "admin add MAR+KUN@DOMAIN " syntax

  +'ed user <addr+ext@domain> (for sendmail users):
	fix to permit this address syntax when automagic registration.
	but not fix to permit command with this addr beautifully.
	# so require more eloborate design

  +'d ユーザのアドレス体系を扱えるように修正


.S	投稿メールのサイズの制限
=E.S	Limit of size for a posted article
.n	mail_size_limit

あまり大きいメールを送られてもサーバもメンバーの端末でも負荷が高くなる
だけです。ＭＬサーバーが受けとる時に切り捨てます。コマンド、投稿を問わ
ずチェックされます。デフォールトは制限なしで、サイズは byte 単位で
=E
You can restrict a posted article size. The maximum size is defined by

		$INCOMING_MAIL_SIZE_LIMIT
.k		$INCOMING_MAIL_SIZE_LIMIT
.l		$INCOMING_MAIL_SIZE_LIMIT

で指定します。なお0は無限大を意味します(デフォールト)。
=E
where the unit of this variable is "bytes". If

		$NOTIFY_MAIL_SIZE_OVERFLOW (default 1)
.k		$NOTIFY_MAIL_SIZE_OVERFLOW
.l		$NOTIFY_MAIL_SIZE_OVERFLOW

が設定されていれば送り主に fml が拒否した旨をメールで返します。
経験的には知らせないと何度も非常に大きいメールを送ってくるので
非常に迷惑です。
=E
is set, fml notifes the rejection to the sender.

message/partial はばらばらにされて送られてくる分の合計のサイズを推定し
てその値と $INCOMING_MAIL_SIZE_LIMIT を比較します。
(最後の一通が突破する可能性はある)
=E
If message/partial style mail is given, fml speculates the total size.
fml rejects it if the speculated total size is over
$INCOMING_MAIL_SIZE_LIMIT.

=E
If 

		$ANNOUNCE_MAIL_SIZE_OVERFLOW (default 0)
.k		$ANNOUNCE_MAIL_SIZE_OVERFLOW
.l		$ANNOUNCE_MAIL_SIZE_OVERFLOW

を 1 に定義すると、ＭＬに「でっかいメールをＭＬへ投げた人がいる」とさ
らしものにする:)。＃本人に警告すれば十分だとおもうんだが…
=E
is defined, announce "somebody sends too big mail to ML" to ML.

.S	ＭＬのメンバー数制限(自動登録の時)
=E.S	Limit of the number of members in a ML

	$MAX_MEMBER_LIMIT
.k	$MAX_MEMBER_LIMIT

でメンバーの最大数を制限する。認証するメンバーのリストではなく、配送の
リストをチェックしています。もっとも自動登録の時はほとんど同じことですが
=E
is the maximum number of members. It may be useful in automatic
registration mode.

.S	DNS Spoofing
.l	DNS Spoofing
.k	DNS Spoofing
.k	$LOG_CONNECTION
.l	$PeerAddr
.k	$PeerAddr

デフォールトでは何もしていませんが $LOG_CONNECTION がONの時は
=E
If

	$LOG_CONNECTION = 1;

コネクションを張ってきた相手先のIPアドレスを $PeerAddr に設定します。
firewall 越しだったりすると無意味ですが…$PeerAddr という変数に相手の
ホストのIPアドレスが保存されます。$PeerAddr を使って DNS Spoofing
Check コードをHOOK掛ければよいでしょう。
=E
is defined, fml.pl logs the host address connecting to fml.pl running
server. The value is taken by getpeername(). The result is set in
$PeerAddr. You can use DNS check by this.

.S	Address Spoofing
.l	Address Spoofing
.k	Address Spoofing

これは無理っす。もっと下のlayerで何とかしてね。
=E
no answer since this spoof is in low layers.

.S	SYN Flooding
.l	SYN Flooding
.k	SYN Flooding

これもカーネルレベルの話。根本的な対策は難しい。
=E
no answer in lower layers.

.S	Email アドレスの表現とRFC822
=E.S	Email address and RFC822 representation
.k	Email アドレスの表現
.k	RFC822

.if LANG == JAPANESE
	From: なんか / なんか (なんか)

とかいう怪しげなフィールドを作ると経路の途中でエラーになって、その先に
配送されないことがあります。securiity 関係の話なので詳しいことは説明し
ませんが…

それは(設計思想として)「疑わしきものははじく」ということから来ています。
sendmail のソースを読めばなぜ弾くのか理解できます。

RFC822 はBNF表現でできる理論限界を表現している文書です。確かに使っても
構わないのですが、表現のクラスをかなり制限したアドレスを使っていないと
通信できない可能性はあります。

では、どういうものならよいのか？というとすべてを網羅した表現はうまくで
きませんが…
.fi
.if LANG == ENGLISH
For example, a famous fwtk firewall toolkit checks address
syntax. RFC822 permits a syntax but it may be insecure related to
sendmail's implementation.

RFC822 is theoretical limit of representation. The syntax does not
corresponds to usually used syntax.
.fi

.S	smrsh.c
.k	smrsh.c

smrsh.c は、
	"|program ..."
の program が何を実行するか？ではなく program の名前が /usr/adm/sm.bin 
の中にあるかどうか？を見ています。＃ access(2) で、
=E
smrsh.c restricts executables run by sendmail. For example you can
restrict executables only in /usr/adm/sm.bin runs under this system.
In this case you should rewrite include file /usr/adm/sm.bin/fml.pl.
smrsh.c is in sendmail packages.

よって、/usr/adm/sm.bin/fml.pl ですね:-)

.S	access(2) 
.k	access(2) 

smrsh.c は access(2) を使っていますが…うぅ

=E
smrsh.c uses access();D but ...

--- NetBSD 1.2REL /usr/share/man/cat2/access.0

CAVEAT
     Access() is a potential security hole and should never be used.

4th Berkeley Distribution     September 15, 1996                             2

--- perl5.003/perl.c

	/* On this access check to make sure the directories are readable,
	 * there is actually a small window that the user could use to make
	 * filename point to an accessible directory.  So there is a faint
	 * chance that someone could execute a setuid script down in a
	 * non-accessible directory.  I don't know what to do about that.
	 * But I don't think it's too important.  The manual lies when
	 * it says access() is useful in setuid programs.
	 */


.S	Precedence Priority
.k	Precedence

sendmail 8.8.5 operations manual tells:

             5.7.  P -- Precedence Definitions

                     Values for the "Precedence:" field may be defined
                using  the  P  control line.  The syntax of this field
                is:

                    Pname==num

                When the name is found in a "Precedence:"  field,  the
                message  class  is  set  to  num.  Higher numbers mean
                higher precedence.  Numbers less than  zero  have  the
                special  property  that if an error occurs during pro-
                cessing the body of the message will not be  returned;
                this  is  expected  to be used for "bulk" mail such as
                through mailing  lists.   The  default  precedence  is
                zero.  For example, our list of precedences is:

                    Pfirst-class=0
                    Pspecial-delivery=100
                    Plist=-30
                    Pbulk=-60
                    Pjunk=-100

                People  writing  mailing list exploders are encouraged
                to use "Precedence: list".  Older versions of sendmail
                (which discarded all error returns for negative prece-
                dences)  didn't  recognize  this  name,  giving  it  a
                default  precedence  of  zero.  This allows list main-
                tainers to see error returns on both old and new  ver-
                sions of sendmail.


.S	4.4BSD vacation
.k	vacation

     No message will be sent unless login (or an alias supplied using the -a
     option) is part of either the ``To:'' or ``Cc:'' headers of the mail.  No
     messages from ``???-REQUEST'', ``Postmaster'', ``UUCP'', ``MAILER'', or
     ``MAILER-DAEMON'' will be replied to (where these strings are case insen-
     sitive) nor is a notification sent if a ``Precedence: bulk'' or
     ``Precedence: junk'' line is included in the mail headers.  The people
     who have sent you messages are maintained as a db(3) database in the file
     .vacation.db in your home directory.

.S	File and Directory Permission Default

umask(2) default is customizable.

	$FML_UMASK	for fml.pl
	$MSEND_UMASK	for msend.pl
	$UMASK	is used if neither $FML_UMASK nor $MSEND_UMASK is not defined.

.S	Directory Permissions

複数の人が fmlserv と一緒に使う場合 fmlserv はメンバーリストを書き変え
る等のために group permission が必要です。
＃ そのために root process を作れば、そうでなくてもできなくはないはず
＃ ですが、root process を増やすことはやりたくないので
=E
When plural maintainers maintain mailing lists directory and they uses
fmlserv.pl also, group writable permission is required. However
sendmail denies such settings for security today in default. It is
desirable to prepare a user e.g. "fml" to maintenance mailing lists
configurations. Or you can change /etc/sendmail.cf
e.g. DontBlameSendmail.

	$USE_FML_WITH_FMLSERV
.l	$USE_FML_WITH_FMLSERV
.k	$USE_FML_WITH_FMLSERV

変数はそれを意味するための内部変数ですが、普通は fml.pl が $DIR の隣に 
fmlserv という directory があるなら自動的に設定します。うまくいかない
ときは explicit に設定して下さい。それから $GID も fmlserv のために導
入された変数です。
=E
is automatically set up by fml.pl if fml.pl can find $DIR/../fmlserv
directory. If it is set, fml.pl recognizes it myself works with
fmlserv.pl. If HOME of fmlserv.pl exists not in $DIR/../fmlserv, you
need to set this variable manually in config.ph. $GID is also a
variable for fmlserv.pl.
.l	$GID
.k	$GID

.S	配送メールへのフィルタリング
=E.S	Filtering
.l	EnvelopeFilter
.n	envf

	$USE_DISTRIBUTE_FILTER
.l	$USE_DISTRIBUTE_FILTER
.k	$USE_DISTRIBUTE_FILTER

をセットすると、配送処理に入る直前(&Distribute ルーチンの先頭)で 
%Envelope のデータ群(ヘッダやメール本文)に対してフィルタリング操作をか
けます。そして問題のある内容のメールの配送をしないなどができるようにな
ります。
=E
enables the filtering for distribute mails. This filter checks
in-coming mails based on %Envelope data. You can set up your own hook
using %Envelope. 

	$USE_DISTRIBUTE_FILTER

をセットしただけのデフォールトでは(現在(97/12/14))次のようなメールは 
reject します。
=E
loads the following filter rule in default.

	○ 本文が何もないメール
	○ help や unsubscribe などの英語一行メール
	○ %echo ふがほげ の行
	   1999/02/24からはこの行がひっかかった時点で拒否
	   これ以前はあるパラグラフがこの行そのものの時のみ拒否
	   つまり『空行＋%echoなんとか行＋空行』の時だけだった
	○ Message-Id: が朗かに addr-spec でないのは SPAM メール
=E
	* reject null body
	* reject one line English words mail
	  e.g. "help", "unsubscribe"
	* reject invalid Message-Id mails (may be SPAM mails)
	* other strange syntaxes

   [options]

	$FILTER_ATTR_REJECT_COMMAND (default 0)
.k	$FILTER_ATTR_REJECT_COMMAND

	○ #unsubscribe などのコマンドをはじく
=E
	reject '#unsubscribe' like commands

	$FILTER_ATTR_REJECT_2BYTES_COMMAND (default 0)
.k	$FILTER_ATTR_REJECT_2BYTES_COMMAND

	○ ２バイト英文字ではじまる行を拒否
	   例: ＵＮＳＵＢＳＣＲＩＢＥ ほえほえ
=E
	* reject a line begining with Japanese 2-byte English Characters
	  e.g. 2-byte "unsubscribe"

これ以外の高度なチェックは
=E
You can use a hook to write your own more complicated filtering rules.
Attention: in this hook you can refer %Envelope as %e.

	$DISTRIBUTE_FILTER_HOOK (for post)
.k	$DISTRIBUTE_FILTER_HOOK
.k	$REJECT_DISTRIBUTE_FILTER_HOOK
.if LANG == JAPANESE
＃ $REJECT_DISTRIBUTE_FILTER_HOOK でも可能です(obsolete)。
＃ 同様に $REJECT_COMMAND_FILTER_HOOK もありますが obsolete
.k	$REJECT_COMMAND_FILTER_HOOK
.fi

	$COMMAND_FILTER_HOOK (for command)
.k	$COMMAND_FILTER_HOOK

で直接 perl の構文で %e (%Envelope) ハッシュの変数を使って記述して下さ
い。HOOK 内部では $e{'h:from:'} などでハッシュにアクセスして下さい。
＃このために独自の言語とかをまた新たに導入するのは面倒だとおもうので
＃perl で生書きです。

この HOOK では次のようなことを期待しています。
=E
In this hook, please write in the following way.

	reject する場合は reject の理由を含む文を return する
	そうでないなら 何も返さない (return ''; など)
=E
	* if reject, write the code
		return 'the reason of rejection';
	  where this reason is logged in $LOGFILE.
	* if OK, 
		return '';	 

この reject の理由はログに残されます。また、
=E
In default fml.pl does not notify the reason of rejection to the
sender (From: address) since no more information is good for security
in one sense. If you want to notify the rejection to the sender, set

	$FILTER_NOTIFY_REJECTION
.k	$FILTER_NOTIFY_REJECTION

という変数が設定されていれば、その理由をそのメールの送り主に送り返しま
す。デフォールトでは単に無視するだけです。

例: (not tested ;-)
○ received: 行のどこかに spam ブラックリストを見つけたら reject する。
○ 本文に http-equiv=3DContent-Type なHTMLをつけてくる迷惑なメール
   は reject する
○ From: のドメインが Message-ID にも含まれているかどうか？
   含まれていないならメールの偽造とみなして reject
=E
Example:
	* reject if a Received: line has "from spam.co.jp".
	* reject if http-equiv=3DContent-Type exists in the body.
	* reject $From_address conflicts with Message-Id:'s domain.

$DISTRIBUTE_FILTER_HOOK = q#
    if ($e{'h:received:'} =~ /from spam.co.jp/) {
	return 'from a host in spam blacklist';
    }

    if ($e{'Body'} =~ /http-equiv=3DContent-Type/) {
	return 'mail with appended HTML documents';
    }

   local($domain) = (split(/@/, $From_address))[1];
   if ($e{'h:message-id:'} !~ /$domain/i) {
	return 'Message-Id conflicts your From: address';
   }

#;

例2:	sendmail の option で PICKY_HELO_CHECK をかけている場合
=E
Example 2: When you configure PICKY_HELO_CHECK is on in config.h of
sendmail, reject mail when it has X-Authentication-Warning by
PICKY_HELO_CHECK. However this filter does not work well 
since virtual domain users matches them even if they are not spammers;D

    # PICKY_HELO_CHECK
    if ($e{'h:x-authentication-warning:'} !~ /Host \S+ claimed to be \S+/) {
	$r = "Your SMTP session or your host config is invalid";
    }

でもメールを出す人が virtual domain とかだとバソバソ reject されて困っ
ちゃうだろう ＃それでも構わないという人は使ってみよう(強引)

.S	特定のフィールドの内容によっては拒否する
=E.S	Reject if a field matches reject patterns

.if LANG == JAPANESE
	&DEFINE_FIELD_PAT_TO_REJECT(ヘッダフィールド, 正規表現, REASON)
.l	&DEFINE_FIELD_PAT_TO_REJECT
.k	&DEFINE_FIELD_PAT_TO_REJECT

という関数は EnvelopeFilter 中で使われる %REJECT_HDR_FIELD_REGEXP とい
うハッシュの内容を設定できます。これはあるフィールド(例えば Subject:)
の特定の内容について reject します。Case Sensitive です。ADULT と書く
と adult にマッチしません。
XXX "reason"はまだ実装されていません。
.fi
.if LANG == ENGLISH
	&DEFINE_FIELD_PAT_TO_REJECT(field-name, regexp, reason)
.l	&DEFINE_FIELD_PAT_TO_REJECT
.k	&DEFINE_FIELD_PAT_TO_REJECT

Define regular expression for a field. Please see an examle below.
XXX "reason" is not yet implemented now.
.fi

例:
=E
Example:

1.	Message-Id: がないものを reject
=E
1.	reject null Message-Id:

	&DEFINE_FIELD_PAT_TO_REJECT('message-id', '^\s*$');

2.	Subject: に FREE SEX ADULT XXX のいづれかの文字列が入っていたら
	SPAMとみなして捨てる(でもこれするとFreesoftも捨てちゃうね;-)
	最初と最後の / はあってもなくてもよいです。/ 以外は使わないで下さい
=E
2.	reject Subject: with FREE, SEX, ADULT, XXX.
	(but this config ignores "free software" content ?;-).

	&DEFINE_FIELD_PAT_TO_REJECT('subject', 'FREE|SEX|ADULT|XXX');
	&DEFINE_FIELD_PAT_TO_REJECT('subject', '/FREE|SEX|ADULT|XXX/');
	&DEFINE_FIELD_PAT_TO_REJECT('from', 'ADULT');

3.	Adult も ADULT も大文字小文字に関係なく許否。/i というperlで
	おなじみの形式を使います。/ 以外は使わないで下さい。
=E
3.	reject Subject: with FREE, SEX, ADULT, XXX (case insensitive).

	&DEFINE_FIELD_PAT_TO_REJECT('subject', '/free|sex|adult|xxx/i');

.S	sendmail 8.8 における check_* ルールセットについて
=E.S	On sendmail 8.8 check_* rule sets

.if LANG == JAPANESE
詳しくは CF を読んでね。sendmail 8.8 では様々なアクセス制御を容易にカ
スタマイズできるように以下のようなルールセットが用意されています。CFで
物足りない場合（そうはないとおもうぞ）はこれらを使ってごりごり 
sendmail.cf を書きます。

.q
check_mail          発信者のチェック
check_rcpt          受信者のチェック
check_relay         SMTP接続のチェック
check_compat        発信者および受信者のペアについてのチェック
.~q

またSMTPコネクションの接続要求に対して tcp_wrapper のライブラリである
libwrap.a を使うように sendmail を compile しておけば、
/etc/hosts.allow などで制御できるようになります。NetBSD 1.3 などの最新
のOSではこれが配布されるソースでのデフォールトです。
ちなみに tcp_wrapper におけるデーモン名は sendmail です。

.q
Example:

[/etc/hosts.allow]

sendmail: mikoto.fml.org


[/etc/hosts.deny]

ALL: ALL

.~q

check_mail と check_rcpt はSMTP処理ルーチン srvrsmtp() 内でそれぞれ 
MAIL FROM: と RCPT TO: の命令の引数に対して適用されます。つまりそれぞ
れ SMTP で渡される MAIL FROM:のアドレス(発信者)と RCPT TO:のアドレス
(配送先)のチェックに使われます

check_relay はSMTPコネクションが張られた時に適用されます。check_relay 
は validate_connection() で呼ばれ接続が成立した SMTPコネクションが接続
を許可されているホストからのものか？などについてチェックをします。
validate_connection() では tcp_wrapper 形式の制御も可能です(前述)。

check_compat は単純なチェックではなく送信者と受取人の組で判定をしなけ
ればならないような複雑な判定に使います。
check_compat は配送ルーチン deliver() で適用されメールの送り主と配送
先のペアについてSMTP translation だけでなく配送するメールの全てについ
て適用されます。
.fi
.if LANG == ENGLISH
Please see sendmail's book (bat book).
.fi

.S	SMTP and Authentication

draft-myers-smtp-auth-11.txt (submitted to be Proposed Standard)
RFC2222 (SASL)

SASL: Simple Authentication and Security Layer

draft-hoffman-smtp-ssl-06.txt (SMTP over secured layer)

.S	&system() function

system は perl の内部関数ではなく独自に書いた system を使っています。
何故かうまく動かない場合や、fork() がないNTなどでは perl 附属の 
system() を使わざるを得ない場合があります。デフォールトでは perl 附属
の system() を使っていません。
=E
Fml does not use perl's system() but the original &system(). When the
perl on OS has no fork(), we have to use perl's system(). On some
environment, a few commands cannot work well with our &system().

コマンドがうまく動かない場合に 
=E
When some commands do not work well, try to set

	$INSECURE_SYSTEM = 1;  (default 0)
.k	$INSECURE_SYSTEM
.l	$INSECURE_SYSTEM

という変数設定をして動くことがあるかもしれません。
=E
in config.ph. It may enable you to use the command.

なお NT では system() を使っています。
=E
On NT4, fml uses perl's system() since ntperl has no fork().

いずれの場合でもシンタックスチェックが事前に行なわれ、その後 system を
呼んでいます。
=E
In any cases fml checks the syntax of arguments passwd to
system(). After checks, fml calls system().



.C	Emailアドレスの判定方法とSecurity
=E.C	Email Address Check Rules and Security

.S	アドレスのチェックを緩めたい or きつくしたい
=E.S	Level of address check severity
.l	$ADDR_CHECK_MAX

メンバーチェックは送られてきたメールの発信者のアドレスと members に書
かれたアドレスとが一致するか否かで判断しています。今の設定は
＃1.3.2からは…緩くした
=E
When fml.pl compares From: address and an address in member lists,
fml.pl recognizes the following four addresses as the same one in
default. That is fml.pl checks within three levels from DNS root.

	fukachan@titech.ac.jp
	fukachan@phys.titech.ac.jp
	fukachan@beth.phys.titech.ac.jp
	fukachan@exelion.phys.titech.ac.jp

はすべて同じにみなしてます。つまり phys.titech.ac.jp のjp側から数えて
３つの部分の判定チェックですね。(木構造のルートから数える)
＃経験的にここまでやれば十分でしょう

4つ(jp ac phys titech の4つ)までチェックしたいなら、
=E
If you check domains more severely, the levels from DNS root is
controlled by $ADDR_CHECK_MAX. If you check 4 levels, set up

	$ADDR_CHECK_MAX = 4;
.k	$ADDR_CHECK_MAX

と config.ph のどっかに書いておいて下さい。$ADDR_CHECK_MAX という変数
が設定されてない場合は３として動きます。４の時
=E
If 4, 

	fukachan@phys.titech.ac.jp
	fukachan@beth.phys.titech.ac.jp
	fukachan@exelion.phys.titech.ac.jp

は同じだが、
=E
is the same but 

	fukachan@titech.ac.jp

は違うアドレスである。
=E
differs from others.

.S	複数アドレスから投稿したいがうけとりは一つ( "skip" コマンド)
=E.S	One recipient for plural addresses to post mails from
.key	skip
.key	noskip
.label	skip

.if LANG == JAPANESE
複数アドレスから投稿可能だがうけとりはあるアドレスに送って欲しい、「こ
の１週間だけこのアドレスも使いたい」などの場合にも効果的です。これらの
場合を想定して actives(自動登録では members = actives) で

fukachan@phys.titech.ac.jp	skip

と書いておけば認証(新人さんチェック)には使うけど配送はしないという動作
をします。つまり

	fukachan@phys.titech.ac.jp	skip
	Elena@phys.titech.ac.jp	
	Pollyanna@phys.titech.ac.jp	skip

になっているとすると、fukachan,elena,pollyannaどこからでも投稿はできる
が、配送はelenaにしか行なわれないということです。

ユーザーがこれを自分でコントロールしたいなら、コマンドは
＃ Admin command でのみ引数が有効です。
 
skip	 [引数]		From:のアドレス もしあれば 引数のアドレスを
			そこから投稿はできるが、配送はされないものと設定する
noskip [引数]		上の逆。配送するようにする。

です。例：
skip 
	From: のアドレスを skip に

skip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp を skip に

noskip pollyanna@phys.titech.ac.jp
	pollyanna@phys.titech.ac.jp へも配送を
.fi
.if LANG == ENGLISH
When one recipient for plural addresses to post mails from, you can
write 

	# address

format in member or delivery lists. In this comment out style fml.pl
uses it as an authentication candidate but not delivers articles to
it. If the list follows

	# addr1
	# addr2
	# addr3
	addr4

Fml delivers mail to addr4 not addr1,addr2,addr3 but accepts post
from addr1,addr2,addr3,addr4.
.fi

.S	特定のアドレスを拒否する(e.g. spam mails)
=E.S	Reject Mails From Specific Domains
.k	spam mails
.l	$REJECT_ADDR_LIST
.k	$REJECT_ADDR_LIST
.k	$REJECT_ADDR
.l	$DIR/spamlist

.if LANG == JAPANESE
メインのルーチンに飛ぶ前に reject するコードなら入っています(2.1 gamma
206以降)。$REJECT_ADDR_LIST (デフォールトは $DIR/spamlist) に perl の
正規表現で書いたアドレスから来たメールには何もしないで reject するよう
になります。この場合配送、コマンド、自動登録すべての場合にそこへいく前
に reject します。

   \S+@spam.org (spam.org のアドレスは全部許否)
   manager@\S+  (あらゆるサイトの個人を代表しないアドレスは拒否)

みたいな形式です。なおデフォールトの $REJECT_ADDR はこれとは別に適用さ
れます。
.fi
.if LANG == ENGLISH
Before the main routine works, fml.pl can check and reject mails from
specific domains in $REJECT_ADDR_LIST ($DIR/spamlist in default).
Please write e.g.

   \S+@spam.org (reject spammers?, mails from spam.org)
   manager@\S+  (reject not personal addresses)

fml adjusts $REJECT_ADDR for rejection irrespective of this file.
.fi


.C	Mail Loops

.S	Message-ID: Cache
.xref	$CHECK_MESSAGE_ID

Message-ID: は時空全体で一意です。なので同じMessage-ID:のメールが突っ
込まれることは有り得ません。ありうる場合は

1.	出した方のソフト(MUA,MSA,MTA?)のどれかがRFC違反
2.	どっかでエラーして２通になった
	どっかに消えて無くなるよりは「疑わしい時は再送」という
	デザインのMTAもあるので、これはあってもしょうがない
3.	そのマシンのエラーで、２通になった
	例: fmlの処理の途中でマシンがリブートした時

$DIR/var/run/ の下にキャッシュファイルが作られています。デフォールトで
は各ファイルは $MESSAGE_ID_CACHE_BUFSIZE (default 60*100) bytesを越え
るとrotateしながら古いものから消去されます。最大 $NEWSYSLOG_MAX + 2 個
のキャッシュが作られます。概ね過去 100 * ($NEWSYSLOG_MAX + 2) アドレス
ほどに対して二重でないかどうかのチェックがされます。

.S	一意なX-ML-Info: 
=E.S	Unique X-ML-Info: header field

X-ML-Info: フィールドにはＭＬのアドレス(MLのアドレス、コマンドのアドレ
ス、管理者のアドレスのいづれか)が出てきます。例え多段のＭＬ(例えば 
ML-A -> ML-B -> ML-C -> ... のML-B)であってもX-ML-Info: に自分のＭＬア
ドレス(X-ML-Info: ML-B)はでないはずという仮定です。
=E
X-ML-Info: field has the ML address. It must be unique. Mail with
"X-ML-Info: ML" must not be injected to the fml.  Under this
conjecture, we check and reject mails with "X-ML-INfo: our ML".

メールループはMessage-ID: Cacheをすり抜けても、このルールがループと見
なすことになります。ただし「ヘッダが削除されない」という前提条件は必要
です。


.include mti.wix
.include function.wix
.include hook.wix
.include smtp.wix



.C	Porting to other Operationg Systems

.S	Micro$oft NT 4.0
.k	Micro$oft NT 4.0
.k	$HAS_GETPWUID
.k	$HAS_GETPWGID
.k	$HAS_ALARM

	$HAS_GETPWUID
	$HAS_GETPWGID
	$HAS_ALARM

の変数はOFFになります。U*ix ではデフォールトでONです。 
ライブラリによっては次の変数をセットしているものもあります。
=E
are disabled when fml.pl on NT4. Also 

	$COMPAT_WIN32 = 1;
.l	$COMPAT_WIN32
.k	$COMPAT_WIN32

=E
in some libraries.

.S	sys/ Directory
.k	$COMPAT_ARCH

fml.pl の次の行は

    if ($COMPAT_ARCH)  { require "arch/${COMPAT_ARCH}/depend.pl";}

Architecture 依存コードをロードするためのものです。
Architecture 依存は

	sys/OS/perlスクリプト

のように並び適宜ローディングされます。
=E
sys/OPERATING_SYSTEM/ directories are locations of architecture
dependent libraries or configuration files.


.# $Id$
.# Copyright (C) 1993-1999 Ken'ichi Fukamachi
.#          All rights reserved. 
.#               1993-1996 fukachan@phys.titech.ac.jp
.#               1996-1999 fukachan@sapporo.iij.ad.jp
.# 
.# FML is free software; you can redistribute it and/or modify
.# it under the terms of GNU General Public License.
.# See the file COPYING for more details.
