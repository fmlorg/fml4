#!/usr/local/bin/perl
#
# Copyright (C) 1993-1997 Ken'ichi Fukamachi
#          All rights reserved. 
#               1993-1996 fukachan@phys.titech.ac.jp
#               1996-1997 fukachan@sapporo.iij.ad.jp
# 
# FML is free software; you can redistribute it and/or modify
# it under the terms of GNU General Public License.
# See the file COPYING for more details.
#
# $Id$;


### AUTOMATICALLY REPLACED by makefml (Sun, 9 Mar 97 19:57:48 )
$CONFIG_DIR = ''; # __MAKEFML_AUTO_REPLACED_HERE__

&InitMakeFml;
&InitTTY;

# info
if (! @ARGV) { &ExecCmd("info"); exit 0;}

if (@ARGV) {
    &ExecCmd(join(" ",@ARGV));
}
else {
    &ExecCmd("info");
}

if ($GroupWritable) {
    print STDERR "\n   Please check the group permission in $ML_DIR\n";
    print STDERR "   Enjoy Internetworking!\n";
}

&System if $SYSTEM_ARGV;

&FlushLog;
exit 0;


#################### LIBLARIES ####################
sub System { system $SYSTEM_ARGV;}

sub InitMakeFml
{
    ### signal handling
    $SIG{'ALRM'} = 'TimeOut';
    $SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = 'SignalLog';

    # for log
    $USER  = $ENV{'USER'} || (getpwuid($<))[0];

    # flush;
    select(STDOUT); $| = 1;

    &GetTime;

    require 'getopts.pl';
    &Getopts("dhf:A:O:p:D:v");

    # flock(2)
    $LOCK_SH                       = 1;
    $LOCK_EX                       = 2;
    $LOCK_NB                       = 4;
    $LOCK_UN                       = 8;

    # umask 077?
    # if a group mainteints the fml system, umask(007)?;
    # here several people can read but not write;
    umask(002);

    $COMPAT_ARCH = $opt_A;

    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	$USER = $ENV{'USERNAME'};
    }
    else {
	$USER = $ENV{'USER'} || (getpwuid($<))[0];
    }

    $debug   = $opt_d;
    $verbose = $opt_v;

    $HOME  = $ENV{'HOME'};
    $PWD   = $ENV{'PWD'};

    { # DNS AutoConfigure to set FQDN and DOMAINNAME; 
	local(@n, $hostname, $list);
	chop($hostname = `hostname`); # beth or beth.domain may be possible
	$FQDN = $hostname;
	@n    = (gethostbyname($hostname))[0,1]; $list .= " @n ";
	@n    = split(/\./, $hostname); $hostname = $n[0]; # beth.dom -> beth
	@n    = (gethostbyname($hostname))[0,1]; $list .= " @n ";

	foreach (split(/\s+/, $list)) { /^$hostname\.\w+/ && ($FQDN = $_);}
	$FQDN       =~ s/\.$//; # for e.g. NWS3865
	$DOMAINNAME = $FQDN;
	$DOMAINNAME =~ s/^$hostname\.//;
    }

    &ProbePerlVersion;
    if ($UNDER_JPERL) {
	local($sep) = "*" x 60;
	local($tab) = "\t\t";
	print STDERR "\n$sep\n";
	print STDERR "\n${tab}***** WARNING *****\n";
	print STDERR "${tab}YOUR PERL LOOKS jperl!\n";
	print STDERR "${tab}YOU SHOULD USE\n";
	print STDERR "${tab}perl 4.036 or perl 5\n${tab}NOT jperl!\n";

	&InitTTY;
	$r = &Query("YOU USE fml under jperl?", "y/n", "y|n", "n");

	if ($r eq 'y') {
	    print STDERR "\nHmm... YOU MAY HAVE PROBLEMS.\n";
	    print STDERR "ALL IS DONE UNDER YOUR OWN RISK\n";
	    print STDERR "PLEASE DO NOT ASK fml-* ML's ON PROBLEMS\n\n";
	    sleep 3;
	}
	else {
	    print STDERR "O.K. Please install usual perl. Good Luck!\n";
	    print STDERR "makefml ends here.\n\n";
	    exit 0;
	}
    }

    # architecture dependence;
    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	$CONFIG_DIR =~ s#\\#/#g;
    }

    # Anyway try once ... (may be re-installation ?)
    # Dame moto sune:-)
    if (! $CONFIG_DIR) {
	for ("$HOME/.fml", "/usr/local/fml/.fml") {
	    $CONFIG_DIR = $_ if -d $_;
	}
    }


    ### FIX VARIABLES
    $CONFIG_DIR = $opt_D || $CONFIG_DIR || "$HOME/.fml"; # must be no meaning ...
    $FML_CONFIG = $opt_f || "$CONFIG_DIR/system";
    $FML_POLICY = $opt_p || "$CONFIG_DIR/policy";

    # for ($FML_CONFIG, $FML_POLICY) { &Touch($_) unless -f $_;}

    # config amd temporary files
    if ($TheFirstTime) {
	$MAKEFML_LOGFILE  = "/tmp/fml::makefml::log.${USER}.$$";
	$TempolaryLogfile = $MAKEFML_LOGFILE;
    }
    else {
	$MAKEFML_LOGFILE  = "$CONFIG_DIR/log";
    }
    &Touch($MAKEFML_LOGFILE) unless -f $MAKEFML_LOGFILE;


    ### *Config, %Default, %PolicyDefault;
    ###   REQUIRED HERE BEFORE LOADING;
    &SetHashDefaults;


    ### LOADING $FML_POLICY
    if (-f $FML_POLICY) {
	# print STDERR "---Load POLICY from $FML_POLICY\n";
	&GetCurPolicy;
    }

    ### LOADING $FML_CONFIG
    if (-f $FML_CONFIG) {
	print STDERR "---Loading the configuration file $FML_CONFIG\n";

	package Config;
	eval("require \$main'FML_CONFIG;\#'");
	print STDERR $@ if $@;

	$main'debug = $Config'debug;
	package main;

	# overwrite configuration debug mode;
	$debug = 1 if $opt_d;

	&Dumpvar('Config') if $debug;
    }
    else {
	print STDERR "---NOT USING configuration file\n";
	$TheFirstTime = 1;
    }

    # inspecting cpu-type-manufacturer-operating-system
    {
	local($eval, $dir);

	$dir = $0;
	$dir = $dir =~ m#/# ? $dir : "./$dir";
	$dir =~ s#(.*)/.*#$1#;

	$eval = qq#\$CPU_TYPE_MANUFACTURER_OS = `sh $dir/sbin/config.guess`;#;
	print STDERR "$eval\n" if $debug;
	eval($eval);
	print STDERR $@ if $@;

	chop $CPU_TYPE_MANUFACTURER_OS;
	$Config'CPU_TYPE_MANUFACTURER_OS{$FQDN} = $CPU_TYPE_MANUFACTURER_OS;#';
	print STDERR $@ if $@;

	$OS_TYPE = (split(/\-/, $CPU_TYPE_MANUFACTURER_OS))[2];
	$OS_TYPE =~ tr/a-z/A-Z/;
    }

    print &Dumpvar('Config') if $debug;

    &SetSockAddr($CPU_TYPE_MANUFACTURER_OS);

    if ($Config'OS_TYPE{$FQDN}) { #';
	$OS_TYPE = $Config'OS_TYPE{$FQDN} || $OS_TYPE; #';
    }
    else {
	print STDERR "\$Config'OS_TYPE{'$FQDN'} = '$OS_TYPE';\n" if $debug;
	eval("\$Config'OS_TYPE{'$FQDN'} = '$OS_TYPE';");
    }
    
    # if not defined this machine OS;
    if ($opt_O) {
	$OS_TYPE = $opt_O;
	$OS_TYPE =~ tr/a-z/A-Z/;
	print "   YOU DEFINE THIS HOST ($FQDN)'s OS == $OS_TYPE.\n";
	eval("\$Config'OS_TYPE{'$FQDN'} = '$OS_TYPE';");
    }
    elsif ($CPU_TYPE_MANUFACTURER_OS) {
	print "\n";
	print "   THIS HOST ($FQDN) IS [$CPU_TYPE_MANUFACTURER_OS]\n";
	print "   THIS HOST ($FQDN) OS [$OS_TYPE]\n" if $debug;
	print "\n";
    }
    elsif ($COMPAT_ARCH eq "WINDOWS_NT4") {
	$OS_TYPE = "WINDOWS_NT4";
	eval("\$Config'OS_TYPE{'$FQDN'} = '$OS_TYPE';");
    }
    else {
	# print "---Try to inspect your Operating System ...\n";
	print "\n";
	print "\n   This machine looks [$CPU_TYPE_MANUFACTURER_OS]\n\n";
    }

    ### anyway reload and set the present config for convenience;
    &GetCurConfig;
    &ResetVariables;

    # fix include path for *.pl 
    push(@INC, $EXEC_DIR);

    if ($CurConfig{'PERSONAL_OR_GROUP'} =~ /^(group|fmlserv)$/) {
	$GroupWritable = $CurConfig{'PERSONAL_OR_GROUP'};
    }
}


sub SetHashDefaults
{
    # Language Extension for documents;
    $LANGUAGE  = $FQDN =~ /jp$/i ? "Japanese" : "English";

    # configurable variables;
    @Config = ('DOMAIN', 'FQDN', 'EXEC_DIR', 'ML_DIR', 'LANGUAGE');

    %Config = ('EXEC_DIR', 'EXEC FILES DIRECTORY',
	       'ML_DIR',   'TOP LEVEL ML DIRECTORY', 
	       'DOMAIN',   'DOMAIN NAME', 
	       'FQDN',     'FQDN', 
	       'LANGUAGE', 'LANGUAGE',
	       ); 

    %Default = ('PERSONAL_OR_GROUP', 'personal',
		'EXEC_DIR', '/usr/local/fml',
		'ML_DIR',   '/var/spool/ml', 
		'DOMAIN',   $DOMAINNAME,
		'FQDN',     $FQDN,
		'GROUP',    '',
		'LANGUAGE', $LANGUAGE,
		); 

    %PolicyDefault = 
	('MAIL_LIST_MODE',         'listname (distribute+commands)',
	 'CONTROL_ADDRESS_FORMAT', 'listname-ctl (command only)',
	 ); 


    # $COMPAT_ARCH eq "WINDOWS_NT4"
    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	local($dir);
	chop($dir = `cd`);
	$dir =~ s/(\w:).*/$1/;
	$Default{'EXEC_DIR'} = "$dir\\fml";
	$Default{'ML_DIR'}   = "$dir\\fml\\ml";
    }

    %MakeFmlProc = ('install',  'do_install',
		    '0#install', 'Install the fml system',
		    'info',     'do_info',
		    '0#info',    'show this message',
		    'setq',     'do_setq',
		    'show',     'do_show',
		    'config',   'do_config',

		    '5#config ML', 'configure the fundamental of <ML>',
		    'edit',   'do_edit',
		    '5#edit ML', "edit config.ph of <ML>\'s",

		    'new',      'do_newml',
		    'newml',    'do_newml',
		    '1#newml ML',   'make a new Mailing List <ML>',
		    'add',      'do_adduser',
		    '2#add ML address',     'add <address> to <ML>',
		    'adduser',  'do_adduser',
		    '2#adduser ML address', 'add <address> to <ML>',
		    'bye',      'do_byeuser',
		    '3#bye ML address',     'remove <address> from the <ML>',
		    'byeuser',  'do_byeuser',
		    '3#byeuser ML address', 'remove <address> from the <ML>',
		    'addadmin', 'do_addadmin',
		    '4#addadmin ML address', 'add <address> as an admin to <ML>',
		    'byeadmin', 'do_byeadmin',
		    '4#byeadmin ML address', 'remove the administrator of the <ML>',
		    'help',	'do_info',
		    '8#help',	'help message',
		    'passwd',	'do_passwd',
		    '8#passwd ML address',	'to change the administrator passwd',

		    'test',	'do_test',
		    '8#test ML',	'test ',

		    'fmlserv',  'do_fmlserv',
		    'listserv', 'do_fmlserv',
		    'majordomo','do_fmlserv',

		    # PGP
		    'pgp',	'do_pgp',
		    '9#pgp ML PGP-arguments', 'e.g. "pgp ML -ka publib_key"',

		    'delivery_mode',  'do_delivery_mode',

		    '10#fmlserv', 'set up fmlserv (listserv-like command interface)',
		    '10#listserv','set up fmlserv (listserv-like command interface)',
		    '10#majordomo','set up fmlserv (listserv-like command interface)',
		    );

    # variables not to lock
    %NOT_LOCK = ('newml', 1,
		 'info', 1,
		 'help', 1,
		 'listserv', 1,
		 'majorodomo', 1,
		 'fmlserv', 1,
		 );

}


sub InitFmlConfig
{
    local($cmd, $prompt, $v);

    print "---Please Define Your Fml System Configurations\n\n";

    # personal or group-shared?
    printf "%-25s ", 
    "Personal Use or ML-Admin-Group-Shared or fmlserv you use?";

    $cmd = &Query("Personal, Group, Fmlserv", "personal/group/fmlserv", 
		  "personal|group|fmlserv", "personal");    
    $cmd = ($cmd !~ /^\s*$/) ? $cmd : $v;
    &do_setq("PERSONAL_OR_GROUP", $cmd);

    if ($cmd eq 'group' || $cmd eq 'fmlserv') {
	printf "Please define the group (in /etc/group) ML Operators use";
	$cmd = &Query("Group of Mailing List Operators", 
		      "fml or GID ([\\w\\d]+)", "[\\w\\d]+", "fml");    
	&do_setq("GROUP", $cmd);

	$GID = &GetGID($cmd);

	print "GID\t$cmd\n" if $debug;
	print "GID\t$GID\n" if $debug;

	if (! $GID) {
	    print "   *** ERROR ***\n";
	    print "   I cannot find the group \"$cmd\" in /etc/group.\n";
	    print "   Please define it!\n";
	    exit 0;
	}
    }

    # values;
    for (@Config) {
	$k = $_;
	$p = $Config{$_};
	$v = $CurConfig{$_} ? $CurConfig{$_} : $Default{$_};

	printf "%-25s %s ", $p, "[$v]";

	$cmd = &GetString;
	
	$cmd = ($cmd !~ /^\s*$/) ? $cmd : $v;
	$buf .= sprintf("  set \$%-10s = '%s';\n", $k, $cmd);
	&do_setq($k, $cmd);
    }

    print "\n$buf\n";

    &GetCurConfig;

    # print "CONFIG_DIR (e.g. $HOME/.fml, $CurConfig{'EXEC_DIR'}/.fml ...)\n";
    # print "Config Saved in [$CurConfig{'EXEC_DIR'}/.fml] ";
    # $cmd = &GetString;
    # $cmd = ($cmd !~ /^\s*$/) ? $cmd : "$CurConfig{'EXEC_DIR'}/.fml";
    # $CONFIG_DIR = $cmd;

    $CONFIG_DIR = "$CurConfig{'EXEC_DIR'}/.fml";

    # mkdir CONFIG_DIR;
    {
	local($dir);
	for (split(/\//, $CONFIG_DIR)) {
	    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
		$dir .= $dir ? "/$_" : $_;
	    }
	    else {
		$dir .= "/$_";
	    }

	    $dir =~ s#//#/#g;

	    if (! -d $dir) {
		# print "   mkdir $dir\n";
		# here /usr/local/fml;only installer can read-write this;
		mkdir($dir, 0755); 
	    }
	}
    }

    $FML_CONFIG  = "$CONFIG_DIR/system";
    
    $buf = &Dumpvar('Config');
    &SaveConfig($buf) if $buf;

    print "\nThe Current Config is saved in $FML_CONFIG\n";
}


sub GetCurConfig
{
    local($s);

    # reset %CurConfig from Config Name Space;
    for (keys %Default) { 
	$s .= "\$CurConfig{'$_'} = \$Config'$_;\n";
    }

    eval($s);
    print "$@\n---\n$s\n" if $@;
}


sub SaveConfig
{
    local($buf) = @_;

    if (-f $FML_CONFIG) { rename($FML_CONFIG, "${FML_CONFIG}.bak");}

    open(F, ">> $FML_CONFIG") || die("Cannot save config to $FML_CONFIG");
    select(F); $| = 1; select(STDOUT);
    print F "$buf\n";
    print F "\n1;\n";
    close(F);
}


sub GetCurPolicy
{
    local($s);

    if (! -f $FML_POLICY) {
	&Touch($FML_POLICY);
	return;
    }

    package Policy;
    eval("do \$main'FML_POLICY;\#'");
    print STDERR $@ if $@;
    package main;

    # reset %CurPolicy from Policy Name Space;
    for (keys %PolicyDefault) { 
	$s .= "\$Policy{'$_'} = \$Policy'$_;\n";
    }

    eval($s);
    print "$@\n---\n$s\n" if $@;

    if ($debug) {
	print STDERR "---POLICY LOADING\n";
	while (($k, $v) =  each %Policy) {
	    printf STDERR "   debug:\$Policy %-20s -> %s\n", $k, $v;
	}
	print STDERR "---POLICY LOADING ENDS\n";
    }
}


sub SavePolicy
{
    local($buf) = @_;

    if (-f $FML_POLICY) { rename($FML_POLICY, "${FML_POLICY}.bak");}

    open(F, ">> $FML_POLICY") || die("Cannot save POLICY to $FML_POLICY");
    select(F); $| = 1; select(STDOUT);
    print F "$buf\n";
    print F "\n1;\n";
    close(F);

    print STDERR "Policy Saved in $FML_POLICY\n";
}


sub FlushLog
{
    if ($TempolaryLogfile eq $MAKEFML_LOGFILE) {
	print STDERR "--- makefml log ($MAKEFML_LOGFILE) ---\n";
	&Cat($MAKEFML_LOGFILE);
	unlink $MAKEFML_LOGFILE if $TheFirstTime;
    }
}


sub Cat
{
    local($in) = @_;

    open(CAT_OUT, $in) || return;
    select(STDOUT); $| = 1;
    while (<CAT_OUT>) { print $_;}
    close(CAT_OUT); 
}


sub Copy
{
    local($in, $out) = @_;

    open(COPY_IN,  $in)      || (&Log("CopyIN: $!"), return);
    open(OUT, "> $out") || (&Log("CopyOUT: $!"), return);
    select(OUT); $| = 1; select(STDOUT); 
    while (sysread(COPY_IN, $_, 4096)) { print OUT $_;}
    close(OUT);
    close(COPY_IN); 
}


sub AppendString2File
{
    local($s, $file) = @_;

    open(APP, ">> $file") || return 0;
    select(APP); $| = 1; select(STDOUT);
    print APP "$s\n" if $s;
    close(APP);
}


sub Warn 
{
    local(@caller) = caller;
    print STDERR "Warning:(called from @caller)\n@_\n";
}


sub Debug { print STDERR "@_\n";}


sub Log 
{ 
    local($str, $s) = @_;
    local($from) = $USER;
    local(@c) = caller;

    &GetTime;

    # existence and append(open system call check)
    if (-f $LOGFILE && open(APP, ">> $LOGFILE")) {
	&Append2("$Now $str ($from)", $LOGFILE);
	&Append2("$Now    $filename:$line% $s", $LOGFILE) if $s;
    }
    elsif (-f $MAKEFML_LOGFILE && open(APP, ">> $MAKEFML_LOGFILE")) {
	&Append2("$Now $str ($from)", $MAKEFML_LOGFILE);
	&Append2("$Now    $filename:$line% $s", $MAKEFML_LOGFILE) if $s;
    }
    else {
	print STDERR "$Now $str ($from)\n\t$s\n";
    }
}


# append $s >> $file
# if called from &Log and fails, must be occur an infinite loop. set $nor
# return NONE
sub Append2 { &Write2(@_, 1);}
sub Write2
{
    local($s, $f, $o_append) = @_;

    if ($o_append && $s && open(APP, ">> $f")) { 
	select(APP); $| = 1; select(STDOUT);
	print APP "$s\n";
	close(APP);
    }
    elsif ($s && open(APP, "> $f")) { 
	select(APP); $| = 1; select(STDOUT);
	print APP "$s\n";
	close(APP);
    }
    else {
	local(@caller) = caller;
	print STDERR "Append2(@_)::Error [@caller] \n";
    }

    1;
}


sub Touch  { open(APP, ">>$_[0]"); close(APP); chown $<, $GID, $_[0] if $GID;}


sub SignalLog 
{ 
    local($sig) = @_; 

    print STDERR "Caught Signal[$sig], shutting down ... \n\n";
    # &MakeFmlUnLock; infinite loop?     sleep(1);
    &FlushLog;
    exit(1);
}


# dummary
sub WholeMail { print STDERR "Dummy WholeMail [@_]\n";}
sub SetEvent  { print STDERR "Dummy SetEvent [@_]\n";}


##############################################################################
##########
########## LOCK LIBRARY
##########

sub FlockP
{
    local($ml, $mldir) = @_;
    local($eval);

    # default=flock if first time or no config.ph;
    return 1 unless -f "$mldir/$ml/config.ph";

    open(PH, "$mldir/$ml/config.ph") || 
	(&Warn("cannot open $mldir/$ml/config.ph[$!]"), return);
    while (<PH>) {
	/\$USE_FLOCK/ && ($eval .= $_);
	/\$SPOOL_DIR/ && ($eval .= $_);
    }
    close(PH);

    eval("package flockp; eval(\$main'eval); package main; #';");
    &Warn($@) if $@;

    $ml'FLockP{$ml}    = $flockp'USE_FLOCK;
    $ml'SPOOL_DIR{$ml} = $flockp'SPOOL_DIR;

    return $flockp'USE_FLOCK; #';
}

sub Lock
{
    local($ml, $mldir) = @_;

    return if $InstallMode;

    if (! -d "$mldir/$ml" && ! -d $mldir) {
	die("\n\n*** Error: $mldir nor $mldir/$ml not exists. stop. *** \n\n");
    }

    if (&FlockP($ml, $mldir)) {
	print STDERR "\n---Flock($ml, $mldir)\n" if $debug_lock;
	&FLock($ml, $mldir);
    }
    else {
	print STDERR "\n---V7 lock($ml, $mldir)\n" if $debug_lock;
	&V7Lock($ml, $mldir);
    }
}

sub UnLock
{
    local($ml) = @_;
    local($flockp) = $ml'FLockP{$ml};#'

    return if $InstallMode;

    if ($flockp) {
	print STDERR "\n---Flock\n" if $debug_lock;
	&FUnLock($ml);
    }
    else {
	print STDERR "\n---V7 lock\n" if $debug_lock;
	&V7UnLock($ml);
    }
}

sub MakeFmlLock
{
    local($ml, $mldir) = @_;
    local($count);

    # Lock Algorithm deepnds on each ML's config.ph,
    # so very complicated (which requires fmlserv's tricks)
    # lock struct
    #    ( flock_p  => lock_file (directory or lockfile) );

    ### Lock Type Probe 
    # only one
    if ($ml) {
	print "---Locking $ml ML"; $count++;
	
	&Lock($ml, $mldir);
	$LockList{$ml} = $mldir;
    }
    else {
	print "---Locking $mldir\n\t";

	opendir(DIRD, $mldir);
	for (readdir(DIRD)) {
	    next if /^\./;
	    next unless -f "$mldir/$_/config.ph";

	    print " $_"; $count++;
	    
	    &Lock($_, "$mldir/$_");
	    $LockList{$ml} = "$mldir/$_";
	}
	closedir(DIRD);
    }

    if ($count) {
	print "\n   Locked. Go ahead!\n\n";
    }
    else {
	print "\n   Nothing exists. Go ahead anyway!\n\n";
    }
}


sub MakeFmlUnLock
{
    local($ml, $mldir) = @_;

    if ($ml && $LockList{$ml}) {
	print "---UnLocking $ml ML";
	&UnLock($ml);
    }
    else {
	print "---UnLocking\n\t";

	opendir(DIRD, $mldir);
	for (readdir(DIRD)) {
	    next if /^\./;
	    next unless -f "$mldir/$_/config.ph";
	    next unless $LockList{$_}; # skip if not locked;

	    print " $_";
	    &UnLock($_);
	}
	closedir(DIRD);
    }

    print "\nDone.\n";
}


########################################################################


sub InitTTY
{
    if (-e "/dev/tty") { $console = "/dev/tty";}

    open(IN, "<$console") || open(IN,  "<&STDIN"); # so we don't dingle stdin
    open(OUT,">$console") || open(OUT, ">&STDOUT");# so we don't dongle stdout
    select(OUT); $| = 1; #select(STDOUT); $| = 1;
}


sub ExecCmd
{
    local($_) = @_;
    local(@argv, $fp, $ml);

    @argv = split(/\s+/, $_);

    &GetCurConfig;
    &ResetVariables;

    if ($TheFirstTime) {
	;
    }
    else {
	if (!-d $EXEC_DIR) {
	    print STDERR "ExecDir($EXEC_DIR) NOT FOUND, STOP\n";
	    return;
	}
	if (!-d $ML_DIR) {
	    print STDERR "ML_DIR($ML_DIR) NOT FOUND, STOP\n";
	    return;
	}
    }

    # function pointer;
    $fp = shift @argv;
    $fp = $FP{$fp} ? $FP{$fp} : $fp; # this line is not used ?

    # valid command?
    if (! $MakeFmlProc{$fp}) {
	&Debug("\n*** Error: command [$fp] NOT DEFINED ***");
	&Debug("   run \"makefml help\"");
	&Debug("        or ");
	&Debug("   see the document 'INSTALL' for more details\n");
	return;
    }

    # check arguments
    {
	local($not_require_ml);
	$ml = $argv[0];
	for ("newml", "info", "help", "install", 
	     "fmlserv", "majordomo", "listserv") {
	    # print STDERR "check $fp eq $_\n";
	    $fp eq $_ && $not_require_ml++;
	}

	if (! $not_require_ml) {
	    if (-d "$ML_DIR/$ml" && -f "$ML_DIR/$ml/config.ph") {
		; # O.K.;
	    }
	    else {
		&Debug("\n*** Syntax Error ***");
		&Debug("    makefml $fp mailing-list\n");
		&Debug("arguments of mailing-list is required\n");
		return;
	    }
	}
    }

    # Here $ml and approviate dir/files must be already defined
    # if $ml is required.
    if ($ml) {
	$LOGFILE = "$ML_DIR/$ml/log";
	&Touch($LOGFILE) unless -f $LOGFILE;
    }

    # Lock all when "install"
    if ($TheFirstTime || $NOT_LOCK{$fp}) {
	;
    }
    else {
	&MakeFmlLock($fp eq 'install' ? "" : $argv[0], $ML_DIR);
    }

    if ($MakeFmlProc{$fp}) {
	local($fp) = $MakeFmlProc{$fp};	# not overwrite $fp for later use;
	local($fn) = $fp; $fn =~ s/do_//;
	&Log("makefml::${fn} @argv ") if $fp ne "do_install";
	&$fp(@argv);
    }
    else {
	print "   Command [$fp] NOT DEFINED\n";
	print "   Please see the document 'INSTALL'\n\n";
	return;
    }

    # Unlock;
    if ($TheFirstTime || $NOT_LOCK{$fp}) {
	;
    }
    else {
	&MakeFmlUnLock($fp eq 'install' ? "" : $argv[0], $ML_DIR);
    }
}


sub gets
{
    local($.);
    $_ = <IN>;
}


sub GetString
{
    local($s);

    $s = &gets;

    # ^D
    if ($s eq "")  { print STDERR "'^D' Trapped.\n"; exit 0;}
    chop $s;

    $s;
}


sub FixPath
{
    local($prog) = @_;
    local($perl);

    if ($COMPAT_ARCH eq "WINDOWS_NT4") { 
	$perl = "";
    }
    else {
	$perl = &search_path('perl');
    }

    open(PROG, $prog) || (&Warn("cannot open $prog"), return);
    open(NEW, "> $prog.new") || (&Warn("cannot open $prog.new"), return);
    select(NEW); $| = 1; select(STDOUT);

    while (<PROG>) {
	if ($. == 1) {
	    print NEW "\#\!$perl\n" if $perl;
	    next;
	}

	next if /^\#\#\# AUTOMATICALLY REPLACED/;

	# recreate my own;
	if ($prog =~ /makefml/ && 
	    /__MAKEFML_AUTO_REPLACED_HERE__/ && /^\$CONFIG_DIR/) {
	    #print STDERR "----Replace makefml::\$CONFIG_DIR -> $CONFIG_DIR\n";
	    print NEW "### AUTOMATICALLY REPLACED by makefml ($MailDate)\n";
	    print NEW "\$CONFIG_DIR = '$CONFIG_DIR'; ";
	    print NEW "\# __MAKEFML_AUTO_REPLACED_HERE__\n";
	    next;
	}

	print NEW $_;
    }
    close(NEW);
    close(PROG);
    # sleep 1;

    if ($COMPAT_ARCH eq "WINDOWS_NT4") { 
	unlink "${prog}.bak" if -f "${prog}.bak";
	&Copy($prog, "${prog}.bak");
	&Copy("${prog}.new", $prog);
    }
    else {
	rename($prog, "${prog}.bak") || &Warn("cannot rename $prog $prog.bak");
	rename("${prog}.new", $prog) || &Warn("cannot rename $prog.new $prog");
    }
}


sub search_path
{
    local($f) = @_;
    local($path) = $ENV{'PATH'};
    local(@path) = split(/:/, $path);

    # too pesimistic?
    for ("/usr/local/bin", "/usr/share/bin", 
	 "/usr/contrib/bin", "/usr/gnu/bin", 
	 "/usr/bin", "/bin", "/usr/gnu/bin", "/usr/ucb",
	 # NT Extention
	 "/perl5/bin" ) {
	push(@path, $_);
    }

    for (@path) { if (-f "$_/$f") { return "$_/$f";}}
}


############ CFVersion 2 -> 3 

### convert CF2 -> CF3
sub ConvertCF2to3
{
    local(*config, *MAKE_FML) = @_;

    print STDERR "--ConvertCF2to3\n" if $verbose || $debug;

    ### Section: config
    @config = ("CFVersion",
	       "DOMAINNAME",
	       "FQDN",
	       "debug",
	       "MAINTAINER",
	       "MAIL_LIST",
	       "PERMIT_POST_FROM",
	       "REJECT_POST_HANDLER",
	       "CONTROL_ADDRESS",
	       "PERMIT_COMMAND_FROM",
	       "REJECT_COMMAND_HANDLER",
	       "AUTO_REGISTRATION_TYPE",
	       "AUTO_HTML_GEN",
	       "ML_FN",
	       "XMLNAME",
	       "XMLCOUNT",
	       "BRACKET",
	       "SUBJECT_TAG_TYPE");

    ### Section: Remove obsolete variable
    undef $config{"ML_MEMBER_CHECK"};

    $config{"CFVersion"} = 3;

    ### Section: Acces Policy and Auto Registration

    # default 
    $config{"PERMIT_POST_FROM"}       = "members_only";
    $config{"PERMIT_COMMAND_FROM"}    = "members_only";
    $config{"REJECT_POST_HANDLER"}    = "reject";
    $config{"REJECT_COMMAND_HANDLER"} = "reject";
    $config{"AUTO_REGISTRATION_TYPE"} = "confirmation";

    if ($MAKE_FML{'AUTO_REGIST_WITH_CONFIRM'}) {
	undef $MAKE_FML{'AUTO_REGIST_WITH_CONFIRM'};

	$config{"REJECT_POST_HANDLER"}    = "auto_regist";
	$config{"REJECT_COMMAND_HANDLER"} = "auto_regist";
	$config{"AUTO_REGISTRATION_TYPE"} = "confirmation";
    }

    if ($MAKE_FML{"DELIVERY_MODE"} eq "distribute") {
	$config{"PERMIT_POST_FROM"} = "anyone";
    }
    elsif ($MAKE_FML{"DELIVERY_MODE"} eq "distribute_with_member_check") {
	$config{"PERMIT_POST_FROM"} = "members_only";
    }
    undef $MAKE_FML{"DELIVERY_MODE"};

    ### Section: Subject Tag
    if ($MAKE_FML{"SUBJECT_TAG"}) {
	$config{"SUBJECT_TAG"} = $MAKE_FML{"SUBJECT_TAG"};
	undef $MAKE_FML{"SUBJECT_TAG"};
    }

    ### Section: Options
    $config{'USE_MIME'} = $MAKE_FML{'OPT_MIME'};
    undef $MAKE_FML{'OPT_MIME'};

    ### Version 3 
    $config{'REMOTE_ADMINISTRATION_AUTH_TYPE'} = "crypt";
    $config{'PGP_PATH'} = "$ML_DIR/$ml/etc/pgp";
}


# USE_MIME is an exception of treatment
# USE_MIME 1 and $MAKE_FML{OPT_MIME} = 1
# since we show the menu determined by %MAKE_FML values;
sub OutPutLocalConfig
{
    local(*MAKE_FML) = @_;
    local($output_count);

    ### %MAKE_FML
    while (($k, $v) = each %MAKE_FML) {
	next unless $v;
	print STDERR "MAKE_FML\t$k\t=>$v\n" if $debug;
    }


    ### output of other configurations
    print CF "\n\n\nLOCAL_CONFIG\n\n";
    print CF "\#__MAKEFML_LOCAL_CONFIG__\n";
    print CF "\# configured by $0 on $MailDate\n";
    print CF "\# *** DO NOT EDIT MANUALLY THIS BLOCK!!! ***\n";


    ### POINT!!!
    ### $local_config .= $_ if /\$MAKE_FML/;
    while (($k, $v) = each %MAKE_FML) {
	printf STDERR "   \$MAKE_FML %-20s -> %s\n", $k, $v if $debug;
	next unless $v;
	undef $MAKE_FML{$k}; # ATTENTION! RESET HERE;
    }

    # abnormal
    for (keys %MAKE_FML) {
	$value = $MAKE_FML{$_};
	next unless $value;
	$value = ($value =~ /^\d+$/) ? $value : "\"$value\"";

	print CF "\$MAKE_FML{'$_'} = $value;\n";
	$output_count++;
    }

    # CFVersion 2
    if ($output_count && !$config{"CFVersion"}) {
	print CF "require 'libmakefml.pl';\n";
	print CF "&ConfigByMakeFml;\n";
    }

    # output to $DIR/cf
    print CF "\#__END_OF_MAKEFML_LOCAL_CONFIG__\n";
    print CF "\n\n\# YOU CAN EDIT MANUALLY AFTER HERE.\n\n";
    print CF "$USER_DEFINED_LOCAL_CONFIG\n";

    printf STDERR "\n---END OF MAKE_FML OUTPUT\n\n", $k, $v if $debug;
}



sub Query
{
    local($menu, $query, $pat, $default) = @_;
    
    print "Query(debug): ($menu, $query, $pat, $default)\n" if $debug;
    print "\n";

    while (1) {
	#print "menu={$menu} query={$query}\n";
	print "${CurTag}${menu} ($query) [$default] ";
	$cmd = &GetString;
	print "\n";

	if ($cmd =~ /^($pat)$/) { last;}
	if ($cmd =~ /^\s*$/) { $cmd = $default; last;}

	print "$CurTag   *** WARNING! Please input one of ($query) ***\n\n";
    }    

    $cmd;
}


sub ResetVariables
{
    # anyway set;
    &GetCurConfig;

    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	$USER = $ENV{'USERNAME'};
    }
    else {
	$USER = (getpwuid($<))[0];
    }

    $EXEC_DIR = $CurConfig{'EXEC_DIR'};
    $ML_DIR   = $CurConfig{'ML_DIR'};
    $DOMAIN   = $CurConfig{'DOMAIN'};
    $FQDN     = $CurConfig{'FQDN'};
    $GID      = &GetGID($CurConfig{'GROUP'}) if $CurConfig{'GROUP'};
    $LANGUAGE = $CurConfig{'LANGUAGE'};

    if ($CurConfig{'GROUP'} && !$GID) { 
	print "Group of ML operatos is not defined in /etc/group\n";
	print "Please define it in first!\n";
	exit 0;
    }

    if ($CurConfig{'PERSONAL_OR_GROUP'} =~ /^(group|fmlserv)$/) {
	$GroupWritable = $CurConfig{'PERSONAL_OR_GROUP'};
    }
    else {
	$GroupWritable = 0;	
    }

    $ML_ETC_DIR = "$ML_DIR/etc";

    # Mailing list name is all lower case;
    # $ml =~ tr/A-Z/a-z/;
    if ((! $NOT_CHECK_ML_EXIST) && $ml && (! -d "$ML_DIR/$ml")) {
	die("Cannot find $ml. you've not created it yet?\n");
    }
}


sub GenCrontab
{
    local($uid);

    print STDERR "\n";
    print STDERR "Crontab for all ${USER}'s ML's is saved in";
    print STDERR " $ML_ETC_DIR/crontab/$USER\n";

    open(TAB, "> $ML_ETC_DIR/crontab/$USER") || 
	(&Warn("cannot open $ML_ETC_DIR/crontab/$USER"), return);
    select(TAB); $| = 1; select(STDOUT);

    opendir(DIRD, $ML_DIR) || (&Warn("cannot open $ML_DIR"), return);
    for (readdir(DIRD)) {
	next if /^\./;

	$uid = (stat("$ML_DIR/$_/crontab"))[4];

	# if $uid == real-UID;
	if (($uid == $<) && -f "$ML_DIR/$_/crontab") {
	    if (open(CRONTAB, "$ML_DIR/$_/crontab") ) {
		while (<CRONTAB>) { print TAB $_;}
		close(CRAONTAB);
	    }
	}

    }
    closedir(DIRD);

    close(TAB);
}


sub Repl
{
    local($member, $file) = @_;
    local($mode) = (stat($file))[2];
     
    open(F, $file)           || (&Warn("cannot open $file"), return 0);
    open(NEW, "> $file.new") || (&Warn("cannot open $file.new"), return 0);
    select(NEW); $| = 1; select(STDOUT);

    while (<F>) {
	/^$member/ && $found++;
	s/^\#\s*$member/\#\#BYE $member/i; # off;
	s/^$member/\#\#BYE $member/i;
	print NEW $_;
    }

    close(NEW);
    close(F);

    rename($file, "${file}.bak") || 
	(&Warn("cannot rename $file $file.bak"), return 0);
    rename("${file}.new", $file) ||
		(&Warn("cannot rename $file.new $file"), return 0);

    chmod $mode, $file;
    $found;
}


sub Mesg { print STDERR "$_[1]\n";}


sub Conv
{
    local($ml, $example, $out) = @_;
    local($uid, $gid, $format);

    # &ApplyPolicy;

    $format = $Policy{'CONTROL_ADDRESS_FORMAT'};

    if ($debug) {
	print STDERR "\tCONTROL_ADDRESS_FORMAT\t$format\n";
    }

    open(EXAMPLE, $example)  || (&Warn("cannot open $example"), return 0);
    open(CF, "> $out")       ||  (&Warn("cannot open $out"), return 0);
    select(CF); $| = 1; select(STDOUT);
    
    print STDERR "\tGenerating $out\n";

    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	$USER = $ENV{'USERNAME'};
    }
    else {
	$uid   = $uid || (getpwuid($<))[2];
	$gid   = $gid || (getpwuid($<))[3];
    }


    while (<EXAMPLE>) {
	# substitute following the policy default
	if ($format) {
	    # 
	    # exception: CtlAddr == fmlserv || MAIL_LIST
	    if ($format =~ /^(fmlserv|_ML_)$/) {
		# aliases: remove the entry
		if ($example =~ /aliases$/ && /^_ML_-ctl:/) {
		    local($repl) = 
			"\# _ML_-ctl is not used. comment out\n\# _ML_-ctl";
		    s/^_ML_-ctl/$repl/;
		}

		# cf file: null entry if CtlAddr == _ML_
		if ($example =~ /cf$/ && $format eq '_ML_') {
		    s/^(CONTROL_ADDRESS).*/$1/;
		}
		elsif ($example =~ /cf$/ && $format eq 'fmlserv') {
		    s/_ML_-ctl/fmlserv/;
		}
	    }
	    # 
	    # CtlAddr != fmlserv NOR _ML_
	    else {
		s/_ML_-ctl/$format/g;
	    }
	}
	
	s/_EXEC_DIR_/$EXEC_DIR/g;
	s/_ML_DIR_/$ML_DIR/g;
	s/_ML_/$ml/g;
	s/_DOMAIN_/$DOMAIN/g;
	s/_FQDN_/$FQDN/g;
	s/_USER_/$USER/g;
	s/_OPTIONS_/$opts/g;
	s/_CPU_TYPE_MANUFACTURER_OS_/$CPU_TYPE_MANUFACTURER_OS/g;
	s/_STRUCT_SOCKADDR_/$STRUCT_SOCKADDR/g;
	s/XXUID/$uid/g;
	s/XXGID/$gid/g;


	if (/dev\.null.*\@domain\.uja/) {
	    s/domain\.uja/$DOMAIN/g;
	    s/dev\.null/$ml/g;
	}

	print CF $_;
    }

    close(EXAMPLE);
    close(CF);
}


sub Touch  { open(APPEND, ">> $_[0]"); close(APPEND);}

sub GetTime
{
    @WDay = ('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat');
    @Month = ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
	      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec');
    
    ($sec,$min,$hour,$mday,$mon,$year,$wday) = (localtime(time))[0..6];
    $Now = sprintf("%2d/%02d/%02d %02d:%02d:%02d", 
		   $year, $mon + 1, $mday, $hour, $min, $sec);
    $MailDate = sprintf("%s, %d %s %d %02d:%02d:%02d %s", 
			$WDay[$wday], $mday, $Month[$mon], 
			$year, $hour, $min, $sec, $TZone);

    # /usr/src/sendmail/src/envelop.c
    #     (void) sprintf(tbuf, "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
    #                     tm->tm_mon+1, tm->tm_mday, tm->tm_hour, tm->tm_min);
    # 
    $CurrentTime = sprintf("%04d%02d%02d%02d%02d", 
			   1900 + $year, $mon + 1, $mday, $hour, $min);
}


sub FixIncludeHeader
{
    local($file, $include, @include, $INCDIR);

    $include =q#sys/types.h unistd.h#;
    @include = split(/\s+/, $include);
    $INCDIR  = '/usr/include';

    &ResetVariables;

    print STDERR "\tGenerating $ML_DIR/$ml/config.h\n";

    if (open(GUESS, "> $ML_DIR/$ml/config.h")) {
	foreach $file (@include) {
	    if ( -f "$INCDIR/$file" ) {
		print GUESS "\#include <$file>\n";
	    }
	    else {
		# print STDERR "Not Found $INCDIR/$file\n";
	    }
	}

	close(GUESS);
    }
}


#################################################################
sub do_help
{
    print "makefml:\n";
    print "   available commands\nt";
    print join("\n\t", (keys %MakeFmlProc));
    print "\n\n";
}


sub do_passwd
{
    local($ml, $member, $passwd) = @_;
    local($passwd_file);

    print "---Changing Passwd of Admin $member in $ml mailing list\n";

    &ResetVariables;

    # $ml/etc
    &MakeSubDir("$ML_DIR/$ml/etc");

    # here we go! 
    &SetWritableUmask;
    $passwd_file= "$ML_DIR/$ml/etc/passwd";

    -f $passwd_file || &Touch($passwd_file);

    while (!$member || !$passwd) {
	if (! $member) {
	    print "Address: ";
	    chop($member = <STDIN>);
	}
	else {
	    print "Address: $member\n";
	}

	if (! $passwd) {
	    # no echo
	    system "stty", "-echo";

	    print "Password: ";
	    chop($passwd = <STDIN>);
	    print "\n";

	    system "stty", "echo";
	}

	if (!$member || !$passwd) {
	    &Warn("Error: Please input NOT NULL Address and Password.");
	    &Log("makefml::passwd address is not defined")  if !$member;
	    &Log("makefml::passwd password is not defined") if !$passwd;
	}
    }

    require 'libcrypt.pl';
    $init = 1;	# if new-comer, initialize the passwd;

    print "\n";

    if (&ChangePasswd($passwd_file, $member, $passwd, $init)) {
	print "   Passwd Changed ($passwd_file).\n";
	&Log("makefml::passwd changing $passwd_file succeed");
    }
    else {
	print "   Passwd Change Fails ($passwd_file).\n";
	&Log("makefml::passwd changing $passwd_file fails");
    }

}


sub do_info
{
    print STDERR "*" x 60; print STDERR "\n";
    print STDERR "makefml Usage:\n\n";

    printf STDERR "   makefml %-20s %s\n", "command arguments", "what";
    print STDERR "   ".("-"x57)."\n\n";

    for (sort {$a <=> $b} keys %MakeFmlProc) {
	next unless /^\d+\#/;
	$usage = $MakeFmlProc{$_};

	s/^(\d+\#)//;

	printf STDERR "   makefml %-20s %s\n", $_, $usage;
    }

    print STDERR "\n";
    print STDERR "*" x 60; print STDERR "\n";
    print STDERR "\n";
    print STDERR "HOW TO INSTALL:\n";
    print STDERR "Please input \"perl makefml install\" to INSTALL the fml\n";
    print STDERR "\n";
}


sub do_install
{
    local($cmd);

    $InstallMode = 1;

    # main proc -> here;
    &InitFmlConfig;

    # do_init
    {
	&ResetVariables;

	if (! -d $EXEC_DIR) {
	    print "   mkdir $EXEC_DIR\n";
	    mkdir($EXEC_DIR, 0755);		
	}

	if (! -d $ML_DIR) {
	    print "   mkdir $ML_DIR\n";
	    &MakeWritableDir($ML_DIR);
	}
    }

    $cmd = &Query("---Install the Fml system to $CurConfig{'EXEC_DIR'}.", 
		  "y/n", "y|n", "n");

    if ($cmd ne 'y') {
	print "STOP. (DO NOT INSTALLED)\n";
	return;
    }
    else {
	print "Installing fml system to $Config'EXEC_DIR\n"; #';
    }

    ### Fixing perl path ###
    {
	print STDERR "Fixing Path:";

	print STDERR " src ";
	&FixPath("src/fml.pl");   print STDERR ".";
	&FixPath("src/msend.pl"); print STDERR ".";
	
	print STDERR " libexec ";
	for (<libexec/*.pl>){ &FixPath($_); print STDERR ".";}

	print STDERR " sbin ";
	&FixPath("sbin/makefml"); print STDERR ".";

	print STDERR " cf ";
	&FixPath("cf/config"); print STDERR ".";

	# bin/*.pl
	print STDERR " bin ";
	for (<bin/*.pl>){ &FixPath($_); print STDERR ".";}

	print STDERR "\n\tDone.\n";
    }

    &ResetVariables;

    # /var/spool/ml/etc/
    # etc can be group-writable for crontab/each-user
    if ($GroupWritable) {
	print STDERR "Group Writable\n" if $debug;
	print STDERR "mkdir $ML_ETC_DIR\n" if $debug;;
	&MakeWritableDir($ML_ETC_DIR);
    }
    else {
	print STDERR "Personal Use\n" if $debug;;
	print STDERR "mkdir $ML_ETC_DIR\n" if $debug;;
	&MakeWritableDir($ML_ETC_DIR);
    }

    # $EXEC_DIR/sbin/install.sh is NOT yet installed 
    if ($COMPAT_ARCH eq "WINDOWS_NT4") {
	&Log("makefml windows NT4 mode");
	print "perl sys/arch/WINDOWS_NT4/ntinstall.pl $EXEC_DIR\n";
	system "perl sys/arch/WINDOWS_NT4/ntinstall.pl $EXEC_DIR";
    }
    elsif (-f "sbin/install.sh") {
	$SH = $ENV{'SH'} || "/bin/sh";
	system "$SH ./sbin/install.sh $EXEC_DIR";
	eval symlink($CONFIG_DIR, "$EXEC_DIR/Configurations");
    }
    else {
	print "Please do \"makefml\" in the top directory of the source\n";
    }

    if ($GroupWritable eq 'fmlserv') {
	$cmd = &Query("Set up \"fmlserv\" system now? ", "y/n", "y|n", "n");
	if ($cmd eq 'y') { &ExecCmd("fmlserv");}
    }

    &FYI;

    # CFVersion 2
    # &FYIPolicy;
}


sub do_setq
{
    #print STDERR "setq \$Config'$_[0] = '$_[1]';\n"  if $debug;;
    eval("\$Config'$_[0] = '$_[1]';");
    print "$@\n--@_\n" if $@;
}


sub GenerateDirectory
{
    local($ml) = @_;

    ### umask;
    $NOT_CHECK_ML_EXIST = 1;
    &ResetVariables;
    $NOT_CHECK_ML_EXIST = 0;

    ### mkdir ML Directory
    # group writable;
    # etc, etc/crontab can be group-writable for crontab/each-user
    if ($GroupWritable) {
	print STDERR "Group Writable\n"  if $debug;;
	print STDERR "mkdir etc crontab\n" if $debug;;
	&MakeWritableDir($ML_ETC_DIR);
	&MakeWritableDir("$ML_ETC_DIR/crontab");
    }
    else {
	print STDERR "Personal Use\n" if $debug;;
	print STDERR "mkdir etc crontab\n" if $debug;;
	&MakeWritableDir($ML_ETC_DIR);
	&MakeWritableDir("$ML_ETC_DIR/crontab");
    }

    # owner only read-write
    # umask(077);
    &MakeDir("$ML_DIR/$ml");
    &MakeDir("$ML_DIR/$ml/spool"); # required for further flock
}


sub do_new { &do_newml(@_);}
sub do_newml
{
    local($ml) = @_;
    local($cf, $local_config, $config, @config, %config);

    if (! $ml) {
	&Log("Error: makefml::newml ML is not defined");

	&Debug("*** Error: no arguments ***");
	&Debug("Please define ML(mailing-list) arguments");
	&Debug("\n\tmakefml newml ML\n");
	return;
    }

    if ($< == 0) {
	&Log("Error: makefml::newml you should not run newml as root.");

	print "************************* WARNING *************************\n";
	print "\n";
	print "    YOU WILL OPERATE A MAILING LIST as ROOT?\n";
	print "    IT IS VERY DANGEROUS!\n";
	print "    YOU SHOULD RUN MAILING LIST AS A NON-PRIVILEGED USER\n";
	print "\n";
	print "***********************************************************\n";
	sleep 10;
    }


    print "---Creating $ml mailing list\n";

    # &ApplyPolicy;

    &GenerateDirectory($ml);
    &ResetVariables;

    ### cf file; 
    # &SetWritableUmask; &SetPublicUmask;
    &SetPersonalUmask;	# umask 077;

    &Conv($ml, "$EXEC_DIR/etc/makefml/cf", "$ML_DIR/$ml/cf");

    if (($OS_TYPE || $CPU_TYPE_MANUFACTURER_OS)
	 && open(CF, ">> $ML_DIR/$ml/cf")) {
	# CFVersio 2;
	# $MAKE_FML{'NON_PORTABILITY'} = 1;
	# $MAKE_FML{'CPU_TYPE_MANUFACTURER_OS'} = $CPU_TYPE_MANUFACTURER_OS;

	$MAKE_FML{'OS_TYPE'} = $OS_TYPE;

	# conversion here; since cf/config can be overwrittern 
	&OutPutLocalConfig(*MAKE_FML);
	close(CF);
    }
    else {
	print STDERR "\n";
	print STDERR "\$OS_TYPE NOR \$CPU_TYPE_MANUFACTURER_OS NOT DEFINED\n";
	print STDERR "STOP!\n";
	return;
    }

    ### cf fixed
    if ($MAIL_LIST_MODE) {
	$cf = "$ML_DIR/$ml/cf";
	&GetCF($cf, *config); # set %config, eval %MAKE_FML in it;
	$MAKE_FML{"DELIVERY_MODE"} = $MAIL_LIST_MODE;
	print STDERR "MODE $MAKE_FML{'DELIVERY_MODE'}\n";
	&SaveCF($cf, *config);
    }

    &ResetVariables;
    &SetPublicUmask;


    # include file is public readable;
    # why for () fails?;
    &Conv($ml, "$EXEC_DIR/etc/makefml/include", "$ML_DIR/$ml/include");
    &Conv($ml, "$EXEC_DIR/etc/makefml/include-ctl", "$ML_DIR/$ml/include-ctl");
    &Conv($ml, "$EXEC_DIR/etc/makefml/aliases", "$ML_DIR/$ml/aliases");
    &Conv($ml, "$EXEC_DIR/etc/makefml/Makefile","$ML_DIR/$ml/Makefile");

    &SetPersonalUmask;	# umask 077;

    &Conv($ml, "$EXEC_DIR/etc/makefml/crontab", "$ML_DIR/$ml/crontab");
    &Conv($ml, "$EXEC_DIR/etc/makefml/fml.c",   "$ML_DIR/$ml/fml.c");
    &FixIncludeHeader;

    # fmlserv (uid != owner ) can read help
    ($GroupWritable eq 'fmlserv') ? umask(027) : umask(077);

    # drafts -> help,deny,guide,objective
    # Japanese;
    if ($LANGUAGE eq 'Japanese') {
	&Conv($ml, "$EXEC_DIR/drafts/help", "$ML_DIR/$ml/help");
	&Conv($ml, "$EXEC_DIR/drafts/help-admin", "$ML_DIR/$ml/help-admin");
	&Conv($ml, "$EXEC_DIR/drafts/deny", "$ML_DIR/$ml/deny");
	&Conv($ml, "$EXEC_DIR/drafts/guide", "$ML_DIR/$ml/guide");
	&Conv($ml, "$EXEC_DIR/drafts/welcome", "$ML_DIR/$ml/welcome");
	&Conv($ml, "$EXEC_DIR/drafts/confirm", "$ML_DIR/$ml/confirm");
	&Conv($ml, "$EXEC_DIR/drafts/objective", "$ML_DIR/$ml/objective");    
    }
    # English;
    else {
	&Conv($ml, "$EXEC_DIR/drafts/help.English", "$ML_DIR/$ml/help");
	&Conv($ml, "$EXEC_DIR/drafts/help-admin.English", 
	      "$ML_DIR/$ml/help-admin");
	&Conv($ml, "$EXEC_DIR/drafts/deny.English", "$ML_DIR/$ml/deny");
	&Conv($ml, "$EXEC_DIR/drafts/guide.English", "$ML_DIR/$ml/guide");
	&Conv($ml, "$EXEC_DIR/drafts/welcome.English", "$ML_DIR/$ml/welcome");
	&Conv($ml, "$EXEC_DIR/drafts/confirm.English", "$ML_DIR/$ml/confirm");
	&Conv($ml, "$EXEC_DIR/drafts/objective.English", 
	      "$ML_DIR/$ml/objective");
    }

    # here backed to the writable bit == 077 or 007
    &SetWritableUmask;
    &SetPersonalUmask;	# umask 077;

    &GenCrontab;

    &MakeConfigPH("$EXEC_DIR/cf/config", "$EXEC_DIR/cf/MANIFEST", 
		  "$ML_DIR/$ml/cf", "$ML_DIR/$ml/config.ph");

    # print message;
    # the last info
    print "\n   Please see several examples in $ML_DIR/$ml\n";
    print "\n# Example of Aliases ($ML_DIR/$ml/aliases)\n";
    &Cat("$ML_DIR/$ml/aliases");
    print "\n";
}


sub do_test
{
    local($ml) = @_;
    local($cf);

    print "---Testing $ml mailing list ... \n";

    &ResetVariables;
    &GetTime;

    local($input, $exec, $dir);
    $input = "$EXEC_DIR/bin/emumail.pl";
    $exec  = "$EXEC_DIR/fml.pl";
    $dir   = "$ML_DIR/$ml";

    chdir $dir || die("cannot chdir ML directory[$dir]\n");
    $SYSTEM_ARGV = "$input|$exec $dir -d";

    print STDERR "test() { $SYSTEM_ARGV }\n" if $debug;
}


# here eval $local_config since here is the phase evaluating CF;
sub GetCF
{
    local($cf, *config) = @_;
    local($local_config, %uniq, $cf_template);

    # template -> @ConfigOrder (with comments)
    $cf_template = "$EXEC_DIR/etc/makefml/cf";
    open(CF, $cf_template) || die ("cannot open cf template[$cf_template]");
    while (<CF>) {
	chop;

	if (/^\#/ || /^\s*$/) {
	    push(@ConfigOrder, $_);
	}
	else {
	    ($key, $value) = split(/\s+/, $_, 2);
	    push(@ConfigOrder, $key);
	}
    }
    close(CF);


    # GET PRESENT CONFIG;
    # without LOCAL_CONFIG;
    open(CF, $cf) || die ("cannot open cf[$cf]");
    while (<CF>) {
	next if /^\s*$/;
	chop;

	if (1 .. /LOCAL_CONFIG/) {
	    # required here,not required in the next section;
	    if (/^\#/) { next;}

	    next if /^LOCAL_CONFIG/; # just "cf"(for cf/config) statements;

	    ($key, $value) = split(/\s+/, $_, 2);
	    $config{$key} = $value; # entry can be overwritten;
	    push(@config, $key) unless $uniq{$key}; # entry is unique;
	    $uniq{$key}   = 1;	# unique

	    print STDERR "\$config{$key} = [$value]\n" if $debug;
	}
	else {
	    next if /^LOCAL_CONFIG/;
	    next if /^\# YOU CAN EDIT MANUALLY AFTER HERE/;
	    next if /^\# configured by \S+makefml/;

	    if (/^\#__MAKEFML_LOCAL_CONFIG__/ .. 
		/^\#__END_OF_MAKEFML_LOCAL_CONFIG__/) {
		$local_config .= $_ if /\$MAKE_FML/;
	    }
	    else {
		$USER_DEFINED_LOCAL_CONFIG .= "$_\n";
	    }
	}
    }

    # set local_config -> %MAKE_FML;
    # print $local_config if $debug;
    eval($local_config);
    print $@ if $@;

    # CFVerion 2 -> 3; Backward Compatilitity 
    if (!$config{"CFVersion"} || 
	$config{"CFVersion"} < 3 ||
	$COMPAT_CF2) {
	print STDERR "   (config.ph; connvert \$CFVersion 2 -> 3)\n\n";	
	&Log("makefml::config convert config.ph::\$CFVersion 2 -> 3");
	&ConvertCF2to3(*config, *MAKE_FML);
    }
    else {
	print STDERR "   (config.ph; \$CFVersion 3)\n\n";
    }
}


# makefml pgp elena PGP-OPTIONS
sub do_pgp
{
    local($ml, @argv) = @_; 

    &GetCF($cf, *config); # set %config, eval %MAKE_FML in it;

    &MkDirHier($config{'PGP_PATH'});

    $ENV{'PGPPATH'} = $config{'PGP_PATH'};

    $| = 1;
    print "\n--- PGP BEGIN ---\n\n";
    &Log("makefml::pgp pgp @argv");
    system("pgp @argv");
    print STDERR "Error: $@" if $@;

    print "\n--- PGP END ---\n\n";

    if ($GroupWritable) {
	chmod 0660, "$config{'PGP_PATH'}/pubring.pgp";	
    }
}


sub Mkdir
{
    &Log("makefml::mkdir $_[0]");

    $USE_FML_WITH_FMLSERV ? mkdir($_[0], 0770) : mkdir($_[0], 0700);
    if ($USE_FML_WITH_FMLSERV && $SPOOL_DIR eq $_[0]) { chmod 0750, $_[0];}
    if ($USE_FML_WITH_FMLSERV && $GID) { chown $<, $GID, $_[0];}
}


sub MkDirHier
{
    local($dir) = @_;
    local($d);

    &Log("makefml::mkdirhier $_[0]");

    for (split(/\//, $dir)) {
	$d .= "/$_";
	$d =~ s#//#/#g;
	if (! -d $d) {
	    print STDERR "making directory $d ...\n";
	    &Mkdir($d);
	}
    } 
}


sub do_edit
{
    local($ml) = @_;
    local($cf, $local_config, $config, @config, %config);

    $editor = $ENV{'EDITOR'} || "vi";

    print STDERR "\n\t$editor $ML_DIR/$ml/config.ph\n\n";
    &Log("makefml::edit $editor $ML_DIR/$ml/config.ph");

    system "$editor $ML_DIR/$ml/config.ph";

    &Log("makefml::edit operation ends");
}


sub do_config
{
    local($ml) = @_;
    local($cf, $local_config, $config, @config, %config);
    local(%saved_config);

    # start;
    print "---Configure $ml mailing list ... \n";

    # Variable Settings;
    &ResetVariables;
    $cf = "$ML_DIR/$ml/cf";

    # evaluate "$ML_DIR/$ml/cf";
    &GetCF($cf, *config); # set %config, eval %MAKE_FML in it;

    # internal use
    $config{'_ML_'} = $ml;
    ($config{'_CA_DOMAIN_'}) = (split(/\@/, $config{'CONTROL_ADDRESS'}))[1];
    

    ### MENU BEGIN
    # for log
    %saved_config = %config;

    # menu.conf version
    $MENU = "$EXEC_DIR/etc/makefml/menu.conf";
    &Menu'InitMenu(*config,*MENU,*FP,*QUERY,*NAME,*MAP,*BIND,*CONFIG);#';

    ### MAIN LOOP 
    &EachLevelQuery(*config, "/");

    for (keys %config) {
	if ($config{$_} ne $saved_config{$_}) {
	    &Log("makefml::config \$${_} \"$saved_config{$_}\" -> \"$config{$_}\"");
	}
    }
    ### MENU END 

    # set local_config -> %MAKE_FML;
    # print $local_config;
    $eval = q%eval $local_config;%;
    eval($eval);
    print $@ if $@;

    if (open(CF, "> $cf")) {
	&SaveCF($cf, *config);
    }
    else {
	&Log("Error makefml::config cannot save to cf file");
	&Warn("Cannot open cf[$cf]");
	return;
    }

    # make ml/config.ph
    &MakeConfigPH("$EXEC_DIR/cf/config", "$EXEC_DIR/cf/MANIFEST", 
		  $cf, "$ML_DIR/$ml/config.ph");

    &Log("makefml::config operation ends");
}


sub EachLevelQuery 
{
    local(*config, $top_level) = @_;
    local($r);

    while ($top_level =~ s|^//|/|) { ;}

    $Depth++;

    while (1) {
	$CurTag = "   " x $Depth;

	# required?
	# &Log("makefml::config menu $top_level");

	&EvalMenu($top_level, *config, *BIND, *MENU, *COUNT, *MAP);

	print "   ".("*" x 60); print "\n";
	print "   [$Depth $top_level]\n\n" if $debug;
	print $MENU{$top_level};
	print "   ".("*" x 60); print "\n";

	&Menu'GenQuery(*query, $QUERY{$top_level}, $top_level); #';
	$r = &Query($query{'menu'}, $query{'query'}, 
		    $query{'pat'}, $query{'default'});

	if ($query{"type"} eq "y-or-n") {
	    print "--query y/n\n";
	    $v   = $CONFIG{$top_level};
	    &Debug("\$config{$v} = $r eq 1 ? 1 : 0;");

	    if ($v) {
		$config{$v} = $r eq "y" ? 1 : 0;
	    }
	    else {
		&Debug("EachLevelQuery(y/n): Error, $v is not defined");
	    }

	    last;
	}
	elsif ($query{"type"} eq "reverse-y-or-n") {
	    print "--query y/n\n";
	    $v   = $CONFIG{$top_level};
	    &Debug("\$config{$v} = $r eq 1 ? 1 : 0;");

	    if ($v) {
		$config{$v} = $r eq "y" ? 0 : 1;
	    }
	    else {
		&Debug("EachLevelQuery(y/n): Error, $v is not defined");
	    }

	    last;
	}
	elsif ($query{"type"} eq "select" && ($r == 0)) {
	    last;
	}
	else {
	    $lvl = $BIND{$top_level, $r};

	    # check in the current level
	    if ($v = $CONFIG{$top_level}) {
		$config{$v} = 
		    $MAP{$top_level, $r} ne "" ? $MAP{$top_level, $r} : $r;
		undef $config{$v} if $config{$v} eq "_NULL_";
	    }
	    else {
		&EachLevelQuery(*config, "$top_level/$lvl");
	    }
	}
    }

    $Depth--;
}


sub SaveCF
{
    local($cf, *config) = @_;
    local(%uniq);

    # fix
    $config{'CPU_TYPE_MANUFACTURER_OS'} = $CPU_TYPE_MANUFACTURER_OS;
    $config{'STRUCT_SOCKADDR'}          = $STRUCT_SOCKADDR;

    if (open(CF, "> $cf")) {
	select(CF); $| = 1; select(STDOUT);

	# believe the config conservation
	# undef $config{'NON_PORTABILITY'};
	# undef $config{"COMPAT_$OS_TYPE"};

	print CF "\# $MailDate(configured by $0)\n\n";

	# configurable variable <=> %config entries;
	push(@config, keys %config);
	&Uniq(*config);

	for (@ConfigOrder, @config) {
	    if (/^\#/ || /^\s*$/) {
		printf CF "$_\n";
		next;
	    }

	    next if $uniq{$_}; $uniq{$_} = 1;

	    print STDERR "-config: $_\n" if $debug;

	    # skip internal and obsolete entries
	    next if /^_\S+_/; # internal use variables e.g. _ML_
	    next if $_ eq 'NON_PORTABILITY';
	    next if $_ eq "COMPAT_${OS_TYPE}";

	    # may be 0 is true value ($debug = 0);
	    printf CF "%-25s\t%s\n", $_, $config{$_};
	    undef $config{$_};
	}

	# CFVersion 2;
	# $MAKE_FML{'OS_TYPE'}         = $OS_TYPE;
	# $MAKE_FML{'NON_PORTABILITY'} = 1;
	# $MAKE_FML{'CPU_TYPE_MANUFACTURER_OS'} = $CPU_TYPE_MANUFACTURER_OS;

	&OutPutLocalConfig(*MAKE_FML);

	close(CF);

	print "Configuration is saved in $cf\n";
    }
}

sub Uniq
{
    local(*config) = @_;
    local(@new, %uniq);

    for (@config) {
	push(@new, $_) unless $uniq{$_}; 
	$uniq{$_} = 1;
    }
    @config = @new;
}

sub PerlModuleExistP
{
    local($pm) = @_;
    if ($] !~ /^5\./) { &Log("Error: using $pm requires perl 5"); return 0;}
    eval("use $pm");
    if ($@) { &Log("${pm}5.pm NOT FOUND; Please install ${pm}.pm"); return 0;}
    1;
}

sub MakeConfigPH
{
    local($config, $manifest, $cf, $config_ph) = @_;
    local($perl);

    $perl = &search_path('perl');

    if (! $perl) { 
	&Log("Error: makefml cannot find perl");
	print STDERR "I cannot find perl!! Dead Ends!\n";
	print STDERR "Hence I cannot make config.ph.\n";
	return "";
    }

    print STDERR "Generating $config_ph from $cf ...\n";

    for ($config, $manifest, $cf) { # config.ph may not exist; 
	if (! -e $_) {
	    print STDERR "***Error: I Cannot find $_, Stop.\n";
	    return 0;
	}
    }

    if (! open(EXEC_CF, "$perl $config -m $manifest $cf|")) {
	&Log("Error: cannot exec $config -m $manifest $cf");
	&Warn("cannot exec $config -m $manifest $cf");
	return 0;
    }

    open(SAVE, "> $config_ph") || (&Log("cannot write $config_ph"), return 0);
    select(SAVE); $| = 1; select(STDOUT);

    while (<EXEC_CF>) { print SAVE $_;}

    close(SAVE);
    close(EXEC_CF);

    print STDERR "Done.\n\n";
}


sub do_addadmin
{
    $AdminMode = 1;
    &do_adduser(@_);
    $AdminMode = 0;
}

sub do_byeadmin
{
    $AdminMode = 1;
    &do_byeuser(@_);
    $AdminMode = 0;
}

sub do_adduser
{
    local($ml, $member) = @_;
    local(@files);
    local($proc) = $fp;
    $proc =~ s/do_//;

    if (! $ml || !$member) {
	&Log("Error: makefml::$proc invalid arguments");
	&Debug("*** Syntax Error: the number of arguments ***");
	&Debug("\n\tmakefml $proc ML address\n");
	return;
    }

    &SetWritableUmask;

    print "---Adding $member to $ml mailing list\n";

    if ($AdminMode) {
	@files = ("$ML_DIR/$ml/members-admin");
    }
    else {
	@files = ("$ML_DIR/$ml/members", "$ML_DIR/$ml/actives");
    }

    &ResetVariables;

    # mkdir ML Directory
    if (! -d "$ML_DIR/$ml") {
	&Log("Error: makefml::$proc cannot find $ML_DIR/$ml");
	print "\n*****Error: $ml ML NOT CREATED\n";
	print "   Firstly,please do \"perl makefml newml $ml\"!\n";
	return;
    }

    # add 
    for (@files) {
	&Log("makefml::$proc append $member to $_");
	print "Append $member to $_\n" if $debug;
	&AppendString2File($member, $_);
    }
}


sub do_byeuser
{
    local($ml, $member) = @_;
    local(@files);
    local($proc) = $fp;
    $proc =~ s/do_//;

    if (! $ml || !$member) {
	&Log("Error: makefml::$proc invalid arguments");
	&Debug("*** Syntax Error: the number of arguments ***");
	&Debug("\n\tmakefml $proc ML address\n");
	return;
    }

    print "---Delete $member in $ml mailing list\n";

    &SetWritableUmask;

    if ($AdminMode) {
	@files = ("$ML_DIR/$ml/members-admin");
    }
    else {
	@files = ("$ML_DIR/$ml/members", "$ML_DIR/$ml/actives");
    }

    &ResetVariables;

    # mkdir ML Directory
    if (! -d "$ML_DIR/$ml") {
	&Log("Error: makefml::$proc cannot find $ML_DIR/$ml");
	print "***Error: $ml ML NOT CREATED\n";
	print "   Firstly,please do \"perl makefml newml $ml\"!\n";
	return;
    }

    # delete 
    for (@files) {
	if (&Repl($member, $_)) {
	    &Log("makefml::$proc delete $member of $_");
	    print "Delete $member in $_\n" if $debug;
	}
    }
}


sub do_fmlserv
{
    print "---Configure fmlserv mailing list ... \n";

    # special assigned ML;
    $ml = "fmlserv";

    &GenerateDirectory($ml);
    &ResetVariables;

    ### cf file; 
    &ResetVariables;

    &SetPublicUmask;

    # include file is public readable;
    # why for () fails?;
    local($exec_dir) = "$EXEC_DIR/etc/makefml";
    &Conv($ml, "$exec_dir/fmlserv-config.ph", "$ML_DIR/$ml/config.ph");
    &Conv($ml, "$exec_dir/fmlserv-include", "$ML_DIR/$ml/include");
    &Conv($ml, "$exec_dir/fmlserv-aliases", "$ML_DIR/$ml/aliases");

    &SetPersonalUmask;
    &Conv($ml, "$exec_dir/fmlserv-fml.c",   "$ML_DIR/$ml/fml.c");
    &FixIncludeHeader;

    # fmlserv (uid != owner ) can read help
    ($GroupWritable eq 'fmlserv') ? umask(027) : umask(077);

    &Conv($ml, "$EXEC_DIR/drafts/help-fmlserv", "$ML_DIR/fmlserv/help");

    # the last info
    print "\n   Please see several examples in $ML_DIR/$ml\n";
    print "\n# Example of Aliases ($ML_DIR/$ml/aliases)\n";
    &Cat("$ML_DIR/$ml/aliases");
    print "\n";
}


sub SetWritableUmask
{
    if ($GroupWritable eq 'fmlserv') {
	umask(007);
    }
    else {
	umask(077);	
    }
}

sub SetPersonalUmask
{
    umask(077);
}

sub SetPublicUmask
{
    umask(022);
}

sub GetGID
{
    local($gid);

    $gid = (getgrnam($_[0]))[2];
    print STDERR "Error: No such group '$_[0]'\n" if $gid eq '';
    $gid;
}

sub MakeWritableDir
{
    if ($GroupWritable) {	# for backup files
	-d $_[0] || mkdir($_[0], 0775);
	chown $<, $GID, $_[0] if $GID ne '';
	&SetGidBit($_[0]);
    }
    else {
	-d $_[0] || mkdir($_[0], 0755);
	&SetGidBit($_[0]);
    }
}

sub MakeDir
{
    local($info) = " GID=$GID" if $GID ne '';
    print "---Make Directory ($_[0])\t(UID=$<$info)\n";

    if ($GroupWritable eq 'fmlserv') {	# for backup files
	-d $_[0] || mkdir($_[0], 0775);
	chown $<, $GID, $_[0] if $GID ne '';
	&SetGidBit($_[0]);
    }
    else {
	-d $_[0] || mkdir($_[0], 0755);
	&SetGidBit($_[0]);
    }
}

sub MakeSubDir
{
    local($info) = " GID=$GID" if $GID ne '';
    print "---Make Directory ($_[0])\t(UID=$<$info)\n";

    if ($GroupWritable eq 'fmlserv') {	# for backup files
	-d $_[0] || mkdir($_[0], 0770);
	chown $<, $GID, $_[0] if $GID ne '';
	&SetGidBit($_[0]);
    }
    else {
	-d $_[0] || mkdir($_[0], 0700);
    }
}


sub SetGidBit
{
    local($file) = @_;
    local($mode);

    return if $OS_TYPE eq 'BSD44';
    return if $CPU_TYPE_MANUFACTURER_OS =~ /netbsd|bsdi/;

    $mode = (stat($file))[2];
    $mode = $mode | 02000;
    chmod $mode, $file;
}




#################################################################
package dumpvar;

sub main'Dumpvar 
{
    ($package, @vars) = @_;

    $package = 'Config';

    if ($] =~ /5\.\d\d\d/) { 
	*stab = *{"${package}::"}; # syntax Error? but this {} is required;
    }
    else {
	(*stab) = eval("*_$package");
    }

    while (($key, $val) = each(%stab)) {
	{
	    next if @vars && !grep($key eq $_,@vars);
	    local(*entry) = $val;

	    if (defined $entry) {
		$buf .= "\$$key = '$entry';\n";
	    }

	    if (defined @entry) {
		$buf .= "\@$key = (\n";
		foreach $num ($[ .. $#entry) {
		    $buf .= "  $num\t'$entry[$num]'\n";
		}
		$buf .= ");\n";
	    }

	    if ((($] !~ /5\.\d\d\d/) && 
		 $key ne "_$package" && $key ne "_DB" && defined %entry
		 )
		||
		(($] =~ /5\.\d\d\d/) && 
		 $key ne "$package::" && $key ne "DB::" && 
		 (defined %entry) && 
		 ($dumpPackages || $key !~ /::$/)
		 && ($key !~ /^_</ || $dumpDBFiles)
		 && !($package eq "dumpvar" && $key eq "stab")
		 )
		) {

		$buf .= "\%$key = (\n";
		foreach $key (sort keys(%entry)) {
		    $buf .= "\t '$key', '$entry{$key}', \n";
		}
		$buf .= ");\n";
	    }
	}
    }

    return $buf;
}

# here is in "package dumpvar";


package ml;

sub ml'Log       { &main'Log(@_);}
sub main'FLock   { &ml'FLock(@_);}
sub main'FUnLock { &ml'FUnLock(@_);}

###
### from libkern.pl
###

### %FLockP and %FLockFile; 

# lock algorithm using flock system call
# if lock does not succeed,  fml process should exit.
sub FLock
{
    local($ml, $mldir) = @_;
    local($lockdir) = "$mldir/$ml/";
    $lockdir =~ s#$ml/$ml#$ml#;
    $lockdir .= $SPOOL_DIR{$ml} || "spool";
   
    open($lockdir, $lockdir) || do {
	&Log("Error: Flock cannot open $lockdir");
	return 0;
    };

    flock($lockdir, $LOCK_EX);

    $FLockP{$ml}   = 1;
    $LockFile{$ml} = $lockdir;
}


sub FUnLock 
{
    local($ml) = @_;
    local($lockdir) = $LockFile{$ml};

    close($lockdir);
    flock($lockdir, $LOCK_UN);
}


package v7;


sub main'V7Lock   { &v7'MakeFml_V7Lock(@_);}
sub main'V7UnLock { &v7'MakeFml_V7UnLock(@_);}

sub v7'Log        { &main'Log(@_);}
sub v7'Warn       { &main'Warn(@_);}
sub v7'WholeMail  { &main'WholeMail(@_);}
sub v7'SetEvent   { &main'SetEvent(@_);}


sub Mkdir
{
    &Log("makefml::v7::mkdir $_[0]");

    $USE_FML_WITH_FMLSERV ? mkdir($_[0], 0770) : mkdir($_[0], 0700);
    if ($USE_FML_WITH_FMLSERV && $SPOOL_DIR eq $_[0]) { chmod 0750, $_[0];}
    if ($USE_FML_WITH_FMLSERV && $GID) { chown $<, $GID, $_[0];}
}

sub LoadConfigPH
{
    local($ml, $mldir) = @_;

    # reset variables used in liblock.pl
    for (FP_VARLOG_DIR, FP_VARRUN_DIR, LOCK_FILE, MAX_TIMEOUT) {
	eval "undef \$${_};";
    }

    # global $DIR ;
    $DIR = "$mldir/$ml";
    chdir $DIR;

    eval("do \"$mldir/$ml/config.ph\";");
    print STDERR "V7Lock::Error $@\n" if $@;

    # variable fixes
    local($s);
    for (SPOOL_DIR,TMP_DIR,VAR_DIR,VARLOG_DIR,VARRUN_DIR,VARDB_DIR) {
	$s .= "-d \$$_ || &Mkdir(\$$_); \$$_ =~ s#$DIR/##g;\n";
	$s .= "\$FP_$_ = \"$DIR/\$$_\";\n"; # FullPath-ed (FP)
    }
    eval($s) || &Log("FAIL EVAL \$SPOOL_DIR ...");
}

sub MakeFml_V7Lock
{
    local($ml, $mldir) = @_;

    &LoadConfigPH($ml, $mldir);

    require 'liblock.pl';

    print STDERR "LOCK_FILE     $LOCK_FILE\n";
    print STDERR "FP_VARRUN_DIR $FP_VARRUN_DIR\n";

    &V7Lock;

    $FLockP{$ml}   = 0;
    $LockFile{$ml} = $LockFile;
}

sub MakeFml_V7UnLock
{
    local($ml) = @_;

    $LockFile = $LockFile{$ml};

    require 'liblock.pl';
    &V7Unlock;
}


package main;

sub TrySmtpConnect
{
    local($host) = @_;
    local($result, $eval, $perl5_socket_ok);

    ### PERL 5  
    if (0 && $] =~ /^5\./) { 
	eval("use Socket;");
	$perl5_socket_ok = 1 if ($@ eq '');
    }
	
    if ($perl5_socket_ok) {
	; # perl 5 Socket.pm must be O.K.;
    }
    elsif ($OS_TYPE eq 'SOLARIS2' || 
	$CPU_TYPE_MANUFACTURER_OS =~ /solaris2/i) {
	$eval  = "sub AF_INET {2;}; sub PF_INET { 2;};";
	$eval .= "sub SOCK_STREAM {2;}; sub SOCK_DGRAM  {1;};";
	eval $eval;
    }
    else { # 4.4BSD (and 4.x BSD's)
	$eval  = "sub AF_INET {2;}; sub PF_INET { 2;};";
	$eval .= "sub SOCK_STREAM {1;}; sub SOCK_DGRAM  {2;};";
	eval $eval;
    }

    local($pat)    = $STRUCT_SOCKADDR || 'n n a4 x8';
    local($addrs)  = (gethostbyname($host || 'localhost'))[4];
    local($proto)  = (getprotobyname('tcp'))[2];
    local($port)   = $PORT || (getservbyname('smtp', 'tcp'))[2];
    $port          = 25 unless defined($port); # default port

    # Check the possibilities of Errors
    return ($error = "Cannot resolve the IP address[$host]") unless $addrs;
    return ($error = "Cannot resolve proto")                 unless $proto;

    # O.K. pack parameters to a struct;
    local($target) = pack($pat, &AF_INET, $port, $addrs);

    # IPC open
    if (socket(S, &PF_INET, &SOCK_STREAM, $proto)) { 
	$result = "socket ok";
    } 
    else { 
	$VERBOSE_STR = 
	    sprintf("socket(S, %s, %s, %s)", &PF_INET, &SOCK_STREAM, $proto);

	return ($error = "Smtp::socket->Error[$!]");
    }
    
    if (connect(S, $target)) { 
	$result = "connect ok";
     } 
    else { 
	$VERBOSE_STR = sprintf("connect(S, %s, %s, %s, %s)\n",
			       $pat, &AF_INET, $port, $addrs);
	return ($error = "Smtp::connect($host)->Error[$!]");
    }

    $result; # success;
}

sub FYI
{
    local($r, $m);

    $r = &TrySmtpConnect('localhost');

    if ($r eq 'connect ok') {
	# $m .= "OK...sendmail RUN on this machine.\n";
    }
    elsif ($r =~ /Smtp\:\:socket/) {
	$m .= "Hmm... perl's socket() fails on this machine.\n";
	$m .= "($r)\n\n" if $r;

	$m .= "But don't worry!\n";
	$m .= "fml would send mails by 'exec sendmail' NOT IPC.\n";
    }
    elsif ($r =~ /Smtp\:\:connect.*connection refused/) {
	$m .= "Hmm... fml cannot connect sendmail on this machine.\n";
	$m .= "($r)\n\n" if $r;

	$m .= "But don't worry!\n";
	$m .= "fml would send mails by 'exec sendmail' NOT IPC.\n";

	$m .= 
	    "(\$HOST in config.ph should be a machine where sendmail runs)\n";
	$m .= &MX;
    }
    else {
	$m .= "Hmm... fml cannot connect sendmail on this machine.\n";
	$m .= "($r)\n\n" if $r;

	$m .= "But don't worry!\n";
	$m .= "fml would send mails by 'exec sendmail' NOT IPC.\n";
    }

    if ($m || $verbose) {
	$r = "$r\n $VERBOSE_STR" if $verbose;
	$m =~ s/\n/\n   /g;
	$r =~ s/\n/\n   /g;

	print STDERR "\n  For Your Information:\n   $m\n";
    }
}


sub MX
{
    local($mx, $m);
    $mx = `nslookup -q=mx "$DOMAIN."`;
    $m .= "\tsendmail may run in your $DOMAIN:\n";
    for (split(/\n/, $mx)) {
	/mail exchanger\s*=\s*(\S+)/ && ($m .= "\t$1\n");
    }
    $m;
}


sub SetSockAddr
{
    local($ostype) = @_;
    local($r);

    $r = &ProbeSockAddr;

    return if ($r eq 'connect ok');

    if ($ostype =~ /netbsd|bsdi/) {
	$STRUCT_SOCKADDR = "n n a4 x8";
    }
    else {
	$STRUCT_SOCKADDR = "S n a4 x8";
    }
}


sub ProbeSockAddr
{
    local($r);
    local($tab) = "\#probe sockaddr: ";

    for ($STRUCT_SOCKADDR, "n n a4 x8", "S n a4 x8") {
	next unless $_;
	$STRUCT_SOCKADDR = $_;

	$r = &TrySmtpConnect("localhost");

	if ($r eq 'connect ok') { 
	    print STDERR "${tab}OK  '$_'\n" if $verbose;
	    return $r;
	}
	else {
	    if ($verbose) {
		print STDERR "${tab}NOT '$_' ($r $VERBOSE_STR)\n";
	    }
	}
    }
}


sub ProbePerlVersion
{
    open(PERL, "perl -v |");
    while (<PERL>) {
	$UNDER_JPERL = 1 if /jperl/;
    }
    close(PERL);
}


########################################################################
package Menu;

sub Menu'Log        { &main'Log(@_);}


sub InitMenu
{
    (*config, *MENU, *FP, *QUERY, *NAME, *MAP, *BIND, *CONFIG) = @_;

    open(F, $MENU) || die($!);
    while (<F>) {
	next if /^\#/;

	if (/^==/) {
	    &Reset;
	    next;
	}
	elsif (/^\/(.*)/) {
	    $hier  = "/";
	    $hier .= join("/", split(/\//, $1));
	    next;
	}
	elsif (/^=menu/) {
	    &Reset;
	    $menu_p = 1;
	    next;
	}
	elsif (/^=name/) {
	    &Reset;
	    $name_p = 1;
	    next;
	}
	elsif (/^=map/) {
	    &Reset;
	    $map_p = 1;
	    next;
	}
	elsif (/^=query/) {
	    &Reset;
	    $query_p = 1;
	    next;
	}
	elsif (/^=config/) {
	    &Reset;
	    $config_p = 1;
	    next;
	}


	if ($menu_p) {
	    # this Name Space Global
	    $MenuTemplate{$hier} .= $_;
	}
	elsif ($query_p) {
	    $QUERY{$hier} .= $_;
	}
	elsif ($config_p) {
	    s/\s//g;
	    $CONFIG{$hier} .= $_ if $_ !~ /^\s*$/;
	}
	elsif ($name_p) {
	    next if /^\s*$/;
	    $_ =~ s/^\s+//;
	    s/\n$//g;
	    $NAME{$hier} .= $_;
	}
	elsif ($map_p) {
	    $_ =~ s/^\s+//;
	    $MAP{$hier} .= $_;
	}
    }

    close(F);

    for $menu (keys %MenuTemplate){
	&EvalMenu($menu, *config, *BIND, *MENU, *COUNT, *MAP);
    }
}

sub main'EvalMenu { &EvalMenu(@_);} #";
sub EvalMenu
{
    local($menu, *config, *BIND, *MENU, *COUNT, *MAP) = @_;
    local($buf);

    # global
    $Count = 0;

    # useful config for menu (dynamic generation)
    $SUMMARY{'REMOTE_ADMINISTRATION'} = 
	$config{'REMOTE_ADMINISTRATION'} ? "yes" : "no";

    $SUMMARY{'SPOOLING'} = 
	$config{'NOT_USE_SPOOL'} ? "not spooling" : "spooling";

    $SUMMARY{'CONTROL_ADDRESS'} = 
	$config{'CONTROL_ADDRESS'} || "*** Command Unavailable ***";


    for (split(/\n/, $MenuTemplate{$menu})) {
	# substitute
	if (/_i_\s+(\S+)/) {
	    s/(_i_\s+\S+)/&Bind(*BIND, $1, $menu)/e;
	}
	s/^\s/   /;
	$buf .= "$_\n";
    }

    # menu evaluator
    eval("\$buf = \"$buf\";");

    $buf =~ s/(\s)1\s*\n/$1USE\n/g;
    $buf =~ s/(\s)0\s*\n/$1NOT USE\n/g;
    $buf =~ s/\$DOMAINNAME/$config{'DOMAINNAME'}/g;
    $buf =~ s/\$FQDN/$config{'FQDN'}/g;


    $MENU{$menu}  = $buf;
    $COUNT{$menu} = $Count;

    for (split(/\n/, $MAP{$menu})) {
	if (/^\s*(\S+)\s*(.*)\s*$/) {
	    $MAP{$menu, $1} = $2;
	    $MAP{$menu, $1} =~ s/\$config{\'_ML_\'}/$config{'_ML_'}/g;
	}
    }
}


sub GenQuery
{
    local(*query, $s, $menu) = @_;
    local($type, $pat);

    undef %query;
    print STDERR "GenQuery:\n$s\n" if $debug;

    for (split(/\n/, $s)) {
	if (/(\S+):\s+(.*)\s*$/) {
	    $query{$1} = $2;
	}
    }
    
    # "type", "menu", "query", "pat", "default"
    $type = $query{"type"};

    if ($type eq "y-or-n" || $type eq "reverse-y-or-n") {
	$query{"menu"}    = $query{"menu"}    || "Use this option?";
	$query{"query"}   = $query{"query"}   || "y/n";
	$query{"pat"}     = $query{"pat"}     || "y|n";
	$query{"default"} = $query{"default"} || "n";
    }
    elsif ($type eq "select") {
	$max = $COUNT{$menu} - 1;
	for (0 .. $max) { $pat .= $pat ne "" ? "|$_" : $_;}

	$max  = $max == 1 ?  "0-1" : "0-$max";

	$query{"menu"}    = $query{"menu"}    || "Which section?";
	$query{"query"}   = $query{"query"}   || $max;
	$query{"pat"}     = $query{"pat"}     || $pat;
	$query{"default"} = $query{"default"} || 0;
    }

}


sub Reset
{
    undef $menu_p;
    undef $query_p;
    undef $name_p;
    undef $map_p;
    undef $config_p;
}


sub Bind
{
    local(*bind, $s, $menu) = @_;
    local($index, $label);

    if ($s =~ /(_i_\s+)(\S+)/) {
	$index = $1;
	$label = $2;

	$index =~ s/_i_/sprintf("%-3s", $Count)/ge;
	$bind{$menu, $Count} = $label;

	# return value is rewritten .
	$label = $NAME{"/$label"} || $label;
    }

    $Count++;

    return "${index}${label}";
}


exit 0;


1;
